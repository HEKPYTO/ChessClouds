This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
axum/
  src/
    main.rs
  Cargo.toml
  Dockerfile
fastapi/
  Dockerfile
  main.py
stockfish/
  Dockerfile
docker-compose.yml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="axum/src/main.rs">
use axum::{
    extract::Query,
    routing::get,
    http::StatusCode,
    Json, Router,
};
use serde::{Deserialize, Serialize};
use std::io::{Read, Write};
use std::net::TcpStream;
use std::time::{Duration, Instant};
use regex::Regex;
use shakmaty::{fen::Fen, Move, Square, Chess};

#[tokio::main]
async fn main() {
    let app = Router::new()
        .route("/", get(root))
        .route("/test", get(test_stockfish_connection))
        .route("/bestmove", get(get_best_move));

    let listener = tokio::net::TcpListener::bind("0.0.0.0:4000").await.unwrap();
    println!("Listening on: {}", listener.local_addr().unwrap());
    axum::serve(listener, app).await.unwrap();
}

#[derive(Serialize)]
struct MessageResponse {
    message: String,
}

async fn root() -> Json<MessageResponse> {
    Json(MessageResponse {
        message: "Stockfish API is running".to_string(),
    })
}

#[derive(Serialize)]
struct TestResponse {
    status: String,
    message: String,
    response: String,
}

async fn test_stockfish_connection() -> Result<Json<TestResponse>, (StatusCode, String)> {
    match connect_to_stockfish() {
        Ok(mut sock) => {
            if let Err(e) = send_command(&mut sock, "uci") {
                return Err((StatusCode::INTERNAL_SERVER_ERROR, e.to_string()));
            }
            
            match receive_until(&mut sock, "uciok", Duration::from_secs(30)) {
                Ok(response) => {
                    Ok(Json(TestResponse {
                        status: "success".to_string(),
                        message: "Connected to Stockfish successfully".to_string(),
                        response,
                    }))
                },
                Err(e) => Err((StatusCode::INTERNAL_SERVER_ERROR, e.to_string())),
            }
        },
        Err(e) => Err((StatusCode::INTERNAL_SERVER_ERROR, format!("Failed to connect to Stockfish: {}", e))),
    }
}

#[derive(Deserialize)]
struct BestMoveQuery {
    fen: String,
}

#[derive(Serialize)]
struct BestMoveResponse {
    best_move: String,
    new_fen: String,
}

#[derive(Serialize)]
struct ErrorResponse {
    status: String,
    message: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    best_move: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    raw_response: Option<String>,
}

async fn get_best_move(Query(params): Query<BestMoveQuery>) -> Result<Json<serde_json::Value>, (StatusCode, String)> {
    if params.fen.is_empty() {
        return Err((StatusCode::BAD_REQUEST, "Missing 'fen' parameter".to_string()));
    }

    match connect_to_stockfish() {
        Ok(mut sock) => {
            if let Err(e) = send_command(&mut sock, "uci") {
                return Err((StatusCode::INTERNAL_SERVER_ERROR, e.to_string()));
            }
            
            if let Err(e) = receive_until(&mut sock, "uciok", Duration::from_secs(30)) {
                return Err((StatusCode::INTERNAL_SERVER_ERROR, e.to_string()));
            }
            
            if let Err(e) = send_command(&mut sock, "isready") {
                return Err((StatusCode::INTERNAL_SERVER_ERROR, e.to_string()));
            }
            
            if let Err(e) = receive_until(&mut sock, "readyok", Duration::from_secs(30)) {
                return Err((StatusCode::INTERNAL_SERVER_ERROR, e.to_string()));
            }
            
            let position_cmd = format!("position fen {}", params.fen);
            if let Err(e) = send_command(&mut sock, &position_cmd) {
                return Err((StatusCode::INTERNAL_SERVER_ERROR, e.to_string()));
            }
            
            if let Err(e) = send_command(&mut sock, "go depth 20") {
                return Err((StatusCode::INTERNAL_SERVER_ERROR, e.to_string()));
            }
            
            match receive_until(&mut sock, "bestmove", Duration::from_secs(30)) {
                Ok(response) => {
                    let re = Regex::new(r"bestmove\s+(\w+)").unwrap();
                    if let Some(caps) = re.captures(&response) {
                        let best_move = caps.get(1).unwrap().as_str();
                        
                        // Try to parse the FEN and apply the move
                        match Fen::from_ascii(params.fen.as_bytes()) {
                            Ok(fen) => {
                                match Chess::from_setup(fen.into_setup(), shakmaty::CastlingMode::Standard) {
                                    Ok(mut pos) => {
                                        // Try to parse the UCI move string into a Move
                                        let m_src = best_move.get(0..2).unwrap_or("");
                                        let m_dst = best_move.get(2..4).unwrap_or("");
                                        
                                        // Basic conversion from UCI to SAN format for the shakmaty library
                                        if let (Ok(src), Ok(dst)) = (m_src.parse(), m_dst.parse()) {
                                            let legal_moves = pos.legal_moves();
                                            let mv = legal_moves.iter().find(|m| 
                                                m.from() == Some(src) && m.to() == dst
                                            );
                                            
                                            if let Some(mv) = mv {
                                                pos.play_unchecked(mv);
                                                let new_fen = Fen::from_setup(pos.into_setup(), shakmaty::EnPassantMode::Legal).to_string();
                                                
                                                let response = BestMoveResponse {
                                                    best_move: best_move.to_string(),
                                                    new_fen,
                                                };
                                                Ok(Json(serde_json::to_value(response).unwrap()))
                                            } else {
                                                let error = ErrorResponse {
                                                    status: "error".to_string(),
                                                    message: "Best move is not legal in the given position".to_string(),
                                                    best_move: Some(best_move.to_string()),
                                                    raw_response: None,
                                                };
                                                Ok(Json(serde_json::to_value(error).unwrap()))
                                            }
                                        } else {
                                            let error = ErrorResponse {
                                                status: "error".to_string(),
                                                message: "Could not parse move coordinates".to_string(),
                                                best_move: Some(best_move.to_string()),
                                                raw_response: None,
                                            };
                                            Ok(Json(serde_json::to_value(error).unwrap()))
                                        }
                                    },
                                    Err(e) => {
                                        let error = ErrorResponse {
                                            status: "error".to_string(),
                                            message: format!("Could not create position from FEN: {}", e),
                                            best_move: Some(best_move.to_string()),
                                            raw_response: None,
                                        };
                                        Ok(Json(serde_json::to_value(error).unwrap()))
                                    }
                                }
                            },
                            Err(e) => {
                                let error = ErrorResponse {
                                    status: "error".to_string(),
                                    message: format!("Invalid FEN format: {}", e),
                                    best_move: Some(best_move.to_string()),
                                    raw_response: None,
                                };
                                Ok(Json(serde_json::to_value(error).unwrap()))
                            }
                        }
                    } else {
                        let error = ErrorResponse {
                            status: "error".to_string(),
                            message: "Could not find best move in response".to_string(),
                            best_move: None,
                            raw_response: Some(response),
                        };
                        Ok(Json(serde_json::to_value(error).unwrap()))
                    }
                },
                Err(e) => Err((StatusCode::INTERNAL_SERVER_ERROR, format!("Error: {}", e))),
            }
        },
        Err(e) => Err((StatusCode::INTERNAL_SERVER_ERROR, format!("Error: {}", e))),
    }
}

fn connect_to_stockfish() -> Result<TcpStream, std::io::Error> {
    let host = "stockfish";
    let port = 4001;
    let addr = format!("{}:{}", host, port);
    let stream = TcpStream::connect(&addr)?;
    stream.set_read_timeout(Some(Duration::from_secs(10)))?;
    stream.set_write_timeout(Some(Duration::from_secs(10)))?;
    Ok(stream)
}

fn send_command(stream: &mut TcpStream, command: &str) -> Result<(), std::io::Error> {
    let command = format!("{}\n", command);
    stream.write_all(command.as_bytes())?;
    Ok(())
}

fn receive_until(stream: &mut TcpStream, marker: &str, timeout: Duration) -> Result<String, String> {
    let start = Instant::now();
    let mut buffer = String::new();
    
    while start.elapsed() < timeout {
        let mut chunk = [0; 4096];
        match stream.read(&mut chunk) {
            Ok(n) if n > 0 => {
                let data = String::from_utf8_lossy(&chunk[0..n]).to_string();
                buffer.push_str(&data);
                if buffer.contains(marker) {
                    return Ok(buffer);
                }
            },
            Ok(_) => {
                std::thread::sleep(Duration::from_millis(100));
            },
            Err(ref e) if e.kind() == std::io::ErrorKind::WouldBlock || e.kind() == std::io::ErrorKind::TimedOut => {
                std::thread::sleep(Duration::from_millis(100));
            },
            Err(e) => return Err(format!("Failed to read from socket: {}", e)),
        }
    }
    
    Err(format!("Timeout waiting for '{}'", marker))
}
</file>

<file path="axum/Cargo.toml">
[package]
name = "stockfish-api"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = "0.7"
tokio = { version = "1", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tower = "0.4"
regex = "1.10"
shakmaty = { version = "0.26", features = ["variant"] }
</file>

<file path="axum/Dockerfile">
FROM rust:1.75-alpine AS builder

WORKDIR /app
RUN apk add --no-cache musl-dev

COPY Cargo.toml .
COPY src src
RUN cargo build --release

FROM alpine:latest
WORKDIR /app
COPY --from=builder /app/target/release/stockfish-api .

EXPOSE 4000

CMD ["./stockfish-api"]
</file>

<file path="fastapi/Dockerfile">
FROM python:3.11-alpine

WORKDIR /app

RUN pip install fastapi uvicorn[standard] python-chess
COPY . .

EXPOSE 4000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "4000"]
</file>

<file path="fastapi/main.py">
from fastapi import FastAPI, HTTPException
import socket
import time
import re
import chess

app = FastAPI()

def connect_to_stockfish(host="stockfish", port=4001, timeout=10):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(timeout)
    try:
        sock.connect((host, port))
        return sock
    except Exception as e:
        raise Exception(f"Failed to connect to Stockfish: {str(e)}")

def send_command(sock, command):
    try:
        sock.sendall(f"{command}\n".encode('utf-8'))
    except Exception as e:
        raise Exception(f"Failed to send command: {str(e)}")

def receive_until(sock, marker, timeout=30):
    start_time = time.time()
    buffer = ""
    while time.time() - start_time < timeout:
        try:
            data = sock.recv(4096).decode('utf-8')
            if not data:
                time.sleep(0.1)
                continue
            buffer += data
            if marker in buffer:
                return buffer
        except socket.timeout:
            time.sleep(0.1)
    raise Exception(f"Timeout waiting for '{marker}'")

@app.get("/")
def read_root():
    return {"message": "Stockfish API is running"}

@app.get("/test")
def test_stockfish_connection():
    try:
        sock = connect_to_stockfish()
        send_command(sock, "uci")
        response = receive_until(sock, "uciok")
        sock.close()
        return {"status": "success", "message": "Connected to Stockfish successfully", "response": response}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/bestmove")
def get_best_move(fen: str):
    if not fen:
        raise HTTPException(status_code=400, detail="Missing 'fen' parameter")
    try:
        sock = connect_to_stockfish()
        send_command(sock, "uci")
        receive_until(sock, "uciok")
        send_command(sock, "isready")
        receive_until(sock, "readyok")
        send_command(sock, f"position fen {fen}")
        send_command(sock, "go depth 20")
        response = receive_until(sock, "bestmove")
        sock.close()
        match = re.search(r'bestmove\s+(\w+)', response)
        if match:
            best_move = match.group(1)
            board = chess.Board(fen)
            move = chess.Move.from_uci(best_move)
            if move in board.legal_moves:
                board.push(move)
                new_fen = board.fen()
                return {"best_move": best_move, "new_fen": new_fen}
            else:
                return {"status": "error", "message": "Best move is not legal in the given position", "best_move": best_move}
        else:
            return {"status": "error", "message": "Could not find best move in response", "raw_response": response}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error: {str(e)}")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=4000)
</file>

<file path="stockfish/Dockerfile">
FROM alpine:edge AS builder

RUN apk update && apk add --no-cache git make g++ wget
RUN git clone https://github.com/official-stockfish/Stockfish.git
WORKDIR /Stockfish/src
RUN make -j$(nproc) profile-build ARCH=x86-64-bmi2

FROM alpine:edge
RUN apk update && apk add --no-cache libstdc++ libgcc socat
COPY --from=builder /Stockfish/src/stockfish /usr/local/bin/stockfish
WORKDIR /usr/local/bin
EXPOSE 4001

CMD ["socat", "TCP-LISTEN:4001,reuseaddr,fork,bind=0.0.0.0", "EXEC:/usr/local/bin/stockfish,pty,raw"]
</file>

<file path="docker-compose.yml">
services:
  stockfish:
    build:
      context: ./stockfish
      dockerfile: Dockerfile
    container_name: stockfish
    ports:
      - "4001:4001"
    networks:
      - engine
      
  axum:
    build:
      context: ./axum
      dockerfile: Dockerfile
    container_name: axum
    ports:
      - "4000:4000"
    depends_on:
      - stockfish
    networks:
      - engine

networks:
  engine:
    driver: bridge
</file>

</files>
