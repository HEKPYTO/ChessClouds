This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/
  workflows/
    upload-image.yml
    web-test-build.yml
engine/
  hyper/
    src/
      main.rs
    Cargo.toml
    Dockerfile
  stockfish/
    Dockerfile
  .gitignore
  docker-compose.yml
matchmaking/
  .sqlx/
    query-ec85b4b4b0c3731794ac31c9233de52c839d8cc2cea517341b72acfa0edff1e8.json
  bindings/
    Color.ts
    MatchRequest.ts
    MatchResponse.ts
  src/
    main.rs
  .gitignore
  Cargo.toml
web/
  prisma/
    schema.prisma
  src/
    app/
      actions/
        gameActions.ts
      computer/
        page.tsx
      dashboard/
        page.tsx
      debug/
        page.tsx
      game/
        page.tsx
      home/
        page.tsx
      signin/
        page.tsx
      signout/
        page.tsx
      signup/
        page.tsx
      socket/
        page.tsx
      globals.css
      layout.tsx
      not-found.tsx
      page.tsx
    components/
      dashboard/
        Friend.tsx
        Game.tsx
        Overview.tsx
      ui/
        badge.tsx
        button.tsx
        card.tsx
        carousel.tsx
        input.tsx
        separator.tsx
        sonner.tsx
      ChessBoard.tsx
      ChessCloud.tsx
      ChessNotations.tsx
      ComputerGamePane.tsx
      DisplayChessBoard.tsx
      Error.tsx
      Footer.tsx
      GamePane.tsx
      LoadingScreen.tsx
      NavBar.tsx
      RouteProtection.tsx
      SocketGamePane.tsx
      ThemeSwitch.tsx
      Unauthorized.tsx
    lib/
      auth/
        googleAuth.ts
      ClientLayout.tsx
      engine.ts
      gameService.ts
      LoadingContext.tsx
      MatchmakingContext.tsx
      matchmakingService.ts
      prisma.ts
      socketService.ts
      time.ts
      utils.ts
    types/
      dashboard-props.ts
      engineTypes.ts
      game-types.ts
      googleAuthTypes.ts
      react-chessground.d.ts
      shared.ts
      socket-types.ts
  .dockerignore
  .gitignore
  components.json
  Dockerfile
  eslint.config.mjs
  next.config.ts
  package.json
  postcss.config.mjs
  README.md
  tailwind.config.js
  tsconfig.json
ws_server/
  .sqlx/
    query-1f362cae8748b36d7ff12321241464c77cbbef1f4b166060686ddd18b29d2507.json
    query-abee11b95d025cec50eeb7d12fbbad1379043ae1529773a971d59e5ee9afa658.json
  bindings/
    ClientMessage.ts
    Color.ts
    Error.ts
    InitBody.ts
    Outcome.ts
    ServerMessage.ts
  src/
    bin/
      client_disconnect.rs
      client.rs
      test.rs
    route/
      games.rs
      init.rs
      ws.rs
    lib.rs
    main.rs
    message.rs
    route.rs
    state.rs
  .dockerignore
  .gitignore
  Cargo.toml
  Dockerfile
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/web-test-build.yml">
name: Code check and build

on:
  push:
    paths:
      - 'web/**'
    branches: ['*']
  pull_request:
    paths:
      - 'web/**'
    branches: ['*']

jobs:
  lint:
    name: Check linting
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: web
    steps:
      - uses: actions/checkout@v4
      - uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest
      - run: bun install
      - run: bun lint

  build:
    name: Production build
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: web
    steps:
      - uses: actions/checkout@v4
      - uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest
      - run: bun install
      - run: bun run build

  secrets_scan:
    name: GitLeaks Secret Scan
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: web
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run GitLeaks scan
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
</file>

<file path="web/src/app/globals.css">
@import 'tailwindcss';
@import 'tw-animate-css';

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

.cg-wrap coords {
  color: #92400e !important;
}

.brown .cg-wrap {
  background-image: none !important;
}

.cg-wrap {
  --cg-coord-color-white: #fef3c7 !important;
  --cg-coord-color-black: #92400e !important;
  --cg-coord-shadow: none !important;
}

.brown .cg-wrap square.light {
  background-color: #fef3c7 !important;
}
.brown .cg-wrap square.dark {
  background-color: #b45309 !important;
}

.cg-wrap square.move-dest {
  background: radial-gradient(rgba(217, 119, 6, 0.4) 19%, transparent 0);
}

.cg-wrap square.move-dest:hover {
  background: radial-gradient(rgba(217, 119, 6, 0.7) 19%, transparent 0);
}

.cg-wrap piece.dragging {
  cursor: grabbing;
  z-index: 10;
}

.cg-wrap piece {
  cursor: grab;
}

.cg-wrap square.last-move {
  background-color: rgba(217, 119, 6, 0.3) !important;
}

.cg-wrap square.selected {
  background-color: rgba(217, 119, 6, 0.4) !important;
}

.chess-board-container {
  box-shadow: 0 10px 30px -5px rgba(0, 0, 0, 0.1);
  border-radius: 0.375rem;
  overflow: hidden;
}

.cg-wrap square.check {
  background-color: rgba(255, 73, 60, 0.75) !important;
}
</file>

<file path="web/src/components/ui/badge.tsx">
import * as React from 'react';
import { Slot } from '@radix-ui/react-slot';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';

const badgeVariants = cva(
  'inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden',
  {
    variants: {
      variant: {
        default:
          'border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90',
        secondary:
          'border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90',
        destructive:
          'border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60',
        outline:
          'text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
);

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<'span'> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : 'span';

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  );
}

export { Badge, badgeVariants };
</file>

<file path="web/src/components/ui/card.tsx">
import * as React from 'react';

import { cn } from '@/lib/utils';

function Card({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card"
      className={cn(
        'bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm',
        className
      )}
      {...props}
    />
  );
}

function CardHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        '@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6',
        className
      )}
      {...props}
    />
  );
}

function CardTitle({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-title"
      className={cn('leading-none font-semibold', className)}
      {...props}
    />
  );
}

function CardDescription({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-description"
      className={cn('text-muted-foreground text-sm', className)}
      {...props}
    />
  );
}

function CardAction({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        'col-start-2 row-span-2 row-start-1 self-start justify-self-end',
        className
      )}
      {...props}
    />
  );
}

function CardContent({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-content"
      className={cn('px-6', className)}
      {...props}
    />
  );
}

function CardFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-footer"
      className={cn('flex items-center px-6 [.border-t]:pt-6', className)}
      {...props}
    />
  );
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
};
</file>

<file path="web/src/components/ui/carousel.tsx">
'use client';

import * as React from 'react';
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from 'embla-carousel-react';
import { ArrowLeft, ArrowRight } from 'lucide-react';

import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';

type CarouselApi = UseEmblaCarouselType[1];
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>;
type CarouselOptions = UseCarouselParameters[0];
type CarouselPlugin = UseCarouselParameters[1];

type CarouselProps = {
  opts?: CarouselOptions;
  plugins?: CarouselPlugin;
  orientation?: 'horizontal' | 'vertical';
  setApi?: (api: CarouselApi) => void;
};

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0];
  api: ReturnType<typeof useEmblaCarousel>[1];
  scrollPrev: () => void;
  scrollNext: () => void;
  canScrollPrev: boolean;
  canScrollNext: boolean;
} & CarouselProps;

const CarouselContext = React.createContext<CarouselContextProps | null>(null);

function useCarousel() {
  const context = React.useContext(CarouselContext);

  if (!context) {
    throw new Error('useCarousel must be used within a <Carousel />');
  }

  return context;
}

function Carousel({
  orientation = 'horizontal',
  opts,
  setApi,
  plugins,
  className,
  children,
  ...props
}: React.ComponentProps<'div'> & CarouselProps) {
  const [carouselRef, api] = useEmblaCarousel(
    {
      ...opts,
      axis: orientation === 'horizontal' ? 'x' : 'y',
    },
    plugins
  );
  const [canScrollPrev, setCanScrollPrev] = React.useState(false);
  const [canScrollNext, setCanScrollNext] = React.useState(false);

  const onSelect = React.useCallback((api: CarouselApi) => {
    if (!api) return;
    setCanScrollPrev(api.canScrollPrev());
    setCanScrollNext(api.canScrollNext());
  }, []);

  const scrollPrev = React.useCallback(() => {
    api?.scrollPrev();
  }, [api]);

  const scrollNext = React.useCallback(() => {
    api?.scrollNext();
  }, [api]);

  const handleKeyDown = React.useCallback(
    (event: React.KeyboardEvent<HTMLDivElement>) => {
      if (event.key === 'ArrowLeft') {
        event.preventDefault();
        scrollPrev();
      } else if (event.key === 'ArrowRight') {
        event.preventDefault();
        scrollNext();
      }
    },
    [scrollPrev, scrollNext]
  );

  React.useEffect(() => {
    if (!api || !setApi) return;
    setApi(api);
  }, [api, setApi]);

  React.useEffect(() => {
    if (!api) return;
    onSelect(api);
    api.on('reInit', onSelect);
    api.on('select', onSelect);

    return () => {
      api?.off('select', onSelect);
    };
  }, [api, onSelect]);

  return (
    <CarouselContext.Provider
      value={{
        carouselRef,
        api: api,
        opts,
        orientation:
          orientation || (opts?.axis === 'y' ? 'vertical' : 'horizontal'),
        scrollPrev,
        scrollNext,
        canScrollPrev,
        canScrollNext,
      }}
    >
      <div
        onKeyDownCapture={handleKeyDown}
        className={cn('relative', className)}
        role="region"
        aria-roledescription="carousel"
        data-slot="carousel"
        {...props}
      >
        {children}
      </div>
    </CarouselContext.Provider>
  );
}

function CarouselContent({ className, ...props }: React.ComponentProps<'div'>) {
  const { carouselRef, orientation } = useCarousel();

  return (
    <div
      ref={carouselRef}
      className="overflow-hidden"
      data-slot="carousel-content"
    >
      <div
        className={cn(
          'flex',
          orientation === 'horizontal' ? '-ml-4' : '-mt-4 flex-col',
          className
        )}
        {...props}
      />
    </div>
  );
}

function CarouselItem({ className, ...props }: React.ComponentProps<'div'>) {
  const { orientation } = useCarousel();

  return (
    <div
      role="group"
      aria-roledescription="slide"
      data-slot="carousel-item"
      className={cn(
        'min-w-0 shrink-0 grow-0 basis-full',
        orientation === 'horizontal' ? 'pl-4' : 'pt-4',
        className
      )}
      {...props}
    />
  );
}

function CarouselPrevious({
  className,
  variant = 'outline',
  size = 'icon',
  ...props
}: React.ComponentProps<typeof Button>) {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel();

  return (
    <Button
      data-slot="carousel-previous"
      variant={variant}
      size={size}
      className={cn(
        'absolute size-8 rounded-full',
        orientation === 'horizontal'
          ? 'top-1/2 -left-12 -translate-y-1/2'
          : '-top-12 left-1/2 -translate-x-1/2 rotate-90',
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft />
      <span className="sr-only">Previous slide</span>
    </Button>
  );
}

function CarouselNext({
  className,
  variant = 'outline',
  size = 'icon',
  ...props
}: React.ComponentProps<typeof Button>) {
  const { orientation, scrollNext, canScrollNext } = useCarousel();

  return (
    <Button
      data-slot="carousel-next"
      variant={variant}
      size={size}
      className={cn(
        'absolute size-8 rounded-full',
        orientation === 'horizontal'
          ? 'top-1/2 -right-12 -translate-y-1/2'
          : '-bottom-12 left-1/2 -translate-x-1/2 rotate-90',
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight />
      <span className="sr-only">Next slide</span>
    </Button>
  );
}

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
};
</file>

<file path="web/src/components/ui/separator.tsx">
'use client';

import * as React from 'react';
import * as SeparatorPrimitive from '@radix-ui/react-separator';

import { cn } from '@/lib/utils';

function Separator({
  className,
  orientation = 'horizontal',
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator-root"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        'bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px',
        className
      )}
      {...props}
    />
  );
}

export { Separator };
</file>

<file path="web/src/components/Footer.tsx">
import Link from 'next/link';

export default function Footer() {
  return (
    <footer className="relative border-t border-amber-200/30 dark:border-slate-700/30 py-12 bg-amber-100 dark:bg-slate-800">
      <div
        className="absolute inset-0"
        style={{
          backgroundImage: 'url(/noise.png)',
          backgroundRepeat: 'repeat',
          opacity: 0.025,
        }}
      />
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 relative z-10">
        <div className="flex flex-col md:flex-row justify-between items-center">
          <div className="flex items-center">
            <div className="h-8 w-8 rounded bg-amber-600 dark:bg-amber-500 mr-2"></div>
            <span className="font-semibold text-amber-900 dark:text-amber-100">
              ChessClouds
            </span>
          </div>

          <div className="mt-4 md:mt-0 flex space-x-6">
            <Link
              href="#"
              className="text-sm text-amber-700 hover:text-amber-900 dark:text-amber-300 dark:hover:text-amber-100"
            >
              Privacy
            </Link>
            <Link
              href="#"
              className="text-sm text-amber-700 hover:text-amber-900 dark:text-amber-300 dark:hover:text-amber-100"
            >
              Terms
            </Link>
            <Link
              href="#"
              className="text-sm text-amber-700 hover:text-amber-900 dark:text-amber-300 dark:hover:text-amber-100"
            >
              Contact
            </Link>
          </div>
        </div>
      </div>
    </footer>
  );
}
</file>

<file path="web/src/lib/utils.ts">
import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
</file>

<file path="web/src/types/react-chessground.d.ts">
declare module 'react-chessground' {
  import { FC } from 'react';
  import { Square } from 'chess.js';

  interface ChessgroundProps {
    width?: string;
    height?: string;
    fen?: string;
    orientation?: 'white' | 'black';
    turnColor?: 'white' | 'black';
    check?: boolean;
    lastMove?: [Square, Square];
    selected?: Square;
    coordinates?: boolean;
    autoCastle?: boolean;
    viewOnly?: boolean;
    disableContextMenu?: boolean;
    resizable?: boolean;
    addPieceZIndex?: boolean;
    highlight?: {
      lastMove?: boolean;
      check?: boolean;
    };
    animation?: {
      enabled?: boolean;
      duration?: number;
    };
    movable?: {
      free?: boolean;
      color?: 'white' | 'black' | 'both';
      dests?: Map<Square, Square[]>;
      showDests?: boolean;
      events?: {
        after?: (orig: Square, dest: Square, metadata: unknown) => void;
      };
    };
    premovable?: {
      enabled?: boolean;
      showDests?: boolean;
      castle?: boolean;
      events?: {
        set?: (orig: Square, dest: Square, metadata: unknown) => void;
        unset?: () => void;
      };
    };
    drawable?: {
      enabled?: boolean;
      visible?: boolean;
      defaultSnapToValidMove?: boolean;
      eraseOnClick?: boolean;
      shapes?: unknown[];
      autoShapes?: unknown[];
      brushes?: unknown;
      pieces?: {
        baseUrl?: string;
      };
      onChange?: (shapes: unknown[]) => void;
    };
    onMove?: (from: Square, to: Square) => void;
    onSelect?: (square: Square) => void;
    onMouseOverSquare?: (square: Square) => void;
    onMouseOutSquare?: (square: Square) => void;
    [key: string]: unknown;
  }

  const Chessground: FC<ChessgroundProps>;
  export default Chessground;
}
</file>

<file path="web/.dockerignore">
node_modules
Dockerfile*
docker-compose*
.dockerignore
.git
.gitignore
README.md
LICENSE
.vscode
Makefile
helm-charts
.env
.editorconfig
.idea
coverage*
</file>

<file path="web/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

repomix-output.xml
</file>

<file path="web/components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="web/eslint.config.mjs">
import { dirname } from 'path';
import { fileURLToPath } from 'url';
import { FlatCompat } from '@eslint/eslintrc';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends('next/core-web-vitals', 'next/typescript'),
];

export default eslintConfig;
</file>

<file path="web/postcss.config.mjs">
const config = {
  plugins: ['@tailwindcss/postcss'],
};

export default config;
</file>

<file path="web/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: 'class',
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  plugins: [],
}
</file>

<file path="web/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="ws_server/bindings/ClientMessage.ts">
// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.

export type ClientMessage = { "kind": "Auth", "value": { game_id: string, user_id: string, } } | { "kind": "Move", "value": string };
</file>

<file path="ws_server/bindings/Color.ts">
// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.

export type Color = "Black" | "White";
</file>

<file path="ws_server/bindings/Error.ts">
// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.

export type Error = "Deserialization" | "Unauthorized" | "InvalidTurn" | "InvalidMove";
</file>

<file path="ws_server/bindings/InitBody.ts">
// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.

export type InitBody = { game_id: string, white_user_id: string, black_user_id: string, };
</file>

<file path="ws_server/bindings/Outcome.ts">
// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.
import type { Color } from "./Color";

export type Outcome = { "Decisive": { winner: Color, } } | "Draw";
</file>

<file path="ws_server/bindings/ServerMessage.ts">
// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.
import type { Error } from "./Error";
import type { Outcome } from "./Outcome";

export type ServerMessage = { "kind": "Move", "value": string } | { "kind": "GameEnd", "value": Outcome } | { "kind": "Error", "value": Error } | { "kind": "AuthSuccess" } | { "kind": "MoveHistory", "value": Array<string> };
</file>

<file path="ws_server/src/bin/client_disconnect.rs">
use std::time::Duration;

use futures_util::{
    stream::{SplitSink, SplitStream},
    SinkExt, StreamExt,
};
use tokio::{net::TcpStream, time::sleep};
use tokio_tungstenite::{
    connect_async,
    tungstenite::{Message, Utf8Bytes},
    MaybeTlsStream, WebSocketStream,
};
use ws_server::{message::ClientMessage, route::init::InitBody, HOST};

async fn send_msg(
    writer: &mut SplitSink<WebSocketStream<MaybeTlsStream<TcpStream>>, Message>,
    msg: &ClientMessage,
) -> anyhow::Result<()> {
    let msg = serde_json::to_string(&msg)?;
    writer.send(Message::Text(Utf8Bytes::from(&msg))).await?;
    sleep(Duration::from_millis(500)).await;
    Ok(())
}

async fn handle_read(
    mut reader: SplitStream<WebSocketStream<MaybeTlsStream<TcpStream>>>,
    socket_name: &str,
) {
    while let Some(Ok(msg)) = reader.next().await {
        if let Message::Text(text) = msg {
            println!("{socket_name} received: {}", text.to_string());
        }
    }
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let url = format!("ws://{HOST}/ws",);

    const GAME_ID: &'static str = "123";
    const WHITE_ID: &'static str = "white";
    const BLACK_ID: &'static str = "black";

    // initialize new game
    let init_body = InitBody {
        game_id: GAME_ID.to_string(),
        white_user_id: WHITE_ID.to_string(),
        black_user_id: BLACK_ID.to_string(),
    };

    let client = reqwest::Client::new();
    client
        .post(format!("http://{HOST}/init"))
        .json(&init_body)
        .send()
        .await?;

    let (socket1, _) = connect_async(&url).await?;
    let (mut writer1, reader1) = socket1.split();

    let (socket2, _) = connect_async(&url).await?;
    let (mut writer2, reader2) = socket2.split();

    tokio::spawn(handle_read(reader1, "socket 1"));
    let handle2 = tokio::spawn(handle_read(reader2, "socket 2"));

    send_msg(
        &mut writer1,
        &ClientMessage::Auth {
            game_id: GAME_ID.to_string(),
            user_id: WHITE_ID.to_string(),
        },
    )
    .await?;
    send_msg(
        &mut writer2,
        &ClientMessage::Auth {
            game_id: GAME_ID.to_string(),
            user_id: BLACK_ID.to_string(),
        },
    )
    .await?;

    send_msg(&mut writer1, &ClientMessage::Move("e4".to_string())).await?;
    send_msg(&mut writer2, &ClientMessage::Move("e5".to_string())).await?;

    send_msg(&mut writer1, &ClientMessage::Move("Qh5".to_string())).await?;
    send_msg(&mut writer2, &ClientMessage::Move("Nc6".to_string())).await?;

    // disconnect socket 1
    writer1.close().await?;

    let (socket3, _) = connect_async(&url).await?;
    let (mut writer3, reader3) = socket3.split();

    let handle3 = tokio::spawn(handle_read(reader3, "socket 3"));

    send_msg(
        &mut writer3,
        &ClientMessage::Auth {
            game_id: GAME_ID.to_string(),
            user_id: WHITE_ID.to_string(),
        },
    )
    .await?;

    send_msg(&mut writer3, &ClientMessage::Move("Bc4".to_string())).await?;
    send_msg(&mut writer2, &ClientMessage::Move("Nf6".to_string())).await?;

    send_msg(&mut writer3, &ClientMessage::Move("Qxf7#".to_string())).await?;

    let _ = tokio::join!(handle2, handle3);
    Ok(())
}
</file>

<file path="ws_server/src/bin/client.rs">
use std::time::Duration;

use futures_util::{stream::SplitSink, SinkExt, StreamExt};
use tokio::{net::TcpStream, time::sleep};
use tokio_tungstenite::{
    connect_async,
    tungstenite::{Message, Utf8Bytes},
    MaybeTlsStream, WebSocketStream,
};
use ws_server::{message::ClientMessage, route::init::InitBody, HOST};

async fn send_msg(
    writer: &mut SplitSink<WebSocketStream<MaybeTlsStream<TcpStream>>, Message>,
    msg: &ClientMessage,
) -> anyhow::Result<()> {
    let msg = serde_json::to_string(&msg)?;
    writer.send(Message::Text(Utf8Bytes::from(&msg))).await?;
    sleep(Duration::from_millis(500)).await;
    Ok(())
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let url = format!("ws://{HOST}/ws",);

    const GAME_ID: &'static str = "123";
    const WHITE_ID: &'static str = "white";
    const BLACK_ID: &'static str = "black";

    // initialize new game
    let init_body = InitBody {
        game_id: GAME_ID.to_string(),
        white_user_id: WHITE_ID.to_string(),
        black_user_id: BLACK_ID.to_string(),
    };

    let client = reqwest::Client::new();
    client
        .post(format!("http://{HOST}/init"))
        .json(&init_body)
        .send()
        .await?;

    let (socket1, _) = connect_async(&url).await?;
    let (mut writer1, mut reader1) = socket1.split();

    let (socket2, _) = connect_async(&url).await?;
    let (mut writer2, mut reader2) = socket2.split();

    tokio::spawn(async move {
        while let Some(Ok(msg)) = reader1.next().await {
            if let Message::Text(text) = msg {
                println!("Socket 1 received: {}", text.to_string());
            }
        }
    });

    tokio::spawn(async move {
        while let Some(Ok(msg)) = reader2.next().await {
            if let Message::Text(text) = msg {
                println!("Socket 2 received: {}", text.to_string());
            }
        }
    });

    send_msg(
        &mut writer1,
        &ClientMessage::Auth {
            game_id: GAME_ID.to_string(),
            user_id: WHITE_ID.to_string(),
        },
    )
    .await?;
    send_msg(
        &mut writer2,
        &ClientMessage::Auth {
            game_id: GAME_ID.to_string(),
            user_id: BLACK_ID.to_string(),
        },
    )
    .await?;

    send_msg(&mut writer1, &ClientMessage::Move("e4".to_string())).await?;
    send_msg(&mut writer2, &ClientMessage::Move("e5".to_string())).await?;

    send_msg(&mut writer1, &ClientMessage::Move("Qh5".to_string())).await?;
    send_msg(&mut writer2, &ClientMessage::Move("Nc6".to_string())).await?;

    send_msg(&mut writer1, &ClientMessage::Move("Bc4".to_string())).await?;
    send_msg(&mut writer2, &ClientMessage::Move("Nf6".to_string())).await?;

    send_msg(&mut writer1, &ClientMessage::Move("Qxf7#".to_string())).await?;
    Ok(())
}
</file>

<file path="ws_server/src/bin/test.rs">
use std::time::Duration;

use axum::body::Bytes;
use futures_util::{
    stream::{SplitSink, SplitStream},
    SinkExt, StreamExt,
};
use tokio::{net::TcpStream, time::sleep};
use tokio_tungstenite::{
    connect_async,
    tungstenite::{Message, Utf8Bytes},
    MaybeTlsStream, WebSocketStream,
};
use ws_server::{message::ClientMessage, route::init::InitBody, HOST};

const GAME_ID: &'static str = "game";
const WHITE_ID: &'static str = "white";
const BLACK_ID: &'static str = "black";

async fn send_msg(
    writer: &mut SplitSink<WebSocketStream<MaybeTlsStream<TcpStream>>, Message>,
    msg: ClientMessage,
) -> anyhow::Result<()> {
    let msg = serde_json::to_string(&msg)?;
    writer.send(Message::Text(Utf8Bytes::from(&msg))).await?;
    sleep(Duration::from_millis(500)).await;
    Ok(())
}

fn spawn_reader(mut reader: SplitStream<WebSocketStream<MaybeTlsStream<TcpStream>>>) {
    tokio::spawn(async move {
        while let Some(Ok(Message::Text(text))) = reader.next().await {
            println!("Received: {}", text.to_string());
        }
    });
}

async fn connect_socket(
    url: &str,
) -> anyhow::Result<SplitSink<WebSocketStream<MaybeTlsStream<TcpStream>>, Message>> {
    let (socket, _) = connect_async(url).await?;
    let (writer, reader) = socket.split();

    spawn_reader(reader);

    Ok(writer)
}

async fn test_auth(url: &str) -> anyhow::Result<()> {
    {
        println!("should fail: not Message::Text");
        let mut writer = connect_socket(url).await?;

        writer
            .send(Message::Ping(Bytes::from_static(b"abc")))
            .await?;

        writer.close().await?;
    }
    {
        println!("should fail: deserialization");
        let mut writer = connect_socket(url).await?;

        writer
            .send(Message::Text(Utf8Bytes::from_static("abc")))
            .await?;

        writer.close().await?;
    }
    {
        println!("should fail: not-existent game");
        let mut writer = connect_socket(url).await?;

        send_msg(
            &mut writer,
            ClientMessage::Auth {
                game_id: "abc".to_string(),
                user_id: WHITE_ID.to_string(),
            },
        )
        .await?;

        writer.close().await?;
    }
    {
        println!("should fail: user not black or white");
        let mut writer = connect_socket(url).await?;

        send_msg(
            &mut writer,
            ClientMessage::Auth {
                game_id: GAME_ID.to_string(),
                user_id: "brown".to_string(),
            },
        )
        .await?;

        writer.close().await?;
    }
    {
        println!("should succeed: move, auth white");
        let mut writer = connect_socket(url).await?;

        send_msg(&mut writer, ClientMessage::Move("e4".to_string())).await?;
        send_msg(
            &mut writer,
            ClientMessage::Auth {
                game_id: GAME_ID.to_string(),
                user_id: WHITE_ID.to_string(),
            },
        )
        .await?;

        writer.close().await?;
    }
    {
        println!("should succeed: auth black");
        let mut writer = connect_socket(url).await?;

        send_msg(
            &mut writer,
            ClientMessage::Auth {
                game_id: GAME_ID.to_string(),
                user_id: BLACK_ID.to_string(),
            },
        )
        .await?;

        writer.close().await?;
    }
    {
        println!("should fail: white already connected");
        let mut writer1 = connect_socket(url).await?;
        let mut writer2 = connect_socket(url).await?;

        send_msg(
            &mut writer1,
            ClientMessage::Auth {
                game_id: GAME_ID.to_string(),
                user_id: WHITE_ID.to_string(),
            },
        )
        .await?;
        send_msg(
            &mut writer2,
            ClientMessage::Auth {
                game_id: GAME_ID.to_string(),
                user_id: WHITE_ID.to_string(),
            },
        )
        .await?;

        writer1.close().await?;
        writer2.close().await?;
    }
    {
        println!("should fail: black already connected");
        let mut writer1 = connect_socket(url).await?;
        let mut writer2 = connect_socket(url).await?;

        send_msg(
            &mut writer1,
            ClientMessage::Auth {
                game_id: GAME_ID.to_string(),
                user_id: BLACK_ID.to_string(),
            },
        )
        .await?;
        send_msg(
            &mut writer2,
            ClientMessage::Auth {
                game_id: GAME_ID.to_string(),
                user_id: BLACK_ID.to_string(),
            },
        )
        .await?;

        writer1.close().await?;
        writer2.close().await?;
    }
    Ok(())
}

async fn test_moves(url: &str) -> anyhow::Result<()> {
    {
        let mut writer_black = connect_socket(url).await?;
        let mut writer_white = connect_socket(url).await?;

        send_msg(
            &mut writer_white,
            ClientMessage::Auth {
                game_id: GAME_ID.to_string(),
                user_id: WHITE_ID.to_string(),
            },
        )
        .await?;
        send_msg(
            &mut writer_black,
            ClientMessage::Auth {
                game_id: GAME_ID.to_string(),
                user_id: BLACK_ID.to_string(),
            },
        )
        .await?;

        println!("should fail: deserialization");
        writer_black
            .send(Message::Text(Utf8Bytes::from_static("abc")))
            .await?;
        println!("should fail: invalid turn");
        send_msg(&mut writer_black, ClientMessage::Move("e5".to_string())).await?;
        println!("should fail: invalid move");
        send_msg(&mut writer_white, ClientMessage::Move("abc".to_string())).await?;
        println!("should fail: invalid move");
        send_msg(&mut writer_white, ClientMessage::Move("e5".to_string())).await?;
        println!("should succeed");
        send_msg(&mut writer_white, ClientMessage::Move("d4".to_string())).await?;
        println!("should fail: invalid turn");
        send_msg(&mut writer_white, ClientMessage::Move("e4".to_string())).await?;

        writer_white.close().await?;
        writer_black.close().await?;
    }

    Ok(())
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let url = format!("ws://{HOST}/ws",);

    // initialize new game
    let init_body = InitBody {
        game_id: GAME_ID.to_string(),
        white_user_id: WHITE_ID.to_string(),
        black_user_id: BLACK_ID.to_string(),
    };

    let client = reqwest::Client::new();
    client
        .post(format!("http://{HOST}/init"))
        .json(&init_body)
        .send()
        .await?;

    test_auth(&url).await?;

    test_moves(&url).await?;

    Ok(())
}
</file>

<file path="ws_server/src/message.rs">
use serde::{Deserialize, Serialize};
use ts_rs::TS;

#[derive(Serialize, Deserialize, Debug, Clone, TS)]
#[ts(export)]
pub enum Error {
    Deserialization,
    Unauthorized,
    InvalidTurn,
    InvalidMove,
}

#[derive(Serialize, Deserialize, Debug, TS)]
#[serde(tag = "kind", content = "value")]
#[ts(export)]
pub enum ClientMessage {
    Auth { game_id: String, user_id: String },
    Move(String),
}

#[derive(Serialize, Deserialize, TS)]
#[serde(remote = "shakmaty::Color")]
#[ts(export)]
enum Color {
    Black = 0,
    White = 1,
}

// why shakmaty does not derive this???
#[derive(Serialize, Deserialize, TS)]
#[serde(remote = "shakmaty::Outcome")]
#[ts(export)]
enum Outcome {
    Decisive {
        #[serde(with = "Color")]
        #[ts(as = "Color")]
        winner: shakmaty::Color,
    },
    Draw,
}

#[derive(Serialize, Debug, Clone, TS)]
#[serde(tag = "kind", content = "value")]
#[ts(export)]
pub enum ServerMessage {
    Move(String),
    GameEnd(
        #[serde(with = "Outcome")]
        #[ts(as = "Outcome")]
        shakmaty::Outcome,
    ),
    Error(Error),
    AuthSuccess,
    MoveHistory(Vec<String>),
}

impl ServerMessage {
    pub fn is_game_end(&self) -> bool {
        match self {
            Self::GameEnd(_) => true,
            _ => false,
        }
    }
}
</file>

<file path="ws_server/src/route.rs">
pub mod games;
pub mod init;
pub mod ws;
</file>

<file path="README.md">
# ChessCloud
</file>

<file path="engine/hyper/Cargo.toml">
[package]
name = "stockfish-api"
version = "0.1.0"
edition = "2021"

[dependencies]
hyper = { version = "0.14", features = ["full"] }
tokio = { version = "1", features = ["full"] }
regex = "1.10"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
shakmaty = { version = "0.26", features = ["variant"] }
url = "2"
</file>

<file path="engine/hyper/Dockerfile">
FROM rust:alpine AS builder

WORKDIR /app
RUN apk add --no-cache musl-dev

COPY Cargo.toml .
COPY src src
RUN cargo build --release

FROM alpine:latest
WORKDIR /app
COPY --from=builder /app/target/release/stockfish-api .

EXPOSE 4000

CMD ["./stockfish-api"]
</file>

<file path="engine/stockfish/Dockerfile">
FROM alpine:edge AS builder

RUN apk update && apk add --no-cache git make g++ wget
RUN git clone https://github.com/official-stockfish/Stockfish.git
WORKDIR /Stockfish/src
RUN make -j$(nproc) profile-build ARCH=x86-64-bmi2

FROM alpine:edge
RUN apk update && apk add --no-cache libstdc++ libgcc socat
COPY --from=builder /Stockfish/src/stockfish /usr/local/bin/stockfish
WORKDIR /usr/local/bin
EXPOSE 4001

CMD ["socat", "TCP-LISTEN:4001,reuseaddr,fork,bind=0.0.0.0", "EXEC:/usr/local/bin/stockfish,pty,raw"]
</file>

<file path="matchmaking/.sqlx/query-ec85b4b4b0c3731794ac31c9233de52c839d8cc2cea517341b72acfa0edff1e8.json">
{
  "db_name": "PostgreSQL",
  "query": "INSERT INTO GameState (GameID, Black, White, PGN) VALUES ($1, $2, $3, '')",
  "describe": {
    "columns": [],
    "parameters": {
      "Left": [
        "Uuid",
        "Text",
        "Text"
      ]
    },
    "nullable": []
  },
  "hash": "ec85b4b4b0c3731794ac31c9233de52c839d8cc2cea517341b72acfa0edff1e8"
}
</file>

<file path="matchmaking/bindings/Color.ts">
// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.

export type Color = "White" | "Black";
</file>

<file path="matchmaking/bindings/MatchRequest.ts">
// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.

export type MatchRequest = { user_id: string, };
</file>

<file path="web/src/components/ui/button.tsx">
import * as React from 'react';
import { Slot } from '@radix-ui/react-slot';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          'bg-primary text-primary-foreground shadow-xs hover:bg-primary/90',
        destructive:
          'bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60',
        outline:
          'border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50',
        secondary:
          'bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80',
        ghost:
          'hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50',
        link: 'text-primary underline-offset-4 hover:underline',
      },
      size: {
        default: 'h-9 px-4 py-2 has-[>svg]:px-3',
        sm: 'h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5',
        lg: 'h-10 rounded-md px-6 has-[>svg]:px-4',
        icon: 'size-9',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<'button'> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean;
  }) {
  const Comp = asChild ? Slot : 'button';

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  );
}

export { Button, buttonVariants };
</file>

<file path="web/src/components/ui/sonner.tsx">
'use client';

import { useTheme } from 'next-themes';
import { Toaster as Sonner, ToasterProps } from 'sonner';

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = 'system' } = useTheme();

  return (
    <Sonner
      theme={theme as ToasterProps['theme']}
      className="toaster group"
      style={
        {
          '--normal-bg': 'var(--popover)',
          '--normal-text': 'var(--popover-foreground)',
          '--normal-border': 'var(--border)',
        } as React.CSSProperties
      }
      {...props}
    />
  );
};

export { Toaster };
</file>

<file path="web/src/components/ChessNotations.tsx">
'use client';

import { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';
import { Chess } from 'chess.js';

interface ChessNotationsProps {
  pgn: string;
}

interface MoveDisplay {
  number: number;
  white: {
    piece: 'pawn' | 'knight' | 'bishop' | 'rook' | 'queen' | 'king';
    move: string;
  } | null;
  black: {
    piece: 'pawn' | 'knight' | 'bishop' | 'rook' | 'queen' | 'king';
    move: string;
  } | null;
}

export default function ChessNotations({ pgn }: ChessNotationsProps) {
  const [moves, setMoves] = useState<MoveDisplay[]>([]);

  useEffect(() => {
    if (!pgn) return;

    try {
      const chess = new Chess();
      chess.loadPgn(pgn);
      const history = chess.history({ verbose: true });
      const formattedMoves: MoveDisplay[] = [];

      for (let i = 0; i < history.length; i += 2) {
        const moveNumber = Math.floor(i / 2) + 1;
        const whiteMove = history[i];
        const blackMove = i + 1 < history.length ? history[i + 1] : null;

        const getPieceType = (
          piece: string
        ): 'pawn' | 'knight' | 'bishop' | 'rook' | 'queen' | 'king' => {
          switch (piece.toLowerCase()) {
            case 'p':
              return 'pawn';
            case 'n':
              return 'knight';
            case 'b':
              return 'bishop';
            case 'r':
              return 'rook';
            case 'q':
              return 'queen';
            case 'k':
              return 'king';
            default:
              return 'pawn';
          }
        };

        formattedMoves.push({
          number: moveNumber,
          white: whiteMove
            ? {
                piece: getPieceType(whiteMove.piece),
                move: whiteMove.san,
              }
            : null,
          black: blackMove
            ? {
                piece: getPieceType(blackMove.piece),
                move: blackMove.san,
              }
            : null,
        });
      }

      setMoves(formattedMoves);
    } catch (error) {
      console.error('Error parsing PGN:', error);
    }
  }, [pgn]);

  const handleRestart = () => {
    window.location.reload();
  };

  return (
    <Card className="p-4 h-full flex flex-col bg-amber-50 border-amber-200 dark:bg-slate-800 dark:border-amber-800/30 overflow-hidden shadow-md">
      <div className="flex justify-between items-center mb-2">
        <h3 className="font-medium text-amber-900 dark:text-amber-100">
          Game Notation
        </h3>
      </div>

      <div className="overflow-y-auto flex-grow mb-2 font-mono text-sm">
        <table className="w-full table-fixed">
          <thead className="text-left text-amber-700 dark:text-amber-300 border-b border-amber-200/50 dark:border-amber-700/30">
            <tr>
              <th className="w-10">#</th>
              <th className="w-1/2">White</th>
              <th className="w-1/2">Black</th>
            </tr>
          </thead>
          <tbody>
            {moves.map((move) => (
              <tr
                key={move.number}
                className="hover:bg-amber-50 hover:text-amber-900 dark:hover:bg-amber-900/20"
              >
                <td className="py-1 text-amber-600 dark:text-amber-400">
                  {move.number}.
                </td>
                <td className="py-1">
                  {move.white && (
                    <div className="flex items-center">
                      <span className="font-semibold text-amber-800 dark:text-amber-200">
                        {move.white.move}
                      </span>
                    </div>
                  )}
                </td>
                <td className="py-1">
                  {move.black && (
                    <div className="flex items-center">
                      <span className="font-semibold text-amber-800 dark:text-amber-200">
                        {move.black.move}
                      </span>
                    </div>
                  )}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      <div className="pt-2 border-t border-amber-200/50 dark:border-amber-700/30">
        <Button
          variant="outline"
          className="w-full border-amber-300 text-amber-800 hover:bg-amber-100/70 
          dark:border-amber-700 dark:text-amber-200 dark:hover:bg-amber-800/30
          shadow-[0_3px_0_0_#fcd34d] hover:shadow-[0_1px_0_0_#fcd34d] hover:translate-y-[2px]
          dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#92400e]"
          onClick={handleRestart}
        >
          Restart Game
        </Button>
      </div>
    </Card>
  );
}
</file>

<file path="web/src/components/DisplayChessBoard.tsx">
'use client';

import Chessground from 'react-chessground';
import 'react-chessground/dist/styles/chessground.css';
import { Chess, type Move } from 'chess.js';
import type { Square } from 'chess.js';
import { useState, useEffect, useRef } from 'react';

export interface CustomChessBoardProps {
  className?: string;
  initialFen?: string;
  pgn?: string;
}

export function calcMovable(chess: Chess) {
  const dests = new Map<Square, Square[]>();
  for (const row of chess.board()) {
    for (const piece of row) {
      if (piece && piece.square) {
        const moves = chess.moves({ square: piece.square, verbose: true }) as {
          to: Square;
        }[];
        if (moves.length)
          dests.set(
            piece.square as Square,
            moves.map((m) => m.to)
          );
      }
    }
  }
  return dests;
}

export default function CustomChessBoard({
  className = '',
  initialFen,
  pgn,
}: CustomChessBoardProps) {
  const [chess] = useState(() => new Chess());
  const [fen, setFen] = useState<string>('');
  const [lastMove, setLastMove] = useState<[Square, Square] | undefined>();
  const moveIndex = useRef(0);
  const moves = useRef<Move[]>([]);

  useEffect(() => {
    chess.reset();

    if (initialFen) {
      try {
        chess.load(initialFen);
      } catch (e) {
        console.error('Invalid FEN:', e);
      }
    }

    if (pgn) {
      try {
        chess.loadPgn(pgn);
        moves.current = chess.history({ verbose: true });
        chess.reset();
        if (initialFen) {
          chess.load(initialFen);
        }
      } catch (e) {
        console.error('Invalid PGN:', e);
      }
    }

    setFen(chess.fen());

    if (pgn && moves.current.length > 0) {
      moveIndex.current = 0;
      const intervalId = setInterval(() => {
        if (moveIndex.current < moves.current.length) {
          const move = moves.current[moveIndex.current];
          chess.move({
            from: move.from,
            to: move.to,
            promotion: move.promotion,
          });
          setLastMove([move.from as Square, move.to as Square]);
          setFen(chess.fen());
          moveIndex.current++;
        } else {
          clearInterval(intervalId);
        }
      }, 1200);

      return () => clearInterval(intervalId);
    }
  }, [chess, initialFen, pgn]);

  const onMove = (from: Square, to: Square) => {
    try {
      const move = chess.move({ from, to });
      if (move) {
        setLastMove([from, to]);
        setFen(chess.fen());
      }
    } catch (error) {
      console.error('Invalid move:', error);
    }
  };

  if (!fen)
    return (
      <div
        className={`${className} w-full aspect-square bg-amber-100 dark:bg-slate-700`}
      ></div>
    );

  return (
    <div
      className={`chess-board-container ${className} dark:ring-1 dark:ring-amber-700/30`}
    >
      <div className="relative w-full aspect-square pointer-events-none">
        <Chessground
          width="100%"
          height="100%"
          fen={fen}
          onMove={onMove}
          lastMove={lastMove}
          turnColor={chess.turn() === 'w' ? 'white' : 'black'}
          movable={{
            free: false,
            color: 'both',
            dests: calcMovable(chess),
          }}
          animation={{ enabled: true, duration: 300 }}
          coordinates={true}
          highlight={{
            lastMove: true,
            check: true,
          }}
          className="dark:bg-slate-800"
        />
      </div>
    </div>
  );
}

export function LatestChessBoard({
  className = '',
  initialFen,
  pgn,
  color = 'w',
}: CustomChessBoardProps & { color?: 'w' | 'b' }) {
  const [chess] = useState(() => new Chess());
  const [fen, setFen] = useState<string>('');
  const [lastMove, setLastMove] = useState<[Square, Square] | undefined>();

  useEffect(() => {
    chess.reset();

    if (initialFen) {
      try {
        chess.load(initialFen);
      } catch (e) {
        console.error('Invalid FEN:', e);
      }
    }

    if (pgn && pgn.trim() !== '') {
      try {
        chess.loadPgn(pgn);
        const history = chess.history({ verbose: true });
        if (history.length > 0) {
          const lastMoveData = history[history.length - 1];
          setLastMove([lastMoveData.from as Square, lastMoveData.to as Square]);
        }
      } catch (e) {
        console.error('Invalid PGN:', e);
      }
    }

    setFen(chess.fen());
  }, [chess, initialFen, pgn]);

  const onMove = (from: Square, to: Square) => {
    try {
      const move = chess.move({ from, to });
      if (move) {
        setLastMove([from, to]);
        setFen(chess.fen());
      }
    } catch (error) {
      console.error('Invalid move:', error);
    }
  };

  if (!fen)
    return (
      <div
        className={`${className} w-full aspect-square bg-amber-100 dark:bg-slate-700`}
      ></div>
    );

  return (
    <div
      className={`chess-board-container ${className} dark:ring-1 dark:ring-amber-700/30`}
    >
      <div className="relative w-full aspect-square pointer-events-none">
        <Chessground
          width="100%"
          height="100%"
          fen={fen}
          onMove={onMove}
          lastMove={lastMove}
          turnColor={chess.turn() === 'w' ? 'white' : 'black'}
          orientation={color === 'w' ? 'white' : 'black'}
          movable={{
            free: false,
            color: 'both',
            dests: calcMovable(chess),
          }}
          animation={{ enabled: false }}
          coordinates={true}
          highlight={{
            lastMove: true,
            check: true,
          }}
          className="dark:bg-slate-800"
        />
      </div>
    </div>
  );
}
</file>

<file path="web/src/components/RouteProtection.tsx">
'use client';

import { useEffect, useState } from 'react';
import { useRouter, usePathname } from 'next/navigation';
import { isAuthenticated } from '@/lib/auth/googleAuth';
import LoadingScreen from '@/components/LoadingScreen';

const PUBLIC_ROUTES = ['/home', '/signin', '/signup', '/'];

const AUTH_ROUTES = ['/signin', '/signup'];

interface RouteProtectionProps {
  children: React.ReactNode;
}

export default function RouteProtection({ children }: RouteProtectionProps) {
  const [loading, setLoading] = useState(true);
  const router = useRouter();
  const pathname = usePathname();

  useEffect(() => {
    const checkAuth = () => {
      const authenticated = isAuthenticated();

      if (authenticated && AUTH_ROUTES.includes(pathname)) {
        router.replace('/home');
        return;
      }

      if (!authenticated && !PUBLIC_ROUTES.includes(pathname)) {
        router.replace('/signin');
        return;
      }

      setLoading(false);
    };

    checkAuth();
  }, [pathname, router]);

  if (loading) {
    return <LoadingScreen />;
  }

  return <>{children}</>;
}
</file>

<file path="web/src/lib/ClientLayout.tsx">
'use client';

import { usePathname } from 'next/navigation';
import { useState, useEffect } from 'react';
import Navbar from '@/components/NavBar';
import Footer from '@/components/Footer';
import LoadingScreen from '@/components/LoadingScreen';
import { useRouter } from 'next/navigation';
import { isAuthenticated } from '@/lib/auth/googleAuth';

const PUBLIC_ROUTES = ['/home', '/signin', '/signup', '/'];

const AUTH_ROUTES = ['/signin', '/signup'];

export default function ClientLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const pathname = usePathname();
  const router = useRouter();
  const [, setMounted] = useState(false);
  const [showLoading, setShowLoading] = useState(true);
  const [isRoutingChecked, setIsRoutingChecked] = useState(false);

  const isAuthPage =
    pathname === '/signin' ||
    pathname === '/signup' ||
    pathname === '/signout' ||
    pathname === '/debug';

  useEffect(() => {
    const checkRouteAccess = () => {
      const authenticated = isAuthenticated();

      if (authenticated && AUTH_ROUTES.includes(pathname)) {
        router.replace('/home');
        return false;
      }

      if (!authenticated && !PUBLIC_ROUTES.includes(pathname)) {
        router.replace('/signin');
        return false;
      }

      return true;
    };

    const timer = setTimeout(() => {
      setMounted(true);

      const routeAccessible = checkRouteAccess();
      if (routeAccessible) {
        setShowLoading(false);
      }

      setIsRoutingChecked(true);
    }, 500);

    return () => clearTimeout(timer);
  }, [pathname, router]);

  if (showLoading || !isRoutingChecked) {
    return <LoadingScreen />;
  }

  return (
    <div className="flex flex-col">
      {!isAuthPage && <Navbar />}
      <main
        className={`flex-1 min-h-screen ${!isAuthPage ? 'pt-16' : ''} relative`}
      >
        {children}
      </main>
      {!isAuthPage && <Footer />}
    </div>
  );
}
</file>

<file path="web/src/lib/LoadingContext.tsx">
// src/lib/LoadingContext.tsx
'use client';

import React, { createContext, useContext, useState, ReactNode } from 'react';
import LoadingScreen from '@/components/LoadingScreen';

type LoadingContextType = {
  setLoading: (isLoading: boolean) => void;
};

const LoadingContext = createContext<LoadingContextType | undefined>(undefined);

export function LoadingProvider({ children }: { children: ReactNode }) {
  const [isLoading, setIsLoading] = useState(false);

  return (
    <LoadingContext.Provider value={{ setLoading: setIsLoading }}>
      {isLoading && <LoadingScreen />}
      <div className={isLoading ? 'opacity-0' : 'opacity-100'}>{children}</div>
    </LoadingContext.Provider>
  );
}

export function useLoading() {
  const context = useContext(LoadingContext);
  if (!context) {
    throw new Error('useLoading must be used within a LoadingProvider');
  }
  return context;
}
</file>

<file path="web/src/lib/time.ts">
export function getLastTime(createdat: Date | null): string {
  if (!createdat) return 'recently';

  const now = new Date();
  const moveTime = new Date(createdat);
  const diffMs = now.getTime() - moveTime.getTime();

  const diffMins = Math.round(diffMs / 60000);

  if (diffMins < 1) return 'just now';
  if (diffMins < 60) return `${diffMins}m ago`;

  const diffHours = Math.floor(diffMins / 60);
  if (diffHours < 24) return `${diffHours}h ago`;

  const diffDays = Math.floor(diffHours / 24);
  return `${diffDays}d ago`;
}
</file>

<file path="web/src/types/engineTypes.ts">
export interface EngineMessageResponse {
  message: string;
}

export interface EngineTestResponse {
  status: string;
  message: string;
  response: string;
}

export interface BestMoveResponse {
  best_move: string;
  new_fen: string;
}

export type EngineType =
  | EngineMessageResponse
  | EngineTestResponse
  | BestMoveResponse;
</file>

<file path="web/README.md">
# 这是一个使用 [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app) 引导的 [Next.js](https://nextjs.org) 项目。

## 开始使用

首先，运行开发服务器：

```bash
pnpm dev
# 或
bun dev
```

使用浏览器打开 [http://localhost:3000](http://localhost:3000) 查看结果。

你可以通过修改 `app/page.tsx` 来开始编辑页面。当你编辑文件时，页面会自动更新。

此项目使用 [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) 自动优化并加载 [Geist](https://vercel.com/font)，这是 Vercel 的一个新字体系列。

## 了解更多

要了解有关 Next.js 的更多信息，请查看以下资源：

- [Next.js 文档](https://nextjs.org/docs) - 了解 Next.js 的功能和 API。
- [学习 Next.js](https://nextjs.org/learn) - 一个交互式 Next.js 教程。

你可以查看 [Next.js GitHub 仓库](https://github.com/vercel/next.js) - 欢迎你的反馈和贡献！

## 部署在 Vercel 上

部署 Next.js 应用的最简单方法是使用来自 Next.js 创建者的 [Vercel 平台](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme)。

查看我们的 [Next.js 部署文档](https://nextjs.org/docs/app/building-your-application/deploying) 了解更多详情。
</file>

<file path="ws_server/.sqlx/query-1f362cae8748b36d7ff12321241464c77cbbef1f4b166060686ddd18b29d2507.json">
{
  "db_name": "PostgreSQL",
  "query": "SELECT GameID, Black, White FROM GameState WHERE GameId = $1 AND Status = 'On Going'",
  "describe": {
    "columns": [
      {
        "ordinal": 0,
        "name": "gameid",
        "type_info": "Uuid"
      },
      {
        "ordinal": 1,
        "name": "black",
        "type_info": "Text"
      },
      {
        "ordinal": 2,
        "name": "white",
        "type_info": "Text"
      }
    ],
    "parameters": {
      "Left": [
        "Uuid"
      ]
    },
    "nullable": [
      false,
      false,
      false
    ]
  },
  "hash": "1f362cae8748b36d7ff12321241464c77cbbef1f4b166060686ddd18b29d2507"
}
</file>

<file path="ws_server/.sqlx/query-abee11b95d025cec50eeb7d12fbbad1379043ae1529773a971d59e5ee9afa658.json">
{
  "db_name": "PostgreSQL",
  "query": "UPDATE GameState SET Status = 'Abort' WHERE GameID = $1",
  "describe": {
    "columns": [],
    "parameters": {
      "Left": [
        "Uuid"
      ]
    },
    "nullable": []
  },
  "hash": "abee11b95d025cec50eeb7d12fbbad1379043ae1529773a971d59e5ee9afa658"
}
</file>

<file path="ws_server/src/route/games.rs">
use axum::extract::State;

use crate::state::AppState;

// for debugging, might remove this later
pub async fn get_games(State(state): State<AppState>) -> String {
    tracing::info!("/GET games");
    let mut s = String::new();
    state.active_games.scan(|k, v| {
        s = format!(
            "{s}\n{{Game: {k}, Black: {}, White: {}}}",
            v.black_user_id, v.white_user_id
        );
    });
    s
}
</file>

<file path="ws_server/src/route/init.rs">
use axum::{extract::State, http::StatusCode, Json};
use serde::{Deserialize, Serialize};
use ts_rs::TS;

use crate::state::{ActiveGame, AppState};

#[derive(Deserialize, Serialize, Debug, TS)]
#[ts(export)]
pub struct InitBody {
    pub game_id: String,
    pub white_user_id: String,
    pub black_user_id: String,
}

pub async fn post_init(
    State(state): State<AppState>,
    Json(body): Json<InitBody>,
) -> (StatusCode, &'static str) {
    tracing::info!("/POST init");
    if state
        .active_games
        .insert(
            body.game_id,
            ActiveGame::new(body.white_user_id, body.black_user_id),
        )
        .is_err()
    {
        tracing::error!("Game already exists");
        return (StatusCode::INTERNAL_SERVER_ERROR, "Game already exists");
    }
    (StatusCode::OK, "OK")
}
</file>

<file path="ws_server/.dockerignore">
target/
</file>

<file path="ws_server/.gitignore">
# Generated by Cargo
# will have compiled files and executables
debug/
target/

# These are backup files generated by rustfmt
**/*.rs.bk

# MSVC Windows builds of rustc generate these, which store debugging information
*.pdb

# RustRover
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

.env
</file>

<file path="ws_server/Dockerfile">
FROM rust:bookworm AS builder

WORKDIR /usr/src/app
COPY . .

RUN apt-get update
RUN apt-get install -y libssl-dev
RUN cargo build --release

FROM debian:bookworm

RUN apt-get update
RUN apt-get install -y openssl

WORKDIR /app

COPY --from=builder /usr/src/app/target/release/ws_server /app/

EXPOSE 8000

CMD ["./ws_server"]
</file>

<file path=".github/workflows/upload-image.yml">
name: Upload image to Amazon

on:
  workflow_run:
    workflows: ["Code check and build"]
    types: [completed]
    branches: ["main"]

jobs:

  build:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: web
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
          aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
          aws configure set default.region ap-southeast-1

      - name: Login to Amazon ECR
        run: |
          aws ecr get-login-password --region ap-southeast-1 | docker login --username AWS --password-stdin 058264495198.dkr.ecr.ap-southeast-1.amazonaws.com

      - name: Build Docker image
        run: docker build -t chesscloud:latest .

      - name: Tag Docker image
        run: docker tag chesscloud:latest 058264495198.dkr.ecr.ap-southeast-1.amazonaws.com/chesscloud:latest

      - name: Push Docker image to ECR
        run: docker push 058264495198.dkr.ecr.ap-southeast-1.amazonaws.com/chesscloud:latest
</file>

<file path="engine/hyper/src/main.rs">
use hyper::{Body, Request, Response, Server, Method, StatusCode, header::HeaderValue};
use hyper::service::{make_service_fn, service_fn};
use regex::Regex;
use serde::Serialize;
use shakmaty::{fen::Fen, Chess, FromSetup, Position};
use std::{
    convert::Infallible,
    io::{Read, Write},
    net::TcpStream,
    time::{Duration, Instant},
};
use url::form_urlencoded;

#[derive(Serialize)]
struct MessageResponse {
    message: String,
}

#[derive(Serialize)]
struct TestResponse {
    status: String,
    message: String,
    response: String,
}

#[derive(Serialize)]
struct BestMoveResponse {
    best_move: String,
    new_fen: String,
}

#[derive(Serialize)]
struct ErrorResponse {
    status: String,
    message: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    best_move: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    raw_response: Option<String>,
}

#[tokio::main]
async fn main() {
    let make_svc = make_service_fn(|_conn| async { Ok::<_, Infallible>(service_fn(handle_request)) });
    let addr = ([0, 0, 0, 0], 4000).into();
    let server = Server::bind(&addr).serve(make_svc);
    if let Err(e) = server.await {
        eprintln!("Server error: {}", e);
    }
}

async fn handle_request(req: Request<Body>) -> Result<Response<Body>, Infallible> {
    if req.method() == Method::OPTIONS {
        return Ok(cors_preflight());
    }
    let response = match (req.method(), req.uri().path()) {
        (&Method::GET, "/") => {
            let body = serde_json::to_string(&MessageResponse { message: "Stockfish API is running".into() }).unwrap();
            json_response(StatusCode::OK, body)
        }
        (&Method::GET, "/test") => {
            match connect_to_stockfish() {
                Ok(mut sock) => {
                    if let Err(e) = send_command(&mut sock, "uci") {
                        return Ok(add_cors_headers(internal_error(&e.to_string())));
                    }
                    match receive_until(&mut sock, "uciok", Duration::from_secs(30)) {
                        Ok(resp) => {
                            let body = serde_json::to_string(&TestResponse {
                                status: "success".into(),
                                message: "Connected to Stockfish successfully".into(),
                                response: resp,
                            }).unwrap();
                            json_response(StatusCode::OK, body)
                        }
                        Err(e) => add_cors_headers(internal_error(&e)),
                    }
                }
                Err(e) => add_cors_headers(internal_error(&format!("Failed to connect to Stockfish: {}", e))),
            }
        }
        (&Method::GET, "/bestmove") => {
            let query = req.uri().query().unwrap_or("");
            let fen = form_urlencoded::parse(query.as_bytes())
                .find(|(k, _)| k == "fen")
                .map(|(_, v)| v.to_string())
                .unwrap_or_default();
            if fen.is_empty() {
                return Ok(add_cors_headers(bad_request("Missing 'fen' parameter")));
            }
            match get_best_move_logic(&fen) {
                Ok(resp) => {
                    let body = serde_json::to_string(&resp).unwrap();
                    json_response(StatusCode::OK, body)
                }
                Err(err_resp) => {
                    let body = serde_json::to_string(&err_resp).unwrap();
                    json_response(StatusCode::OK, body)
                }
            }
        }
        _ => Response::builder()
            .status(StatusCode::NOT_FOUND)
            .body(Body::from("Not Found"))
            .unwrap(),
    };
    Ok(add_cors_headers(response))
}

fn cors_preflight() -> Response<Body> {
    Response::builder()
        .status(StatusCode::NO_CONTENT)
        .header("Access-Control-Allow-Origin", "*")
        .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
        .header("Access-Control-Allow-Headers", "content-type")
        .body(Body::empty())
        .unwrap()
}

fn add_cors_headers(mut res: Response<Body>) -> Response<Body> {
    res.headers_mut().insert("Access-Control-Allow-Origin", HeaderValue::from_static("*"));
    res.headers_mut().insert("Access-Control-Allow-Methods", HeaderValue::from_static("GET, POST, OPTIONS"));
    res.headers_mut().insert("Access-Control-Allow-Headers", HeaderValue::from_static("content-type"));
    res
}

fn json_response(status: StatusCode, body: String) -> Response<Body> {
    Response::builder()
        .status(status)
        .header("Content-Type", "application/json")
        .body(Body::from(body))
        .unwrap()
}

fn internal_error(msg: &str) -> Response<Body> {
    Response::builder()
        .status(StatusCode::INTERNAL_SERVER_ERROR)
        .body(Body::from(msg.to_string()))
        .unwrap()
}

fn bad_request(msg: &str) -> Response<Body> {
    Response::builder()
        .status(StatusCode::BAD_REQUEST)
        .body(Body::from(msg.to_string()))
        .unwrap()
}

fn get_best_move_logic(fen: &str) -> Result<BestMoveResponse, ErrorResponse> {
    let mut sock = connect_to_stockfish().map_err(|e| ErrorResponse { status: "error".into(), message: e.to_string(), best_move: None, raw_response: None })?;
    send_command(&mut sock, "uci").map_err(|e| err_resp(&e.to_string()))?;
    receive_until(&mut sock, "uciok", Duration::from_secs(30)).map_err(|e| err_resp(&e))?;
    send_command(&mut sock, "isready").map_err(|e| err_resp(&e.to_string()))?;
    receive_until(&mut sock, "readyok", Duration::from_secs(30)).map_err(|e| err_resp(&e))?;
    send_command(&mut sock, &format!("position fen {}", fen)).map_err(|e| err_resp(&e.to_string()))?;
    send_command(&mut sock, "go depth 25").map_err(|e| err_resp(&e.to_string()))?;
    let response = receive_until(&mut sock, "bestmove", Duration::from_secs(30)).map_err(|e| err_resp(&e))?;
    let re = Regex::new(r"bestmove\s+(\w+)").unwrap();
    if let Some(caps) = re.captures(&response) {
        let best_move = caps.get(1).unwrap().as_str();
        let fen_parsed = Fen::from_ascii(fen.as_bytes()).map_err(|e| err_resp(&format!("Invalid FEN: {}", e)))?;
        let mut pos = Chess::from_setup(fen_parsed.into_setup(), shakmaty::CastlingMode::Standard).map_err(|e| err_resp(&format!("Invalid position: {}", e)))?;
        let src = &best_move[0..2];
        let dst = &best_move[2..4];
        if let (Ok(src_sq), Ok(dst_sq)) = (src.parse(), dst.parse()) {
            if let Some(mv) = pos.legal_moves().into_iter().find(|m| m.from() == Some(src_sq) && m.to() == dst_sq) {
                pos.play_unchecked(&mv);
                let new_fen = Fen::from_setup(pos.into_setup(shakmaty::EnPassantMode::Legal)).to_string();
                return Ok(BestMoveResponse { best_move: best_move.to_string(), new_fen });
            } else {
                return Err(ErrorResponse { status: "error".into(), message: "Best move is not legal".into(), best_move: Some(best_move.into()), raw_response: None });
            }
        } else {
            return Err(err_resp("Could not parse move coordinates"));
        }
    }
    Err(ErrorResponse { status: "error".into(), message: "Could not find best move in response".into(), best_move: None, raw_response: Some(response) })
}

fn err_resp(msg: &str) -> ErrorResponse {
    ErrorResponse { status: "error".into(), message: msg.to_string(), best_move: None, raw_response: None }
}

fn connect_to_stockfish() -> Result<TcpStream, std::io::Error> {
    let stream = TcpStream::connect("stockfish:4001")?;
    stream.set_read_timeout(Some(Duration::from_secs(10)))?;
    stream.set_write_timeout(Some(Duration::from_secs(10)))?;
    Ok(stream)
}

fn send_command(stream: &mut TcpStream, command: &str) -> Result<(), std::io::Error> {
    stream.write_all(format!("{}\n", command).as_bytes())?;
    Ok(())
}

fn receive_until(stream: &mut TcpStream, marker: &str, timeout: Duration) -> Result<String, String> {
    let start = Instant::now();
    let mut buffer = String::new();
    while start.elapsed() < timeout {
        let mut chunk = [0; 4096];
        match stream.read(&mut chunk) {
            Ok(n) if n > 0 => {
                buffer.push_str(&String::from_utf8_lossy(&chunk[..n]));
                if buffer.contains(marker) {
                    return Ok(buffer);
                }
            }
            Ok(_) => std::thread::sleep(Duration::from_millis(100)),
            Err(ref e) if e.kind() == std::io::ErrorKind::WouldBlock || e.kind() == std::io::ErrorKind::TimedOut => std::thread::sleep(Duration::from_millis(100)),
            Err(e) => return Err(format!("Failed to read from socket: {}", e)),
        }
    }
    Err(format!("Timeout waiting for '{}'", marker))
}
</file>

<file path="matchmaking/bindings/MatchResponse.ts">
// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.
import type { Color } from "./Color";

export type MatchResponse = { "result": "Ok", "value": { game_id: string, color: Color, } } | { "result": "Err", "value": string };
</file>

<file path="matchmaking/.gitignore">
# Generated by Cargo
# will have compiled files and executables
debug/
target/

# These are backup files generated by rustfmt
**/*.rs.bk

# MSVC Windows builds of rustc generate these, which store debugging information
*.pdb

# RustRover
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

.env
</file>

<file path="web/src/components/ui/input.tsx">
import * as React from 'react';

import { cn } from '@/lib/utils';

function Input({ className, type, ...props }: React.ComponentProps<'input'>) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        'file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm',
        'aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive',
        className
      )}
      {...props}
    />
  );
}

export { Input };
</file>

<file path="web/src/components/Error.tsx">
'use client';

import { useState, useEffect } from 'react';
import Link from 'next/link';
import { useRouter } from 'next/navigation';
import { Button } from '@/components/ui/button';
import {
  HomeIcon,
  ArrowPathIcon,
  ChevronRightIcon,
} from '@heroicons/react/24/outline';
import CustomChessBoard from '@/components/DisplayChessBoard';

interface ErrorPageProps {
  message?: string;
  code?: string | number;
}

export default function ErrorPage({
  message = 'Something went wrong',
  code = '500',
}: ErrorPageProps) {
  const router = useRouter();
  const [chessAnimation, setChessAnimation] = useState(0);
  const animations = [
    '1. e4 e5 2. Nf3 Nc6 3. d4 exd4 4. Bc4',
    '1. d4 d5 2. c4 e6 3. Nc3 Nf6 4. Bg5',
    '1. e4 c5 2. Nf3 d6 3. d4 cxd4 4. Nxd4 Nf6 5. Nc3',
  ];

  useEffect(() => {
    const interval = setInterval(() => {
      setChessAnimation((prev) => (prev + 1) % animations.length);
    }, 8000);
    return () => clearInterval(interval);
  }, [animations.length]);

  return (
    <div className="min-h-screen flex items-center justify-center p-4 relative overflow-hidden bg-gradient-to-br from-amber-50 via-amber-100/70 to-amber-200/50 dark:from-slate-800 dark:via-amber-900/20 dark:to-slate-900/90">
      <div
        className="absolute inset-0"
        style={{
          backgroundImage: 'url(/noise.png)',
          backgroundRepeat: 'repeat',
          opacity: 0.025,
        }}
      />
      <div
        className="
          absolute inset-0 pointer-events-none
          [background-image:linear-gradient(90deg,rgba(241,194,125,0.15)_1px,transparent_1px),linear-gradient(180deg,rgba(241,194,125,0.15)_1px,transparent_1px)]
          dark:[background-image:linear-gradient(90deg,rgba(251,191,36,0.2)_1px,transparent_1px),linear-gradient(180deg,rgba(251,191,36,0.2)_1px,transparent_1px)]
          [background-size:20px_20px]
        "
      />

      <div className="absolute top-1/3 left-1/3 w-96 h-96 bg-amber-200/20 dark:bg-amber-500/20 rounded-full blur-3xl"></div>
      <div className="absolute bottom-1/3 right-1/3 w-64 h-64 bg-amber-300/20 dark:bg-amber-600/15 rounded-full blur-3xl"></div>

      <div className="w-full max-w-5xl z-10">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8 items-center">
          <div className="order-2 md:order-1 p-6">
            <div className="mb-2 text-lg text-amber-600 dark:text-amber-400 font-medium">
              Error {code}
            </div>
            <h1 className="text-4xl md:text-5xl font-bold text-amber-900 dark:text-amber-100 font-display mb-6">
              Check Mate
            </h1>
            <p className="text-amber-800 dark:text-amber-200 mb-8">{message}</p>

            <div className="flex flex-col sm:flex-row gap-4">
              <Button
                onClick={() => router.push('/home')}
                className="bg-amber-600 hover:bg-amber-700 text-white px-6 rounded-md 
                shadow-[0_4px_0_0_#b45309] hover:shadow-[0_2px_0_0_#92400e] hover:translate-y-[2px]
                dark:bg-amber-500 dark:hover:bg-amber-600
                dark:shadow-[0_4px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f]"
              >
                <HomeIcon className="mr-2 h-5 w-5" />
                Return Home
              </Button>

              <Button
                variant="outline"
                onClick={() => router.back()}
                className="border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900
                shadow-[0_4px_0_0_#fcd34d] hover:shadow-[0_2px_0_0_#fcd34d] hover:translate-y-[2px]
                dark:bg-slate-800 dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-900
                dark:shadow-[0_4px_0_0_#475569] dark:hover:shadow-[0_1px_0_0_#475569]"
              >
                <ArrowPathIcon className="mr-2 h-5 w-5" />
                Try Again
              </Button>
            </div>

            <div className="mt-12">
              <div className="text-sm text-amber-700 dark:text-amber-300">
                Looking for something else?
              </div>
              <div className="mt-2 flex gap-6">
                <Link
                  href="/game"
                  className="text-amber-600 hover:text-amber-700 dark:text-amber-400 dark:hover:text-amber-300 flex items-center text-sm"
                >
                  Play Game
                  <ChevronRightIcon className="ml-1 h-4 w-4" />
                </Link>
                <Link
                  href="/dashboard"
                  className="text-amber-600 hover:text-amber-700 dark:text-amber-400 dark:hover:text-amber-300 flex items-center text-sm"
                >
                  Dashboard
                  <ChevronRightIcon className="ml-1 h-4 w-4" />
                </Link>
              </div>
            </div>
          </div>

          <div className="order-1 md:order-2 p-6 flex justify-center">
            <div className="w-full max-w-sm relative">
              <div className="absolute z-1 -top-8 -left-8 md:-top-14 md:-left-14 w-20 h-20 md:w-32 md:h-32 rounded-full bg-white dark:bg-slate-800 shadow-md flex items-center justify-center">
                <div className="text-6xl md:text-8xl font-bold text-amber-300 dark:text-amber-600 font-display">
                  !
                </div>
              </div>
              <div className="chess-board-container">
                <CustomChessBoard
                  className="shadow-2xl dark:shadow-black/30"
                  pgn={animations[chessAnimation]}
                />
              </div>
              <div className="absolute -bottom-8 -right-8 md:-bottom-12 md:-right-12 w-20 h-20 md:w-32 md:h-32 rounded-full bg-white dark:bg-slate-800 shadow-md flex items-center justify-center">
                <div className="text-6xl md:text-8xl font-bold text-amber-300 dark:text-amber-600 font-display">
                  {code}
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="web/src/components/ThemeSwitch.tsx">
'use client';

import { useState, useEffect } from 'react';
import { MoonIcon, SunIcon } from '@heroicons/react/24/outline';
import { Button } from './ui/button';

interface ThemeSwitchProps {
  className?: string;
}

export default function ThemeSwitch({ className = '' }: ThemeSwitchProps) {
  const [theme, setTheme] = useState<'light' | 'dark'>('light');
  const [mounted, setMounted] = useState(false);
  const [pressedKey, setPressedKey] = useState<boolean>(false);

  useEffect(() => {
    setMounted(true);
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(isDark ? 'dark' : 'light');
  }, []);

  const toggleTheme = () => {
    setPressedKey(true);
    setTimeout(() => {
      const newTheme = theme === 'light' ? 'dark' : 'light';
      setTheme(newTheme);
      document.documentElement.classList.toggle('dark', newTheme === 'dark');
      localStorage.setItem('theme', newTheme);
      setPressedKey(false);
    }, 150);
  };

  if (!mounted) {
    return null;
  }

  return (
    <Button
      variant="outline"
      className={`h-9 w-9 p-0 flex items-center justify-center border-amber-300 text-amber-800 
      hover:bg-amber-50 hover:text-amber-900 rounded-md transition-all 
      shadow-[0_3px_0_0_#fcd34d] hover:shadow-[0_1px_0_0_#fcd34d] hover:translate-y-[2px]
      dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50
      dark:shadow-[0_3px_0_0_#475569] dark:hover:shadow-[0_1px_0_0_#475569]
      ${
        pressedKey
          ? 'transform translate-y-[3px] shadow-none bg-amber-100 dark:bg-slate-800'
          : ''
      } ${className}`}
      onClick={toggleTheme}
      aria-label="Toggle theme"
    >
      {theme === 'light' ? (
        <MoonIcon className="h-5 w-5" />
      ) : (
        <SunIcon className="h-5 w-5" />
      )}
    </Button>
  );
}
</file>

<file path="web/src/components/Unauthorized.tsx">
'use client';

import { useState, useEffect } from 'react';
import Link from 'next/link';
import { useRouter } from 'next/navigation';
import { Button } from '@/components/ui/button';
import {
  HomeIcon,
  LockClosedIcon,
  ShieldCheckIcon,
  ChevronRightIcon,
} from '@heroicons/react/24/outline';
import CustomChessBoard from '@/components/DisplayChessBoard';

export default function UnauthorizedPage() {
  const router = useRouter();
  const [chessAnimation, setChessAnimation] = useState(0);
  const animations = [
    '1. e4 e5 2. Nf3 Nc6 3. Bb5 a6 4. Ba4 Nf6',
    '1. d4 Nf6 2. c4 e6 3. Nc3 Bb4 4. e3 O-O',
    '1. e4 c5 2. Nf3 d6 3. d4 cxd4 4. Nxd4 Nf6 5. Nc3 a6',
  ];

  useEffect(() => {
    const interval = setInterval(() => {
      setChessAnimation((prev) => (prev + 1) % animations.length);
    }, 8000);
    return () => clearInterval(interval);
  }, [animations.length]);

  return (
    <div className="min-h-screen flex items-center justify-center p-4 relative overflow-hidden bg-gradient-to-br from-amber-50 via-amber-100/70 to-amber-200/50 dark:from-slate-800 dark:via-amber-900/20 dark:to-slate-900/90">
      <div
        className="absolute inset-0"
        style={{
          backgroundImage: 'url(/noise.png)',
          backgroundRepeat: 'repeat',
          opacity: 0.025,
        }}
      />
      <div
        className="
          absolute inset-0 pointer-events-none
          [background-image:linear-gradient(90deg,rgba(241,194,125,0.15)_1px,transparent_1px),linear-gradient(180deg,rgba(241,194,125,0.15)_1px,transparent_1px)]
          dark:[background-image:linear-gradient(90deg,rgba(251,191,36,0.2)_1px,transparent_1px),linear-gradient(180deg,rgba(251,191,36,0.2)_1px,transparent_1px)]
          [background-size:20px_20px]
        "
      />

      <div className="absolute top-1/3 left-1/3 w-96 h-96 bg-amber-200/20 dark:bg-amber-500/20 rounded-full blur-3xl"></div>
      <div className="absolute bottom-1/3 right-1/3 w-64 h-64 bg-amber-300/20 dark:bg-amber-600/15 rounded-full blur-3xl"></div>

      <div className="w-full max-w-5xl z-10">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8 items-center">
          <div className="order-2 md:order-1 p-6">
            <div className="mb-2 text-lg text-amber-600 dark:text-amber-400 font-medium">
              Error 401
            </div>
            <h1 className="text-4xl md:text-5xl font-bold text-amber-900 dark:text-amber-100 font-display mb-6">
              Protected Move
            </h1>
            <p className="text-amber-800 dark:text-amber-200 mb-8">
              This game requires authentication to access. It looks like
              you&apos;re not signed in, or your session has expired, or you
              have no permission to view this page.
            </p>

            <div className="flex flex-col sm:flex-row gap-4">
              <Button
                onClick={() => router.push('/signin')}
                className="bg-amber-600 hover:bg-amber-700 text-white px-6 rounded-md 
                shadow-[0_4px_0_0_#b45309] hover:shadow-[0_2px_0_0_#92400e] hover:translate-y-[2px]
                dark:bg-amber-500 dark:hover:bg-amber-600
                dark:shadow-[0_4px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f]"
              >
                <ShieldCheckIcon className="mr-2 h-5 w-5" />
                Sign In
              </Button>

              <Button
                variant="outline"
                onClick={() => router.push('/home')}
                className="border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900
                shadow-[0_4px_0_0_#fcd34d] hover:shadow-[0_2px_0_0_#fcd34d] hover:translate-y-[2px]
                dark:bg-slate-800 dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-900
                dark:shadow-[0_4px_0_0_#475569] dark:hover:shadow-[0_1px_0_0_#475569]"
              >
                <HomeIcon className="mr-2 h-5 w-5" />
                Return Home
              </Button>
            </div>

            <div className="mt-12">
              <div className="text-sm text-amber-700 dark:text-amber-300">
                Don&apos;t have an account?
              </div>
              <div className="mt-2 flex gap-6">
                <Link
                  href="/signup"
                  className="text-amber-600 hover:text-amber-700 dark:text-amber-400 dark:hover:text-amber-300 flex items-center text-sm"
                >
                  Create Account
                  <ChevronRightIcon className="ml-1 h-4 w-4" />
                </Link>
                <Link
                  href="/"
                  className="text-amber-600 hover:text-amber-700 dark:text-amber-400 dark:hover:text-amber-300 flex items-center text-sm"
                >
                  Learn More
                  <ChevronRightIcon className="ml-1 h-4 w-4" />
                </Link>
              </div>
            </div>
          </div>

          <div className="order-1 md:order-2 p-6 flex justify-center">
            <div className="w-full max-w-sm relative">
              <div className="absolute z-1 -top-8 -left-8 md:-top-14 md:-left-14 w-20 h-20 md:w-32 md:h-32 rounded-full bg-white dark:bg-slate-800 shadow-md flex items-center justify-center">
                <div className="flex justify-center items-center h-full w-full">
                  <LockClosedIcon className="h-12 w-12 md:h-16 md:w-16 text-amber-300 dark:text-amber-600" />
                </div>
              </div>
              <div className="chess-board-container">
                <CustomChessBoard
                  className="shadow-2xl dark:shadow-black/30"
                  pgn={animations[chessAnimation]}
                />
              </div>
              <div className="absolute -bottom-8 -right-8 md:-bottom-12 md:-right-12 w-20 h-20 md:w-32 md:h-32 rounded-full bg-white dark:bg-slate-800 shadow-md flex items-center justify-center">
                <div className="text-6xl md:text-8xl font-bold text-amber-300 dark:text-amber-600 font-display">
                  ?
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="web/src/lib/auth/googleAuth.ts">
import {
  AuthCallbackResult,
  GoogleCognitoJwtPayload,
  JwtParseResult,
  UserInfo,
} from '@/types/googleAuthTypes';

export const initiateGoogleAuth = (redirectPath?: string): void => {
  const authEndpoint = process.env.NEXT_PUBLIC_GOOGLE_AUTH_ENDPOINT;
  if (!authEndpoint) {
    console.error('Google Auth endpoint not configured');
    localStorage.setItem(
      'auth_error',
      'Authentication endpoint not configured'
    );
    return;
  }

  if (redirectPath && typeof window !== 'undefined') {
    sessionStorage.setItem('auth_redirect', redirectPath);
  }

  localStorage.removeItem('auth_error');
  window.location.href = authEndpoint;
};

export const handleAuthCallback = (): AuthCallbackResult => {
  if (typeof window === 'undefined') {
    return { token: null, error: null, redirectPath: null };
  }

  const hash = window.location.hash;

  if (!hash) {
    return { token: null, error: null, redirectPath: null };
  }

  const params = new URLSearchParams(hash.substring(1));
  const idToken = params.get('id_token');
  const error = params.get('error');
  const errorDescription = params.get('error_description');

  const redirectPath = sessionStorage.getItem('auth_redirect');

  if (error) {
    const errorMessage = errorDescription || `Authentication error: ${error}`;
    localStorage.setItem('auth_error', errorMessage);
    return { token: null, error, redirectPath: '/' };
  }

  if (idToken) {
    localStorage.setItem('id_token', idToken);

    const expiryTime = Date.now() + 24 * 60 * 60 * 1000;
    localStorage.setItem('token_expiry', expiryTime.toString());

    sessionStorage.removeItem('auth_redirect');
    localStorage.removeItem('auth_error');

    const userInfo = parseJwt(idToken);
    if (userInfo) {
      localStorage.setItem('user_info', JSON.stringify(userInfo));
    }

    return {
      token: idToken,
      error: null,
      redirectPath: redirectPath || '/home',
    };
  }

  return {
    token: idToken,
    error,
    redirectPath,
  };
};

export const getAuthError = (): string | null => {
  if (typeof window === 'undefined') {
    return null;
  }

  return localStorage.getItem('auth_error');
};

export const clearAuthError = (): void => {
  if (typeof window === 'undefined') {
    return;
  }

  localStorage.removeItem('auth_error');
};

export const parseJwt = (token: string): JwtParseResult => {
  try {
    const base64Url = token.split('.')[1];
    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');

    const jsonPayload = decodeURIComponent(
      atob(base64)
        .split('')
        .map((c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
        .join('')
    );

    return JSON.parse(jsonPayload) as GoogleCognitoJwtPayload;
  } catch (error) {
    console.error('Error parsing JWT token:', error);
    return null;
  }
};

export const getUserInfo = (): UserInfo | null => {
  if (typeof window === 'undefined') {
    return null;
  }

  const userInfoStr = localStorage.getItem('user_info');

  if (!userInfoStr) {
    const token = getAuthToken();
    if (token) {
      const userInfo = parseJwt(token);
      if (userInfo) {
        localStorage.setItem('user_info', JSON.stringify(userInfo));
        return userInfo as UserInfo; // Cast to UserInfo is safe now with updated types
      }
    }
    return null;
  }

  try {
    return JSON.parse(userInfoStr) as UserInfo;
  } catch (error) {
    console.error('Error parsing user info:', error);
    return null;
  }
};

export const getUsername = (): string => {
  const userInfo = getUserInfo();

  if (userInfo) {
    return (
      userInfo.username ||
      userInfo['cognito:username'] ||
      userInfo.email?.split('@')[0] ||
      'User'
    );
  }

  return 'User';
};

export const getAuthToken = (): string | null => {
  if (typeof window === 'undefined') {
    return null;
  }

  const token = localStorage.getItem('id_token');
  const expiryTimeStr = localStorage.getItem('token_expiry');

  if (token && expiryTimeStr) {
    const expiryTime = parseInt(expiryTimeStr, 10);
    if (Date.now() > expiryTime) {
      localStorage.removeItem('id_token');
      localStorage.removeItem('token_expiry');
      localStorage.removeItem('user_info');
      return null;
    }
  }

  return token;
};

export const isAuthenticated = (): boolean => {
  return !!getAuthToken();
};

export const signOut = (): void => {
  if (typeof window === 'undefined') {
    return;
  }

  try {
    localStorage.removeItem('id_token');
    localStorage.removeItem('token_expiry');
    localStorage.removeItem('user_info');
    window.location.href = '/';
  } catch (error) {
    localStorage.setItem('auth_error', 'Failed to sign out properly: ' + error);
    window.location.href = '/';
  }
};
</file>

<file path="web/src/types/dashboard-props.ts">
export interface DashboardTabProps {
  setActiveTab: (tab: string) => void;
  username: string;
}
</file>

<file path="web/src/types/game-types.ts">
// /**
//  * Game status enum representing the possible states of a game
//  */
// export type GameStatus = 'ONGOING' | 'WHITE_WINS' | 'BLACK_WINS' | 'DRAW';

// /**
//  * Represents a game history entry in the database
//  */
// export interface GameHistoryEntry {
//   gameId: string;
//   white: string;
//   black: string;
//   pgn: string;
//   createdAt: Date;
//   status: GameStatus;
// }

// /**
//  * Response from the create game API
//  */
// export interface CreateGameResponse {
//   gameId: string;
// }

// /**
//  * Response from the update game API
//  */
// export interface UpdateGameResponse {
//   success: boolean;
//   gameId: string;
// }

// /**
//  * Response from the get games API
//  */
// export interface GetGamesResponse {
//   success: boolean;
//   games: GameHistoryEntry[];
// }

// /**
//  * Error response from APIs
//  */
// export interface ErrorResponse {
//   error: string;
//   message?: string;
// }

// /**
//  * Game outcome representation for socket games
//  */
// export interface GameOutcome {
//   type: 'Decisive' | 'Draw' | 'Ongoing';
//   winner?: 'w' | 'b';
// }

// /**
//  * Convert a GameStatus to a GameOutcome
//  */
// export const gameStatusToOutcome = (status: GameStatus): GameOutcome => {
//   switch (status) {
//     case 'WHITE_WINS':
//       return { type: 'Decisive', winner: 'w' };
//     case 'BLACK_WINS':
//       return { type: 'Decisive', winner: 'b' };
//     case 'DRAW':
//       return { type: 'Draw' };
//     case 'ONGOING':
//       return { type: 'Ongoing' };
//   }
// };

// /**
//  * Convert a GameOutcome to a GameStatus
//  */
// export const gameOutcomeToStatus = (outcome: GameOutcome): GameStatus => {
//   if (outcome.type === 'Decisive') {
//     return outcome.winner === 'w' ? 'WHITE_WINS' : 'BLACK_WINS';
//   } else if (outcome.type === 'Draw') {
//     return 'DRAW';
//   } else {
//     return 'ONGOING';
//   }
// };
</file>

<file path="web/src/types/googleAuthTypes.ts">
export interface CognitoIdentity {
  userId: string;
  providerName: string;
  providerType: string;
  issuer: string | null;
  primary: boolean;
  dateCreated: number;
}

export interface GoogleCognitoJwtPayload {
  at_hash: string;
  sub: string;
  'cognito:groups': string[];
  email_verified: boolean;
  iss: string;
  'cognito:username': string;
  aud: string;
  identities: CognitoIdentity[];
  token_use: string;
  auth_time: number;
  exp: number;
  iat: number;
  jti: string;
  email: string;
  [key: string]: unknown;
}

export interface AuthCallbackResult {
  token: string | null;
  error: string | null;
  redirectPath: string | null;
}

export interface UserInfo {
  username?: string;
  'cognito:username'?: string;
  email?: string;
  sub?: string;
  email_verified?: boolean;
  'cognito:groups'?: string[];
  [key: string]: unknown;
}

export type JwtParseResult = GoogleCognitoJwtPayload | null;
</file>

<file path="web/src/types/shared.ts">
export type Color = 'White' | 'Black';
export type ChessColor = 'w' | 'b';

export interface GameOutcome {
  Decisive?: {
    winner: Color;
  };
}

export type ErrorType =
  | 'Deserialization'
  | 'Unauthorized'
  | 'InvalidTurn'
  | 'InvalidMove'
  | 'ConnectionFailed'
  | 'ConnectionClosed'
  | 'Maximum reconnection attempts reached'
  | 'Cannot send move: connection not open'
  | 'Cannot send move: not authenticated'
  | 'Error parsing message'
  | 'Connection error'
  | 'Connection closed';

export type ClientMessage =
  | { kind: 'Auth'; value: { game_id: string; user_id: string } }
  | { kind: 'Move'; value: string };

export type ServerMessage =
  | { kind: 'Move'; value: string }
  | { kind: 'GameEnd'; value: GameOutcome | 'Draw' }
  | { kind: 'Error'; value: ErrorType | string }
  | { kind: 'AuthSuccess' }
  | { kind: 'MoveHistory'; value: string[] };

export type MoveCallback = (move: string) => void;
export type ConnectCallback = () => void;
export type ErrorCallback = (error: string) => void;
export type HistoryCallback = (moves: string[]) => void;
export type GameEndCallback = (outcome: GameOutcome | 'Draw') => void;
</file>

<file path="web/src/components/ChessBoard.tsx">
'use client';

import Chessground from 'react-chessground';
import 'react-chessground/dist/styles/chessground.css';
import { Chess } from 'chess.js';
import type { Square } from 'chess.js';
import Image from 'next/image';
import { Card, CardContent } from '@/components/ui/card';
import { Button } from '@/components/ui/button';

import wQ from 'react-chessground/dist/images/pieces/merida/wQ.svg';
import wR from 'react-chessground/dist/images/pieces/merida/wR.svg';
import wN from 'react-chessground/dist/images/pieces/merida/wN.svg';
import wB from 'react-chessground/dist/images/pieces/merida/wB.svg';
import bQ from 'react-chessground/dist/images/pieces/merida/bQ.svg';
import bR from 'react-chessground/dist/images/pieces/merida/bR.svg';
import bN from 'react-chessground/dist/images/pieces/merida/bN.svg';
import bB from 'react-chessground/dist/images/pieces/merida/bB.svg';

type PromotionPiece = 'q' | 'r' | 'n' | 'b';
const pieceImages: Record<'w' | 'b', Record<PromotionPiece, string>> = {
  w: { q: wQ, r: wR, n: wN, b: wB },
  b: { q: bQ, r: bR, n: bN, b: bB },
};

export interface ChessBoardProps {
  fen: string;
  onMove: (from: Square, to: Square) => void;
  lastMove?: [Square, Square];
  playingAs: 'w' | 'b';
  selectVisible: boolean;
  promotion: (piece: 'q' | 'r' | 'n' | 'b') => void;
  previewIndex: number | null;
  chess: Chess;
  viewOnly?: boolean;
}

export function calcMovable(chess: Chess) {
  const dests = new Map<Square, Square[]>();
  for (const row of chess.board()) {
    for (const piece of row) {
      if (piece && piece.square) {
        const moves = chess.moves({ square: piece.square, verbose: true }) as {
          to: Square;
        }[];
        if (moves.length)
          dests.set(
            piece.square as Square,
            moves.map((m) => m.to)
          );
      }
    }
  }
  return dests;
}

export function ChessBoard({
  fen,
  onMove,
  lastMove,
  playingAs,
  selectVisible,
  promotion,
  previewIndex,
  chess,
  viewOnly = false,
}: ChessBoardProps) {
  const handleMove = (from: Square, to: Square) => {
    if (previewIndex !== null || viewOnly) return;
    onMove(from, to);
  };

  return (
    <Card className="w-full max-w-lg mx-auto bg-transparent border-0 shadow-none pt-4 pb-0 md:py-6">
      <CardContent
        className={`p-0 ${
          previewIndex !== null
            ? 'bg-amber-500 dark:bg-amber-500 rounded-sm'
            : ''
        }`}
      >
        <div className="w-full">
          <div className="w-full aspect-square relative">
            <Chessground
              width="100%"
              height="100%"
              fen={fen}
              onMove={handleMove}
              lastMove={lastMove}
              turnColor={chess.turn() === 'w' ? 'white' : 'black'}
              orientation={playingAs === 'w' ? 'white' : 'black'}
              movable={{
                free: false,
                color:
                  previewIndex !== null || viewOnly
                    ? undefined
                    : chess.turn() === playingAs
                    ? playingAs === 'w'
                      ? 'white'
                      : 'black'
                    : undefined,
                dests:
                  previewIndex !== null || viewOnly
                    ? new Map()
                    : calcMovable(chess),
              }}
              coordinates={true}
              animation={{ enabled: true, duration: 100 }}
              highlight={{
                lastMove: true,
                check: true,
              }}
              viewOnly={previewIndex !== null || viewOnly}
            />

            {selectVisible && !previewIndex && !viewOnly && (
              <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-white/70 dark:bg-slate-800/70 backdrop-blur-sm border border-amber-200/50 dark:border-amber-800/30 p-4 rounded-lg shadow-md dark:shadow-black/20 z-10">
                <div className="flex gap-4">
                  {(['q', 'r', 'n', 'b'] as const).map((piece) => (
                    <Button
                      key={piece}
                      variant="outline"
                      className="w-12 h-12 p-0 flex justify-center items-center 
                      border-amber-300 text-amber-800 hover:bg-amber-50/80 
                      shadow-[0_4px_0_0_#fcd34d] hover:shadow-[0_2px_0_0_#fcd34d] hover:translate-y-[2px]
                      dark:bg-slate-800/70 dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50
                      dark:shadow-[0_4px_0_0_#475569] dark:hover:shadow-[0_1px_0_0_#475569]
                      backdrop-blur-sm"
                      onClick={() => promotion(piece)}
                    >
                      <Image
                        src={pieceImages[chess.turn() as 'w' | 'b'][piece]}
                        alt={`${
                          chess.turn() === 'w' ? 'White' : 'Black'
                        } ${piece.toUpperCase()}`}
                        width={40}
                        height={40}
                      />
                    </Button>
                  ))}
                </div>
              </div>
            )}
          </div>

          {previewIndex !== null ? (
            <div className="bg-amber-500 text-white text-center py-3 font-medium">
              Preview Mode
            </div>
          ) : viewOnly && chess.isGameOver() ? (
            <div className="bg-amber-600 text-white text-center py-3 font-medium">
              Game Ended
            </div>
          ) : (
            <div className="bg-transparent py-6 font-medium"></div>
          )}
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="web/src/components/ChessCloud.tsx">
import { useRouter } from 'next/navigation';
import { isAuthenticated } from '@/lib/auth/googleAuth';

interface ChessCloudIconProps {
  className?: string;
}

export default function ChessCloudIcon({
  className = '',
}: ChessCloudIconProps) {
  const router = useRouter();

  const handleClick = () => {
    router.push(isAuthenticated() ? '/home' : '/');
  };

  return (
    <div
      onClick={handleClick}
      className={`
        relative
        h-8 w-8
        rounded
        bg-amber-600 dark:bg-amber-500
        mr-2
        overflow-hidden
        transition-transform transition-shadow duration-700 hover:duration-[1500ms] ease-out dark:duration-300
        shadow-[0_8px_16px_rgba(180,83,9,0.2)] dark:shadow-[0_8px_16px_rgba(245,158,11,0.3)]
        hover:-translate-y-0.5
        hover:shadow-[0_8px_16px_rgba(180,83,9,0.2),0_0_12px_rgba(245,158,11,0.5),0_0_24px_rgba(245,158,11,0.3)]
        animate-[float_8s_ease-in-out_infinite] dark:animate-[float_2s_ease-in-out_infinite]
        ${className}
      `}
    >
      <div className="absolute inset-0 grid grid-cols-2 grid-rows-2 p-[15%]">
        <div className="bg-amber-100" />
        <div className="bg-amber-800 dark:bg-amber-900" />
        <div className="bg-amber-800 dark:bg-amber-900" />
        <div className="bg-amber-100" />
      </div>
    </div>
  );
}
</file>

<file path="web/src/lib/engine.ts">
import {
  EngineMessageResponse,
  EngineTestResponse,
  BestMoveResponse,
  EngineType,
} from '@/types/engineTypes';

const ENGINE_API_URL = process.env.NEXT_PUBLIC_ENGINE_API_URL!;
const MAX_RETRIES = 5;
const RETRY_DELAY = 1000;
const BACKOFF_FACTOR = 1.5;

async function fetchWithRetry<T extends EngineType>(
  url: string,
  options: RequestInit = {},
  retries = MAX_RETRIES
): Promise<T> {
  const resp = await fetch(url, options);
  if (!resp.ok) {
    if (retries > 1) {
      const delay =
        RETRY_DELAY * Math.pow(BACKOFF_FACTOR, MAX_RETRIES - retries);
      await new Promise((resolve) => setTimeout(resolve, delay));
      return fetchWithRetry<T>(url, options, retries - 1);
    }
    console.log(`Request failed: ${resp.status}`);
  }
  return resp.json() as Promise<T>;
}

export function getEngineStatus(): Promise<EngineMessageResponse> {
  return fetchWithRetry<EngineMessageResponse>(`${ENGINE_API_URL}/`);
}

export function testEngine(): Promise<EngineTestResponse> {
  return fetchWithRetry<EngineTestResponse>(`${ENGINE_API_URL}/test`);
}

export function getBestMove(fen: string): Promise<BestMoveResponse> {
  const encoded = encodeURIComponent(fen);
  return fetchWithRetry<BestMoveResponse>(
    `${ENGINE_API_URL}/bestmove?fen=${encoded}`
  );
}
</file>

<file path="web/src/lib/prisma.ts">
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export default prisma;
</file>

<file path="ws_server/Cargo.toml">
[package]
name = "ws_server"
version = "0.1.0"
edition = "2021"
default-run = "ws_server"

[dependencies]
anyhow = "1.0.97"
axum = { version = "0.8.3", features = ["ws"] }
axum-macros = "0.5.0"
dotenvy = "0.15.7"
futures-util = "0.3.31"
reqwest = { version = "0.12.15", features = ["json"] }
scc = "2.3.3"
serde = { version = "1.0.219", features = ["derive"] }
serde_json = "1.0.140"
shakmaty = { version = "0.27.3", features = ["serde"] }
sqlx = { version = "0.8.5", features = ["macros", "postgres", "runtime-tokio", "tls-native-tls", "uuid"] }
tokio = { version = "1.44.1", features = ["full"] }
tokio-tungstenite = "0.26.2"
tower-http = { version = "0.5.2", features = ["cors"] }
tracing = "0.1.41"
tracing-subscriber = "0.3.19"
ts-rs = "10.1.0"
uuid = "1.16.0"
</file>

<file path="engine/docker-compose.yml">
services:
  stockfish:
    build:
      context: ./stockfish
      dockerfile: Dockerfile
    container_name: stockfish
    ports:
      - "4001:4001"
    networks:
      - engine
      
  hyper:
    build:
      context: ./hyper
      dockerfile: Dockerfile
    container_name: hyper
    ports:
      - "4000:4000"
    depends_on:
      - stockfish
    networks:
      - engine

networks:
  engine:
    driver: bridge
</file>

<file path="web/prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model gamestate {
  gameid    String     @id @default(uuid()) @db.Uuid
  white     String
  black     String
  pgn       String
  createdat DateTime?  @default(now()) @db.Timestamp(6)
  status    GameStatus @default(ONGOING)
}

enum GameStatus {
  WHITE_WINS @map("White Wins")
  BLACK_WINS @map("Black Wins")
  DRAW       @map("Draw")
  ONGOING    @map("On Going")
  ABORTED    @map("Abort")
}
</file>

<file path="web/src/app/game/page.tsx">
'use client';

import { useState, useCallback } from 'react';
import { Chess } from 'chess.js';
import type { Square } from 'chess.js';
import GamePane from '@/components/GamePane';

export default function Game() {
  const [chess] = useState(new Chess());
  const [fen, setFen] = useState(chess.fen());
  const [lastMove, setLastMove] = useState<[Square, Square] | undefined>();
  const [selectVisible, setSelectVisible] = useState(false);
  const [pendingMove, setPendingMove] = useState<
    [Square, Square] | undefined
  >();
  const [previewIndex, setPreviewIndex] = useState<number | null>(null);

  const fullHistory = chess.history({ verbose: true });

  const updateState = useCallback(() => {
    setFen(chess.fen());
  }, [chess]);

  const randomMove = useCallback(() => {
    const moves = chess.moves({ verbose: true });
    if (moves.length > 0 && !chess.isGameOver()) {
      const random = moves[Math.floor(Math.random() * moves.length)];
      chess.move(random);
      setLastMove([random.from as Square, random.to as Square]);
      updateState();
    }
  }, [chess, updateState]);

  const onMove = useCallback(
    (from: Square, to: Square) => {
      if (previewIndex !== null) {
        setPreviewIndex(null);
        return;
      }

      const moves = chess.moves({ verbose: true });
      const moveFound = moves.find((m) => m.from === from && m.to === to);
      if (!moveFound) return;

      if (moveFound.promotion) {
        setPendingMove([from, to]);
        setSelectVisible(true);
      } else if (chess.move({ from, to })) {
        setLastMove([from, to]);
        updateState();
        setTimeout(randomMove, 500);
      }
    },
    [chess, previewIndex, updateState, randomMove]
  );

  const promotion = useCallback(
    (piece: 'q' | 'r' | 'n' | 'b') => {
      if (!pendingMove) return;
      const [from, to] = pendingMove;
      chess.move({ from, to, promotion: piece });
      setLastMove([from, to]);
      setSelectVisible(false);
      updateState();
      setTimeout(randomMove, 500);
    },
    [chess, pendingMove, randomMove, updateState]
  );

  const previewMove = useCallback(
    (index: number) => {
      if (index >= fullHistory.length) setPreviewIndex(null);
      else setPreviewIndex(index);
    },
    [fullHistory.length]
  );

  const handleFirstMove = useCallback(() => {
    if (fullHistory.length > 0) {
      setPreviewIndex(0);
    }
  }, [fullHistory.length]);

  const handlePrevious = useCallback(() => {
    if (previewIndex === null && fullHistory.length > 0) {
      setPreviewIndex(fullHistory.length - 1);
    } else if (previewIndex !== null && previewIndex > 0) {
      setPreviewIndex(previewIndex - 1);
    }
  }, [previewIndex, fullHistory.length]);

  const handleNext = useCallback(() => {
    if (previewIndex !== null && previewIndex < fullHistory.length - 1) {
      setPreviewIndex(previewIndex + 1);
    } else if (
      previewIndex !== null &&
      previewIndex === fullHistory.length - 1
    ) {
      setPreviewIndex(null);
    }
  }, [previewIndex, fullHistory.length]);

  const handleLastMove = useCallback(() => {
    setPreviewIndex(null);
  }, []);

  const calcPreviewFen = useCallback(() => {
    if (previewIndex === null) return null;
    const temp = new Chess();
    fullHistory.slice(0, previewIndex).forEach((m) => temp.move(m.san));
    return temp.fen();
  }, [previewIndex, fullHistory]);

  const gameProps = {
    chess,
    fen,
    lastMove,
    selectVisible,
    pendingMove,
    previewIndex,
    fullHistory,
    previewFen: calcPreviewFen(),
    onMove,
    promotion,
    previewMove,
    handleFirstMove,
    handlePrevious,
    handleNext,
    handleLastMove,
  };

  return (
    <div className="container mx-auto py-8 px-4">
      <GamePane playingAs="w" gameProps={gameProps} />
    </div>
  );
}
</file>

<file path="web/src/app/signin/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import Link from 'next/link';
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import { Separator } from '@/components/ui/separator';
import { HomeIcon } from '@heroicons/react/24/outline';
import ThemeSwitch from '@/components/ThemeSwitch';
import {
  initiateGoogleAuth,
  getAuthError,
  clearAuthError,
  isAuthenticated,
} from '@/lib/auth/googleAuth';
import { toast } from 'sonner';
import { useRouter } from 'next/navigation';
import ChessCloudIcon from '@/components/ChessCloud';

export default function SignIn() {
  const [isLoading, setIsLoading] = useState(false);
  const [pressedButton, setPressedButton] = useState<string | null>(null);
  const router = useRouter();

  useEffect(() => {
    if (isAuthenticated()) {
      router.push('/home');
      return;
    }

    const error = getAuthError();
    if (error) {
      toast.warning('Authentication Error', {
        description: error,
      });
      clearAuthError();
    }

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key.toLowerCase() === 'g') {
        setPressedButton('google');
        setTimeout(() => {
          handleSignInWithGoogle();
        }, 150);
      }
    };

    const handleKeyUp = () => {
      setPressedButton(null);
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [router]);

  const handleSignInWithGoogle = () => {
    setPressedButton('google');
    setIsLoading(true);
    initiateGoogleAuth('/home');
  };

  return (
    <div className="min-h-screen flex flex-col text-slate-800 dark:text-amber-50 relative overflow-hidden bg-gradient-to-br from-amber-50 via-amber-100/70 to-amber-200/50 dark:from-slate-800 dark:via-amber-900/20 dark:to-slate-900/90">
      <div
        className="absolute inset-0"
        style={{
          backgroundImage: 'url(/noise.png)',
          backgroundRepeat: 'repeat',
          opacity: 0.025,
        }}
      />
      <div
        className="
          absolute inset-0 pointer-events-none
          [background-image:linear-gradient(90deg,rgba(241,194,125,0.15)_1px,transparent_1px),linear-gradient(180deg,rgba(241,194,125,0.15)_1px,transparent_1px)]
          dark:[background-image:linear-gradient(90deg,rgba(251,191,36,0.2)_1px,transparent_1px),linear-gradient(180deg,rgba(251,191,36,0.2)_1px,transparent_1px)]
          [background-size:20px_20px]
        "
      />

      <div className="absolute top-1/4 left-1/4 w-96 h-96 bg-amber-200/20 dark:bg-amber-500/20 rounded-full blur-3xl"></div>
      <div className="absolute bottom-1/3 right-1/4 w-64 h-64 bg-amber-300/20 dark:bg-amber-600/15 rounded-full blur-3xl"></div>

      <div className="flex-grow flex items-center justify-center p-4 relative z-10">
        <Card className="w-full max-w-md bg-white/70 dark:bg-slate-800/70 backdrop-blur-sm border border-amber-200/50 dark:border-amber-700/40 shadow-xl dark:shadow-amber-900/30">
          <CardHeader className="space-y-1 text-center pb-1 pt-6">
            <div className="flex justify-between items-center mb-6">
              <Button
                variant="outline"
                className="h-9 w-9 p-0 rounded-md border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900
                shadow-[0_4px_0_0_#fcd34d] hover:shadow-[0_2px_0_0_#fcd34d] hover:translate-y-[2px]
                dark:bg-slate-800/70 dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50
                dark:shadow-[0_4px_0_0_#475569] dark:hover:shadow-[0_2px_0_0_#475569]"
                onClick={() => (window.location.href = '/')}
              >
                <HomeIcon className="h-5 w-5" />
              </Button>

              <ChessCloudIcon className="h-12 w-12" />

              <ThemeSwitch />
            </div>

            <CardTitle className="text-2xl font-bold text-amber-900 dark:text-amber-100 font-display">
              Sign in to ChessClouds
            </CardTitle>
            <CardDescription className="text-amber-700 dark:text-amber-300">
              Continue with your preferred account
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <Button
              variant="outline"
              className={`w-full border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900 px-6 rounded-md transition-all 
              shadow-[0_4px_0_0_#fcd34d] hover:shadow-[0_2px_0_0_#fcd34d] hover:translate-y-[2px]
              dark:bg-slate-800/70 dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50
              dark:shadow-[0_4px_0_0_#475569] dark:hover:shadow-[0_2px_0_0_#475569]
              ${
                pressedButton === 'google'
                  ? 'transform translate-y-[3px] shadow-none bg-amber-100 dark:bg-slate-800'
                  : ''
              }`}
              disabled={isLoading}
              onClick={handleSignInWithGoogle}
            >
              <svg className="w-5 h-5 mr-2" viewBox="0 0 24 24">
                <path
                  d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
                  fill="#4285F4"
                />
                <path
                  d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
                  fill="#34A853"
                />
                <path
                  d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
                  fill="#FBBC05"
                />
                <path
                  d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
                  fill="#EA4335"
                />
              </svg>
              {isLoading && pressedButton === 'google'
                ? 'Signing in...'
                : 'Continue with Google'}
              <span
                className={`ml-1 text-xs px-1 rounded transition-colors ${
                  pressedButton === 'google'
                    ? 'bg-amber-200 text-amber-900 dark:bg-slate-700 dark:text-amber-100'
                    : 'bg-amber-100 dark:bg-slate-800'
                }`}
              >
                G
              </span>
            </Button>
          </CardContent>
          <Separator className="my-1 bg-amber-200/30 dark:bg-amber-700/20" />
          <CardFooter className="flex flex-col space-y-4 pt-4">
            <div className="text-center text-sm text-amber-700 dark:text-amber-300">
              Don&apos;t have an account?{' '}
              <Link
                href="/signup"
                className="text-amber-600 hover:text-amber-700 dark:text-amber-400 dark:hover:text-amber-300 font-medium underline underline-offset-4"
              >
                Sign up
              </Link>
            </div>
          </CardFooter>
        </Card>
      </div>
    </div>
  );
}
</file>

<file path="web/src/app/signup/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import Link from 'next/link';
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import { Separator } from '@/components/ui/separator';
import { HomeIcon } from '@heroicons/react/24/outline';
import ThemeSwitch from '@/components/ThemeSwitch';
import {
  initiateGoogleAuth,
  getAuthError,
  clearAuthError,
  isAuthenticated,
} from '@/lib/auth/googleAuth';
import { toast } from 'sonner';
import { useRouter } from 'next/navigation';
import ChessCloudIcon from '@/components/ChessCloud';

export default function SignUp() {
  const [isLoading, setIsLoading] = useState(false);
  const [pressedButton, setPressedButton] = useState<string | null>(null);
  const router = useRouter();

  useEffect(() => {
    if (isAuthenticated()) {
      router.push('/home');
      return;
    }

    const error = getAuthError();
    if (error) {
      toast.warning('Authentication Error', {
        description: error,
      });
      clearAuthError();
    }

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key.toLowerCase() === 'g') {
        setPressedButton('google');
        setTimeout(() => {
          handleSignUpWithGoogle();
        }, 150);
      }
    };

    const handleKeyUp = () => {
      setPressedButton(null);
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [router]);

  const handleSignUpWithGoogle = () => {
    setPressedButton('google');
    setIsLoading(true);
    initiateGoogleAuth('/home');
  };

  return (
    <div className="min-h-screen flex flex-col text-slate-800 dark:text-amber-50 relative overflow-hidden bg-gradient-to-tl from-amber-50 via-amber-100/70 to-amber-200/50 dark:from-slate-800 dark:via-amber-900/20 dark:to-slate-900/90">
      <div
        className="absolute inset-0"
        style={{
          backgroundImage: 'url(/noise.png)',
          backgroundRepeat: 'repeat',
          opacity: 0.025,
        }}
      />
      <div
        className="
          absolute inset-0 pointer-events-none
          [background-image:linear-gradient(90deg,rgba(241,194,125,0.15)_1px,transparent_1px),linear-gradient(180deg,rgba(241,194,125,0.15)_1px,transparent_1px)]
          dark:[background-image:linear-gradient(90deg,rgba(251,191,36,0.2)_1px,transparent_1px),linear-gradient(180deg,rgba(251,191,36,0.2)_1px,transparent_1px)]
          [background-size:20px_20px]
        "
      />

      <div className="absolute top-1/3 right-1/4 w-96 h-96 bg-amber-200/20 dark:bg-amber-500/20 rounded-full blur-3xl"></div>
      <div className="absolute bottom-1/4 left-1/3 w-80 h-80 bg-amber-300/20 dark:bg-amber-600/15 rounded-full blur-3xl"></div>

      <div className="flex-grow flex items-center justify-center p-4 relative z-10">
        <Card className="w-full max-w-md bg-white/70 dark:bg-slate-800/70 backdrop-blur-sm border border-amber-200/50 dark:border-amber-700/40 shadow-xl dark:shadow-amber-900/30">
          <CardHeader className="space-y-1 text-center pb-1 pt-6">
            <div className="flex justify-between items-center mb-6">
              <Button
                variant="outline"
                className="h-9 w-9 p-0 rounded-md border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900
                shadow-[0_4px_0_0_#fcd34d] hover:shadow-[0_2px_0_0_#fcd34d] hover:translate-y-[2px]
                dark:bg-slate-800/70 dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50
                dark:shadow-[0_4px_0_0_#475569] dark:hover:shadow-[0_2px_0_0_#475569]"
                onClick={() => (window.location.href = '/')}
              >
                <HomeIcon className="h-5 w-5" />
              </Button>

              <ChessCloudIcon className="h-12 w-12" />

              <ThemeSwitch />
            </div>

            <CardTitle className="text-2xl font-bold text-amber-900 dark:text-amber-100 font-display">
              Join ChessClouds
            </CardTitle>
            <CardDescription className="text-amber-700 dark:text-amber-300">
              Create your account to start playing
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <Button
              variant="outline"
              className={`w-full border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900 px-6 rounded-md transition-all 
              shadow-[0_4px_0_0_#fcd34d] hover:shadow-[0_2px_0_0_#fcd34d] hover:translate-y-[2px]
              dark:bg-slate-800/70 dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50
              dark:shadow-[0_4px_0_0_#475569] dark:hover:shadow-[0_2px_0_0_#475569]
              ${
                pressedButton === 'google'
                  ? 'transform translate-y-[3px] shadow-none bg-amber-100 dark:bg-slate-800'
                  : ''
              }`}
              disabled={isLoading}
              onClick={handleSignUpWithGoogle}
            >
              <svg className="w-5 h-5 mr-2" viewBox="0 0 24 24">
                <path
                  d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
                  fill="#4285F4"
                />
                <path
                  d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
                  fill="#34A853"
                />
                <path
                  d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
                  fill="#FBBC05"
                />
                <path
                  d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
                  fill="#EA4335"
                />
              </svg>
              {isLoading && pressedButton === 'google'
                ? 'Creating account...'
                : 'Sign up with Google'}
              <span
                className={`ml-1 text-xs px-1 rounded transition-colors ${
                  pressedButton === 'google'
                    ? 'bg-amber-200 text-amber-900 dark:bg-slate-700 dark:text-amber-100'
                    : 'bg-amber-100 dark:bg-slate-800'
                }`}
              >
                G
              </span>
            </Button>

            <div className="text-xs text-center text-amber-600 dark:text-amber-400 mt-6">
              By signing up, you agree to our{' '}
              <Link href="#" className="underline underline-offset-2">
                Terms of Service
              </Link>{' '}
              and{' '}
              <Link href="#" className="underline underline-offset-2">
                Privacy Policy
              </Link>
            </div>
          </CardContent>
          <Separator className="my-1 bg-amber-200/30 dark:bg-amber-700/20" />
          <CardFooter className="flex flex-col space-y-4">
            <div className="text-center text-sm text-amber-700 dark:text-amber-300">
              Already have an account?{' '}
              <Link
                href="/signin"
                className="text-amber-600 hover:text-amber-700 dark:text-amber-400 dark:hover:text-amber-300 font-medium underline underline-offset-4"
              >
                Sign in
              </Link>
            </div>
          </CardFooter>
        </Card>
      </div>
    </div>
  );
}
</file>

<file path="web/src/components/dashboard/Friend.tsx">
'use client';

import { useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Separator } from '@/components/ui/separator';
import {
  ArrowLeftIcon,
  ArrowRightIcon,
  MagnifyingGlassIcon,
  UserPlusIcon,
  XMarkIcon,
  CheckIcon,
} from '@heroicons/react/24/outline';

const mockFriends = Array(30)
  .fill(null)
  .map((_, i) => {
    const names = [
      'martin-xiii',
      'dj-ron-passano',
      'Jdomenusrex',
      'knight_rider',
      'chess_lover99',
      'tactical_genius',
      'queen_gambit',
      'pawn_star',
      'rook_roller',
      'bishop_boss',
      'checkmate101',
      'kingpin',
      'queenb',
      'castle_master',
      'endgame_expert',
      'opening_theory',
      'pawn_pusher',
      'knight_mover',
      'bishop_slider',
      'rook_checker',
    ];
    const statuses = ['online', 'offline', 'playing'];
    const ratings = [
      1800, 1350, 446, 550, 700, 625, 520, 830, 490, 675, 900, 1200, 1500, 1600,
      1700,
    ];

    return {
      id: i + 1,
      name: names[i % names.length],
      status: statuses[Math.floor(Math.random() * statuses.length)],
      rating: ratings[i % ratings.length],
      lastSeen: Math.floor(Math.random() * 30) + 1,
    };
  });

const mockInvitations = [
  { id: 1, name: 'chess_master42', rating: 1650 },
  { id: 2, name: 'grand_wizard', rating: 1423 },
  { id: 3, name: 'rook_rookie', rating: 820 },
];

const mockUserSearch = [
  { id: 101, name: 'chess_prodigy', rating: 1920 },
  { id: 102, name: 'pawn_punisher', rating: 1340 },
  { id: 103, name: 'knight_rider99', rating: 1675 },
  { id: 104, name: 'bishop_blitz', rating: 1580 },
  { id: 105, name: 'queen_attack', rating: 1460 },
];

export default function FriendsTab() {
  const [currentPage, setCurrentPage] = useState(1);
  const [friendSearchTerm, setFriendSearchTerm] = useState('');
  const [userSearchTerm, setUserSearchTerm] = useState('');
  const [userSearchResults, setUserSearchResults] = useState<
    typeof mockUserSearch
  >([]);
  const [invitationSearchTerm, setInvitationSearchTerm] = useState('');
  const [showUserSearch, setShowUserSearch] = useState(false);

  const itemsPerPage = 7;

  const filteredFriends = mockFriends.filter(
    (friend) =>
      friendSearchTerm === '' ||
      friend.name.toLowerCase().includes(friendSearchTerm.toLowerCase())
  );

  const filteredInvitations = mockInvitations.filter(
    (invitation) =>
      invitationSearchTerm === '' ||
      invitation.name.toLowerCase().includes(invitationSearchTerm.toLowerCase())
  );

  const totalPages = Math.ceil(filteredFriends.length / itemsPerPage);
  const paginatedFriends = filteredFriends.slice(
    (currentPage - 1) * itemsPerPage,
    currentPage * itemsPerPage
  );

  const handlePreviousPage = () => {
    if (currentPage > 1) {
      setCurrentPage(currentPage - 1);
    }
  };

  const handleNextPage = () => {
    if (currentPage < totalPages) {
      setCurrentPage(currentPage + 1);
    }
  };

  const handleUserSearch = () => {
    if (userSearchTerm.trim() === '') {
      setUserSearchResults([]);
      return;
    }

    const results = mockUserSearch.filter((user) =>
      user.name.toLowerCase().includes(userSearchTerm.toLowerCase())
    );

    setUserSearchResults(results);
    setShowUserSearch(true);
  };

  const handlePlayerSearchKeyDown = (
    e: React.KeyboardEvent<HTMLInputElement>
  ) => {
    if (e.key === 'Enter') {
      handleUserSearch();
    }
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'online':
        return 'bg-green-600';
      case 'playing':
        return 'bg-amber-600';
      case 'offline':
        return 'bg-slate-400';
      default:
        return 'bg-slate-400';
    }
  };

  const getStatusText = (status: string, lastSeen: number) => {
    switch (status) {
      case 'online':
        return 'Online now';
      case 'playing':
        return 'Playing now';
      case 'offline':
        return `Last online ${lastSeen} ${lastSeen === 1 ? 'day' : 'days'} ago`;
      default:
        return '';
    }
  };

  return (
    <div className="flex flex-col lg:flex-row gap-4 sm:gap-6">
      {/* Friends List */}
      <div className="w-full lg:flex-1 order-2 lg:order-1">
        <Card className="w-full bg-white/50 dark:bg-slate-800/50 backdrop-blur-sm border border-amber-200/50 dark:border-amber-800/30 shadow-md">
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-lg font-semibold text-amber-900 dark:text-amber-100">
              Friends ({filteredFriends.length})
            </CardTitle>
            <div className="relative w-full max-w-[300px]">
              <Input
                type="text"
                placeholder="Search friends"
                value={friendSearchTerm}
                onChange={(e) => setFriendSearchTerm(e.target.value)}
                className="pl-8 bg-amber-50/80 dark:bg-slate-700/80 border-amber-200 dark:border-slate-600"
              />
              <MagnifyingGlassIcon className="absolute left-2.5 top-2.5 h-4 w-4 text-amber-700 dark:text-amber-300" />
            </div>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-1 gap-4">
              {paginatedFriends.length > 0 ? (
                paginatedFriends.map((friend) => (
                  <div
                    key={friend.id}
                    className="p-4 rounded-lg bg-amber-50/70 dark:bg-slate-700/50 border border-amber-200/30 dark:border-amber-800/20 hover:bg-amber-100/70 dark:hover:bg-slate-700/70 transition-colors"
                  >
                    <div className="flex items-start gap-3">
                      <div className="relative mt-1">
                        <div className="h-12 w-12 rounded-full bg-amber-100 dark:bg-slate-600 flex items-center justify-center text-amber-600 dark:text-amber-400 font-medium text-lg">
                          {friend.name[0].toUpperCase()}
                        </div>
                        <div
                          className={`absolute -bottom-1 -right-1 h-4 w-4 rounded-full border-2 border-white dark:border-slate-700 ${getStatusColor(
                            friend.status
                          )}`}
                        ></div>
                      </div>

                      <div className="flex-1 min-w-0">
                        <div className="font-medium text-amber-800 dark:text-amber-200 truncate">
                          {friend.name}
                        </div>
                        <div className="text-sm text-amber-600 dark:text-amber-400">
                          Rating: {friend.rating}
                        </div>
                        <div className="text-xs text-amber-500 dark:text-amber-500 mt-1">
                          {getStatusText(friend.status, friend.lastSeen)}
                        </div>
                      </div>

                      <div className="flex flex-col gap-2">
                        <button className="text-green-600 dark:text-green-400 hover:text-green-800 dark:hover:text-green-300 p-1.5 rounded-full hover:bg-green-50 dark:hover:bg-green-900/20">
                          <svg
                            xmlns="http://www.w3.org/2000/svg"
                            fill="none"
                            viewBox="0 0 24 24"
                            strokeWidth={1.5}
                            stroke="currentColor"
                            className="w-5 h-5"
                          >
                            <path
                              strokeLinecap="round"
                              strokeLinejoin="round"
                              d="M21 8.25c0-2.485-2.099-4.5-4.688-4.5-1.935 0-3.597 1.126-4.312 2.733-.715-1.607-2.377-2.733-4.313-2.733C5.1 3.75 3 5.765 3 8.25c0 7.22 9 12 9 12s9-4.78 9-12z"
                            />
                          </svg>
                        </button>

                        <button className="text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300 p-1.5 rounded-full hover:bg-blue-50 dark:hover:bg-blue-900/20">
                          <svg
                            xmlns="http://www.w3.org/2000/svg"
                            fill="none"
                            viewBox="0 0 24 24"
                            strokeWidth={1.5}
                            stroke="currentColor"
                            className="w-5 h-5"
                          >
                            <path
                              strokeLinecap="round"
                              strokeLinejoin="round"
                              d="M20.25 8.511c.884.284 1.5 1.128 1.5 2.097v4.286c0 1.136-.847 2.1-1.98 2.193-.34.027-.68.052-1.02.072v3.091l-3-3c-1.354 0-2.694-.055-4.02-.163a2.115 2.115 0 01-.825-.242m9.345-8.334a2.126 2.126 0 00-.476-.095 48.64 48.64 0 00-8.048 0c-1.131.094-1.976 1.057-1.976 2.192v4.286c0 .837.46 1.58 1.155 1.951m9.345-8.334V6.637c0-1.621-1.152-3.026-2.76-3.235A48.455 48.455 0 0011.25 3c-2.115 0-4.198.137-6.24.402-1.608.209-2.76 1.614-2.76 3.235v6.226c0 1.621 1.152 3.026 2.76 3.235.577.075 1.157.14 1.74.194V21l4.155-4.155"
                            />
                          </svg>
                        </button>
                      </div>
                    </div>
                  </div>
                ))
              ) : (
                <div className="col-span-1 md:col-span-2 py-8 text-center text-amber-600 dark:text-amber-400">
                  No friends found matching your search.
                </div>
              )}
            </div>

            {/* Pagination Controls */}
            {totalPages > 1 && (
              <div className="flex flex-col sm:flex-row justify-between items-center mt-6 gap-2">
                <div className="text-sm text-amber-700 dark:text-amber-300 order-2 sm:order-1">
                  Showing {(currentPage - 1) * itemsPerPage + 1} to{' '}
                  {Math.min(currentPage * itemsPerPage, filteredFriends.length)}{' '}
                  of {filteredFriends.length} friends
                </div>
                <div className="flex space-x-2 order-1 sm:order-2">
                  <Button
                    variant="outline"
                    size="sm"
                    className="h-8 w-8 p-0 border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900
                    dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50"
                    onClick={handlePreviousPage}
                    disabled={currentPage === 1}
                  >
                    <ArrowLeftIcon className="h-4 w-4" />
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    className="h-8 w-8 p-0 border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900
                    dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50"
                    onClick={handleNextPage}
                    disabled={currentPage === totalPages}
                  >
                    <ArrowRightIcon className="h-4 w-4" />
                  </Button>
                </div>
              </div>
            )}
          </CardContent>
        </Card>
      </div>

      {/* Find Players */}
      <div className="w-full lg:w-80 lg:flex-shrink-0 order-1 lg:order-2">
        <Card className="w-full bg-white/50 dark:bg-slate-800/50 backdrop-blur-sm border border-amber-200/50 dark:border-amber-800/30 shadow-md">
          <CardHeader className="pb-2">
            <CardTitle className="text-lg font-semibold text-amber-900 dark:text-amber-100">
              Find Players
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="space-y-2">
              <div className="relative">
                <Input
                  type="text"
                  placeholder="Search players"
                  value={userSearchTerm}
                  onChange={(e) => setUserSearchTerm(e.target.value)}
                  onKeyDown={handlePlayerSearchKeyDown}
                  className="pl-8 bg-amber-50/80 dark:bg-slate-700/80 border-amber-200 dark:border-slate-600"
                />
                <MagnifyingGlassIcon className="absolute left-2.5 top-2.5 h-4 w-4 text-amber-700 dark:text-amber-300" />
              </div>
              <Button
                className="w-full bg-amber-600 hover:bg-amber-700 text-white
                shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[2px]
                dark:bg-amber-500 dark:hover:bg-amber-600
                dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f]"
                onClick={handleUserSearch}
              >
                Search
              </Button>
            </div>

            {/* User Search Results */}
            {showUserSearch && (
              <div className="space-y-2 mt-4">
                <div className="text-sm font-medium text-amber-800 dark:text-amber-200">
                  Search Results
                </div>
                <div className="space-y-2">
                  {userSearchResults.length > 0 ? (
                    userSearchResults.map((user) => (
                      <div
                        key={user.id}
                        className="flex items-center justify-between p-2 rounded-md hover:bg-amber-50/70 dark:hover:bg-slate-700/50 transition-colors border border-transparent hover:border-amber-200/30 dark:hover:border-amber-800/20"
                      >
                        <div className="flex items-center gap-2 min-w-0">
                          <div className="h-8 w-8 rounded-full bg-amber-100 dark:bg-slate-700 flex items-center justify-center text-amber-600 dark:text-amber-400 font-medium flex-shrink-0">
                            {user.name[0].toUpperCase()}
                          </div>
                          <div className="min-w-0">
                            <div className="font-medium text-sm text-amber-800 dark:text-amber-200 truncate">
                              {user.name}
                            </div>
                            <div className="text-xs text-amber-600 dark:text-amber-400">
                              {user.rating}
                            </div>
                          </div>
                        </div>
                        <Button
                          size="sm"
                          className="h-8 px-2 bg-amber-600 hover:bg-amber-700 text-white ml-2 flex-shrink-0
                          shadow-[0_2px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px]
                          dark:bg-amber-500 dark:hover:bg-amber-600
                          dark:shadow-[0_2px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f]"
                        >
                          <UserPlusIcon className="h-4 w-4 mr-1" />
                          Add
                        </Button>
                      </div>
                    ))
                  ) : (
                    <div className="text-center py-4 text-amber-600 dark:text-amber-400">
                      No players found matching your search.
                    </div>
                  )}
                </div>
              </div>
            )}

            <Separator className="my-2 bg-amber-200/30 dark:bg-amber-700/20" />

            {/* Friend Invitations */}
            <div className="space-y-2">
              <div className="text-sm font-medium text-amber-800 dark:text-amber-200 flex justify-between items-center">
                <span>Friend Invitations</span>
                <span className="text-amber-600 dark:text-amber-400">
                  {filteredInvitations.length}
                </span>
              </div>

              {filteredInvitations.length > 0 ? (
                <div className="space-y-2">
                  <div className="relative">
                    <Input
                      type="text"
                      placeholder="Search invitations"
                      value={invitationSearchTerm}
                      onChange={(e) => setInvitationSearchTerm(e.target.value)}
                      className="pl-8 bg-amber-50/80 dark:bg-slate-700/80 border-amber-200 dark:border-slate-600"
                    />
                    <MagnifyingGlassIcon className="absolute left-2.5 top-2.5 h-4 w-4 text-amber-700 dark:text-amber-300" />
                  </div>

                  {filteredInvitations.map((invitation) => (
                    <div
                      key={invitation.id}
                      className="flex items-center justify-between p-2 rounded-md hover:bg-amber-50/70 dark:hover:bg-slate-700/50 transition-colors border border-transparent hover:border-amber-200/30 dark:hover:border-amber-800/20"
                    >
                      <div className="flex items-center gap-2 min-w-0">
                        <div className="h-8 w-8 rounded-full bg-amber-100 dark:bg-slate-700 flex items-center justify-center text-amber-600 dark:text-amber-400 font-medium flex-shrink-0">
                          {invitation.name[0].toUpperCase()}
                        </div>
                        <div className="min-w-0">
                          <div className="font-medium text-sm text-amber-800 dark:text-amber-200 truncate">
                            {invitation.name}
                          </div>
                          <div className="text-xs text-amber-600 dark:text-amber-400">
                            {invitation.rating}
                          </div>
                        </div>
                      </div>
                      <div className="flex gap-1 flex-shrink-0">
                        <button className="h-7 w-7 rounded-full bg-green-100 hover:bg-green-200 dark:bg-green-900/30 dark:hover:bg-green-900/50 text-green-600 dark:text-green-400 flex items-center justify-center">
                          <CheckIcon className="h-4 w-4" />
                        </button>
                        <button className="h-7 w-7 rounded-full bg-red-100 hover:bg-red-200 dark:bg-red-900/30 dark:hover:bg-red-900/50 text-red-600 dark:text-red-400 flex items-center justify-center">
                          <XMarkIcon className="h-4 w-4" />
                        </button>
                      </div>
                    </div>
                  ))}
                </div>
              ) : (
                <div className="text-center py-4 text-amber-600 dark:text-amber-400">
                  No pending invitations.
                </div>
              )}
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
</file>

<file path="web/src/components/GamePane.tsx">
'use client';

import { useState, useEffect, useRef } from 'react';
import { Chess, type Move } from 'chess.js';
import type { Square } from 'chess.js';
import { Button } from '@/components/ui/button';
import { ChessBoard } from '@/components/ChessBoard';
import { Card, CardContent } from '@/components/ui/card';
import {
  ChevronDoubleLeftIcon,
  ChevronDoubleRightIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
} from '@heroicons/react/24/outline';

interface GameProps {
  chess: Chess;
  fen: string;
  lastMove?: [Square, Square];
  selectVisible: boolean;
  pendingMove?: [Square, Square];
  previewIndex: number | null;
  fullHistory: Move[];
  previewFen: string | null;
  onMove: (from: Square, to: Square) => void;
  promotion: (piece: 'q' | 'r' | 'n' | 'b') => void;
  previewMove: (index: number) => void;
  handleFirstMove: () => void;
  handlePrevious: () => void;
  handleNext: () => void;
  handleLastMove: () => void;
}

interface PaneProps {
  playingAs: 'w' | 'b';
  gameProps: GameProps;
}

export default function GamePane({ playingAs, gameProps }: PaneProps) {
  const {
    chess,
    fen,
    lastMove,
    selectVisible,
    previewIndex,
    fullHistory,
    previewFen,
    onMove,
    promotion,
    previewMove,
    handleFirstMove,
    handlePrevious,
    handleNext,
    handleLastMove,
  } = gameProps;

  const [pressedKeys, setPressedKeys] = useState<Set<string>>(new Set());
  const moveListRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (
      moveListRef.current &&
      fullHistory.length > 0 &&
      previewIndex === null
    ) {
      moveListRef.current.scrollTop = moveListRef.current.scrollHeight;
    }
  }, [fullHistory.length, previewIndex]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
        e.preventDefault();

        setPressedKeys((prev) => {
          const updated = new Set(prev);
          updated.add(e.key);
          return updated;
        });

        if (e.key === 'ArrowLeft') {
          handlePrevious();
        } else if (e.key === 'ArrowRight') {
          handleNext();
        } else if (e.key === 'ArrowUp') {
          handleFirstMove();
        } else if (e.key === 'ArrowDown') {
          handleLastMove();
        }
      }
    };

    const handleKeyUp = (e: KeyboardEvent) => {
      if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
        setPressedKeys((prev) => {
          const updated = new Set(prev);
          updated.delete(e.key);
          return updated;
        });
      }
    };

    const handleBlur = () => {
      setPressedKeys(new Set());
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    window.addEventListener('blur', handleBlur);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
      window.removeEventListener('blur', handleBlur);
    };
  }, [handlePrevious, handleNext, handleFirstMove, handleLastMove]);

  const movePairs = [];
  for (let i = 0; i < fullHistory.length; i += 2) {
    const whiteMove = fullHistory[i];
    const blackMove = fullHistory[i + 1];
    movePairs.push({
      moveNumber: Math.floor(i / 2) + 1,
      whiteMove: whiteMove?.san,
      blackMove: blackMove?.san,
      whiteIndex: i + 1,
      blackIndex: i + 2,
    });
  }

  const boardFen = previewFen ? previewFen : fen;
  const gameStatus = getGameStatus(chess);

  return (
    <Card className="w-full bg-white/50 dark:bg-slate-800/50 backdrop-blur-sm border border-amber-200/50 dark:border-amber-800/30 shadow-md rounded-xl overflow-hidden">
      <CardContent className="p-4 md:p-6">
        <div className="md:hidden flex flex-col md:gap-6">
          <Card className="bg-white dark:bg-slate-700 border border-amber-200/50 dark:border-slate-600/50 shadow-none">
            <CardContent className="p-4 text-center">
              <div className="font-medium text-lg text-amber-800 dark:text-amber-200">
                Player A (1600) - Player B (1600)
              </div>
              <div className="text-sm text-amber-600 dark:text-amber-300">
                {gameStatus}
              </div>
            </CardContent>
          </Card>

          <div className="w-full flex items-center justify-center">
            <div className="w-full max-w-lg">
              <ChessBoard
                fen={boardFen}
                onMove={onMove}
                lastMove={lastMove}
                playingAs={playingAs}
                selectVisible={selectVisible}
                promotion={promotion}
                previewIndex={previewIndex}
                chess={chess}
              />
            </div>
          </div>

          <div className="flex justify-center items-center gap-2 my-4">
            <Button
              variant="outline"
              size="sm"
              data-key="ArrowUp"
              className={`w-10 h-10 p-1 bg-amber-600 hover:text-white hover:bg-amber-700 border-none text-white
            shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px]
            dark:bg-amber-500 dark:hover:bg-amber-600
            dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f]
            ${
              pressedKeys.has('ArrowUp') ? 'translate-y-[2px] shadow-none' : ''
            }`}
              onClick={handleFirstMove}
              disabled={fullHistory.length === 0}
              aria-label="First move"
            >
              <ChevronDoubleLeftIcon className="h-5 w-5" />
            </Button>
            <Button
              variant="outline"
              size="sm"
              data-key="ArrowLeft"
              className={`w-10 h-10 p-1 bg-amber-600 hover:text-white hover:bg-amber-700 border-none text-white
            shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px]
            dark:bg-amber-500 dark:hover:bg-amber-600
            dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f]
            ${
              pressedKeys.has('ArrowLeft')
                ? 'translate-y-[2px] shadow-none'
                : ''
            }`}
              onClick={handlePrevious}
              disabled={previewIndex === 0 || fullHistory.length === 0}
              aria-label="Previous move"
            >
              <ChevronLeftIcon className="h-5 w-5" />
            </Button>
            <Button
              variant="outline"
              size="sm"
              data-key="ArrowRight"
              className={`w-10 h-10 p-1 bg-amber-600 hover:text-white hover:bg-amber-700 border-none text-white
            shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px]
            dark:bg-amber-500 dark:hover:bg-amber-600
            dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f]
            ${
              pressedKeys.has('ArrowRight')
                ? 'translate-y-[2px] shadow-none'
                : ''
            }`}
              onClick={handleNext}
              disabled={previewIndex === null || fullHistory.length === 0}
              aria-label="Next move"
            >
              <ChevronRightIcon className="h-5 w-5" />
            </Button>
            <Button
              variant="outline"
              size="sm"
              data-key="ArrowDown"
              className={`w-10 h-10 p-1 bg-amber-600 hover:text-white hover:bg-amber-700 border-none text-white
            shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px]
            dark:bg-amber-500 dark:hover:bg-amber-600
            dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f]
            ${
              pressedKeys.has('ArrowDown')
                ? 'translate-y-[2px] shadow-none'
                : ''
            }`}
              onClick={handleLastMove}
              disabled={previewIndex === null}
              aria-label="Last move"
            >
              <ChevronDoubleRightIcon className="h-5 w-5" />
            </Button>
          </div>

          <div className="bg-amber-50 dark:bg-slate-800 rounded-lg border border-amber-200/50 dark:border-amber-800/30 overflow-hidden shadow-md flex flex-col h-[435px]">
            <div
              ref={moveListRef}
              className="overflow-y-auto flex-grow max-h-[435px] px-4 font-mono text-sm"
            >
              <div className="pt-2" />
              <table className="w-full table-fixed">
                <thead className="text-left text-amber-700 dark:text-amber-300 border-b border-amber-200/50 dark:border-amber-700/30 sticky top-0 bg-amber-50 dark:bg-slate-800">
                  <tr>
                    <th className="w-10 py-2">#</th>
                    <th className="w-1/2 py-2">White</th>
                    <th className="w-1/2 py-2">Black</th>
                  </tr>
                </thead>
                <tbody>
                  {movePairs.length > 0 ? (
                    movePairs.map((move) => (
                      <tr
                        key={move.moveNumber}
                        className="hover:bg-amber-50 hover:text-amber-900 dark:hover:bg-amber-900/20"
                      >
                        <td className="py-1 text-amber-600 dark:text-amber-400">
                          {move.moveNumber}.
                        </td>
                        <td className="py-1">
                          {move.whiteMove && (
                            <button
                              className={`font-semibold text-amber-800 dark:text-amber-200 ${
                                previewIndex === move.whiteIndex
                                  ? 'bg-amber-100 dark:bg-amber-900/30 px-2 py-0.5 rounded'
                                  : 'hover:bg-amber-100/50 dark:hover:bg-amber-900/20 px-2 py-0.5 rounded'
                              }`}
                              onClick={() => previewMove(move.whiteIndex)}
                            >
                              {move.whiteMove}
                            </button>
                          )}
                        </td>
                        <td className="py-1">
                          {move.blackMove && (
                            <button
                              className={`font-semibold text-amber-800 dark:text-amber-200 ${
                                previewIndex === move.blackIndex
                                  ? 'bg-amber-100 dark:bg-amber-900/30 px-2 py-0.5 rounded'
                                  : 'hover:bg-amber-100/50 dark:hover:bg-amber-900/20 px-2 py-0.5 rounded'
                              }`}
                              onClick={() => previewMove(move.blackIndex)}
                            >
                              {move.blackMove}
                            </button>
                          )}
                        </td>
                      </tr>
                    ))
                  ) : (
                    <tr>
                      <td
                        colSpan={3}
                        className="text-center text-amber-500 dark:text-amber-400 py-4"
                      >
                        No moves yet
                      </td>
                    </tr>
                  )}
                </tbody>
              </table>
            </div>
          </div>
        </div>

        <div className="hidden md:flex md:flex-col md:flex-row gap-6">
          <div className="w-full md:w-1/2 flex flex-center items-center justify-center min-h-full">
            <div className="w-full max-w-lg">
              <ChessBoard
                fen={boardFen}
                onMove={onMove}
                lastMove={lastMove}
                playingAs={playingAs}
                selectVisible={selectVisible}
                promotion={promotion}
                previewIndex={previewIndex}
                chess={chess}
              />
            </div>
          </div>

          <div className="w-full md:w-1/2 flex flex-col gap-4">
            <Card className="bg-white dark:bg-slate-700 border border-amber-200/50 dark:border-slate-600/50 shadow-none">
              <CardContent className="p-4 text-center">
                <div className="font-medium text-lg text-amber-800 dark:text-amber-200">
                  Player A (1600) - Player B (1600)
                </div>
                <div className="text-sm text-amber-600 dark:text-amber-300">
                  {gameStatus}
                </div>
              </CardContent>
            </Card>

            <div className="flex-1 bg-amber-50 dark:bg-slate-800 rounded-lg border border-amber-200/50 dark:border-amber-800/30 overflow-hidden shadow-md flex flex-col h-[435px]">
              <div
                ref={moveListRef}
                className="overflow-y-auto flex-grow max-h-[400px] px-4 font-mono text-sm"
              >
                <div className="pt-2" />
                <table className="w-full table-fixed">
                  <thead className="text-left text-amber-700 dark:text-amber-300 border-b border-amber-200/50 dark:border-amber-700/30 sticky top-0 bg-amber-50 dark:bg-slate-800">
                    <tr>
                      <th className="w-10 py-2">#</th>
                      <th className="w-1/2 py-2">White</th>
                      <th className="w-1/2 py-2">Black</th>
                    </tr>
                  </thead>
                  <tbody>
                    {movePairs.length > 0 ? (
                      movePairs.map((move) => (
                        <tr
                          key={move.moveNumber}
                          className="hover:bg-amber-50 hover:text-amber-900 dark:hover:bg-amber-900/20"
                        >
                          <td className="py-1 text-amber-600 dark:text-amber-400">
                            {move.moveNumber}.
                          </td>
                          <td className="py-1">
                            {move.whiteMove && (
                              <button
                                className={`font-semibold text-amber-800 dark:text-amber-200 ${
                                  previewIndex === move.whiteIndex
                                    ? 'bg-amber-100 dark:bg-amber-900/30 px-2 py-0.5 rounded'
                                    : 'hover:bg-amber-100/50 dark:hover:bg-amber-900/20 px-2 py-0.5 rounded'
                                }`}
                                onClick={() => previewMove(move.whiteIndex)}
                              >
                                {move.whiteMove}
                              </button>
                            )}
                          </td>
                          <td className="py-1">
                            {move.blackMove && (
                              <button
                                className={`font-semibold text-amber-800 dark:text-amber-200 ${
                                  previewIndex === move.blackIndex
                                    ? 'bg-amber-100 dark:bg-amber-900/30 px-2 py-0.5 rounded'
                                    : 'hover:bg-amber-100/50 dark:hover:bg-amber-900/20 px-2 py-0.5 rounded'
                                }`}
                                onClick={() => previewMove(move.blackIndex)}
                              >
                                {move.blackMove}
                              </button>
                            )}
                          </td>
                        </tr>
                      ))
                    ) : (
                      <tr>
                        <td
                          colSpan={3}
                          className="text-center text-amber-500 dark:text-amber-400 py-4"
                        >
                          No moves yet
                        </td>
                      </tr>
                    )}
                  </tbody>
                </table>
              </div>

              <div className="border-t border-amber-200/50 dark:border-amber-700/30 mt-auto px-4 py-2">
                <div className="flex justify-center items-center gap-2 my-2">
                  <Button
                    variant="outline"
                    size="sm"
                    data-key="ArrowUp"
                    className={`w-10 h-10 p-1 bg-amber-600 hover:text-white hover:bg-amber-700 border-none text-white
                    shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px]
                    dark:bg-amber-500 dark:hover:bg-amber-600
                    dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f]
                    ${
                      pressedKeys.has('ArrowUp')
                        ? 'translate-y-[2px] shadow-none'
                        : ''
                    }`}
                    onClick={handleFirstMove}
                    disabled={fullHistory.length === 0}
                    aria-label="First move"
                  >
                    <ChevronDoubleLeftIcon className="h-5 w-5" />
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    data-key="ArrowLeft"
                    className={`w-10 h-10 p-1 bg-amber-600 hover:text-white hover:bg-amber-700 border-none text-white
                    shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px]
                    dark:bg-amber-500 dark:hover:bg-amber-600
                    dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f]
                    ${
                      pressedKeys.has('ArrowLeft')
                        ? 'translate-y-[2px] shadow-none'
                        : ''
                    }`}
                    onClick={handlePrevious}
                    disabled={previewIndex === 0 || fullHistory.length === 0}
                    aria-label="Previous move"
                  >
                    <ChevronLeftIcon className="h-5 w-5" />
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    data-key="ArrowRight"
                    className={`w-10 h-10 p-1 bg-amber-600 hover:text-white hover:bg-amber-700 border-none text-white
                    shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px]
                    dark:bg-amber-500 dark:hover:bg-amber-600
                    dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f]
                    ${
                      pressedKeys.has('ArrowRight')
                        ? 'translate-y-[2px] shadow-none'
                        : ''
                    }`}
                    onClick={handleNext}
                    disabled={previewIndex === null || fullHistory.length === 0}
                    aria-label="Next move"
                  >
                    <ChevronRightIcon className="h-5 w-5" />
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    data-key="ArrowDown"
                    className={`w-10 h-10 p-1 bg-amber-600 hover:text-white hover:bg-amber-700 border-none text-white
                    shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px]
                    dark:bg-amber-500 dark:hover:bg-amber-600
                    dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f]
                    ${
                      pressedKeys.has('ArrowDown')
                        ? 'translate-y-[2px] shadow-none'
                        : ''
                    }`}
                    onClick={handleLastMove}
                    disabled={previewIndex === null}
                    aria-label="Last move"
                  >
                    <ChevronDoubleRightIcon className="h-5 w-5" />
                  </Button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

function getGameStatus(chess: Chess): string {
  if (!chess.isGameOver()) return 'On Going';
  if (chess.isCheckmate()) {
    const winner = chess.turn() === 'w' ? 'Black' : 'White';
    return `Completed - ${winner} wins by checkmate`;
  }
  if (chess.isStalemate()) return 'Completed - Stalemate';
  if (chess.isDraw()) return 'Completed - Draw';
  return 'Completed';
}
</file>

<file path="web/src/components/LoadingScreen.tsx">
'use client';

import ChessCloudIcon from './ChessCloud';

export default function LoadingScreen() {
  return (
    <div className="flex flex-col min-h-screen bg-amber-50 dark:bg-slate-900 relative">
      <div
        className="absolute inset-0"
        style={{
          backgroundImage: 'url(/noise.png)',
          backgroundRepeat: 'repeat',
          opacity: 0.025,
        }}
      />
      <div
        className="
          absolute inset-0 pointer-events-none
          [background-image:linear-gradient(90deg,rgba(241,194,125,0.15)_1px,transparent_1px),linear-gradient(180deg,rgba(241,194,125,0.15)_1px,transparent_1px)]
          dark:[background-image:linear-gradient(90deg,rgba(251,191,36,0.2)_1px,transparent_1px),linear-gradient(180deg,rgba(251,191,36,0.2)_1px,transparent_1px)]
          [background-size:20px_20px]
        "
      />
      <div className="flex-1 flex items-center justify-center relative z-10">
        <div className="text-center">
          <ChessCloudIcon className="inline-block w-12 h-12 mb-6" />
          <div className="flex items-center justify-center space-x-2">
            <div
              className="h-2 w-2 bg-amber-600 dark:bg-amber-500 rounded-full animate-bounce"
              style={{ animationDelay: '0ms' }}
            ></div>
            <div
              className="h-2 w-2 bg-amber-600 dark:bg-amber-500 rounded-full animate-bounce"
              style={{ animationDelay: '150ms' }}
            ></div>
            <div
              className="h-2 w-2 bg-amber-600 dark:bg-amber-500 rounded-full animate-bounce"
              style={{ animationDelay: '300ms' }}
            ></div>
          </div>
          <p className="mt-2 text-amber-800 dark:text-amber-200 font-medium">
            Loading ChessClouds<span className="inline-block">...</span>
          </p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="web/src/lib/gameService.ts">
// import prisma from './prisma';

// export const getActiveGames = async () => {
//   return prisma.activegames.findMany();
// };

// export const getActiveGame = async (gameId: string) => {
//   return prisma.activegames.findUnique({
//     where: { gameid: gameId },
//   });
// };

// export const createActiveGame = async (
//   gameId: string,
//   white: string,
//   black: string
// ) => {
//   return prisma.activegames.create({
//     data: { gameid: gameId, white, black },
//   });
// };

// export const deleteActiveGame = async (gameId: string) => {
//   return prisma.activegames.delete({
//     where: { gameid: gameId },
//   });
// };

// export const getGameHistory = async (options?: {
//   gameId?: string;
//   playerId?: string;
//   limit?: number;
//   offset?: number;
// }) => {
//   const { gameId, playerId, limit = 10, offset = 0 } = options || {};

//   /* eslint-disable  @typescript-eslint/no-explicit-any */
//   const whereConditions: any = {};

//   if (gameId) {
//     whereConditions.gameid = gameId;
//   }

//   if (playerId) {
//     whereConditions.OR = [{ white: playerId }, { black: playerId }];
//   }

//   return prisma.gamehistory.findMany({
//     where: whereConditions,
//     orderBy: { createdat: 'desc' },
//     take: limit,
//     skip: offset,
//   });
// };

// export const createGameHistory = async (
//   gameId: string,
//   white: string,
//   black: string,
//   pgn: string
// ) => {
//   return prisma.gamehistory.create({
//     data: { gameid: gameId, white: white, black: black, pgn },
//   });
// };

// export const completeGame = async (gameId: string, pgn: string) => {
//   const game = await prisma.activegames.findUnique({
//     where: { gameid: gameId },
//   });

//   if (!game) {
//     throw new Error('Game not found');
//   }

//   await prisma.gamehistory.create({
//     data: {
//       gameid: game.gameid,
//       white: game.white,
//       black: game.black,
//       pgn,
//     },
//   });

//   return prisma.activegames.delete({
//     where: { gameid: gameId },
//   });
// };
</file>

<file path="web/next.config.ts">
import type { NextConfig } from 'next';

const nextConfig: NextConfig = {
  output: 'standalone'
};

export default nextConfig;
</file>

<file path="web/package.json">
{
  "name": "web",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "format": "prettier --write \"src/**/*.{js,jsx,ts,tsx,css,scss,md}\"",
    "db:generate": "drizzle-kit generate",
    "db:migrate": "drizzle-kit migrate"
  },
  "dependencies": {
    "@heroicons/react": "^2.2.0",
    "@prisma/client": "6.6.0",
    "@prisma/extension-accelerate": "^1.3.0",
    "@radix-ui/react-separator": "^1.1.3",
    "@radix-ui/react-slot": "^1.2.0",
    "chess.js": "^1.2.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "dotenv": "^16.5.0",
    "embla-carousel-react": "^8.6.0",
    "lucide-react": "^0.487.0",
    "next": "15.2.4",
    "next-themes": "^0.4.6",
    "pg": "^8.14.1",
    "react": "^19.1.0",
    "react-chessground": "^1.5.0",
    "react-dom": "^19.1.0",
    "sonner": "^2.0.3",
    "tailwind-merge": "^3.2.0",
    "tw-animate-css": "^1.2.5",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.3.1",
    "@tailwindcss/postcss": "^4.1.4",
    "@types/node": "^20.17.30",
    "@types/pg": "^8.11.13",
    "@types/react": "^19.1.2",
    "@types/react-dom": "^19.1.2",
    "eslint": "^9.24.0",
    "eslint-config-next": "15.2.4",
    "loader-utils": "^1.4.2",
    "prettier": "^2.8.8",
    "prisma": "^6.6.0",
    "tailwindcss": "^4.1.4",
    "tsx": "^4.19.3",
    "typescript": "^5.8.3"
  },
  "prettier": {
    "semi": true,
    "singleQuote": true,
    "tabWidth": 2,
    "trailingComma": "es5"
  }
}
</file>

<file path="ws_server/src/state.rs">
use std::sync::Arc;

use scc::HashMap;
use shakmaty::{Chess, Color};
use sqlx::{Pool, Postgres};
use tokio::sync::broadcast;

use crate::{message::ServerMessage, MAX_CHANNEL_CAPACITY};

pub struct ActiveGame {
    pub white_user_id: String,
    pub black_user_id: String,
    pub white_connected: bool,
    pub black_connected: bool,
    pub clean_up_task: Option<tokio::task::JoinHandle<()>>,
    pub board: Chess,
    pub tx_broadcast: broadcast::Sender<ServerMessage>,
    pub moves: Vec<String>,
}

impl ActiveGame {
    pub fn new(white_user_id: String, black_user_id: String) -> Self {
        let (tx, _) = broadcast::channel(MAX_CHANNEL_CAPACITY);
        ActiveGame {
            white_user_id,
            black_user_id,
            white_connected: false,
            black_connected: false,
            clean_up_task: None,
            board: Chess::default(),
            tx_broadcast: tx,
            moves: Vec::new(),
        }
    }

    pub fn connect(&mut self, color: Color) {
        if let Some(task) = self.clean_up_task.take() {
            tracing::info!("aborting deferred clean up");
            task.abort();
        }
        match color {
            Color::Black => {
                assert!(!self.black_connected);
                self.black_connected = true;
            }
            Color::White => {
                assert!(!self.white_connected);
                self.white_connected = true;
            }
        }
    }

    pub fn disconnect(&mut self, color: Color) {
        match color {
            Color::Black => {
                assert!(self.black_connected);
                self.black_connected = false;
            }
            Color::White => {
                assert!(self.white_connected);
                self.white_connected = false;
            }
        }
    }
}

pub type ActiveGameMap = Arc<HashMap<String, ActiveGame>>;

#[derive(Clone)]
pub struct AppState {
    pub active_games: ActiveGameMap,
    pub pool: Pool<Postgres>,
}
</file>

<file path="web/src/app/signout/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import Link from 'next/link';
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import { Separator } from '@/components/ui/separator';
import { HomeIcon } from '@heroicons/react/24/outline';
import ThemeSwitch from '@/components/ThemeSwitch';
import { signOut } from '@/lib/auth/googleAuth';
import ChessCloudIcon from '@/components/ChessCloud';

export default function SignOut() {
  const [isLoading, setIsLoading] = useState(false);
  const [countdown, setCountdown] = useState(5);
  const [pressedButton, setPressedButton] = useState<string | null>(null);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key.toLowerCase() === 'h') {
        setPressedButton('home');
        setTimeout(() => {
          window.location.href = '/';
        }, 150);
      } else if (e.key.toLowerCase() === 'c') {
        setPressedButton('cancel');
        setTimeout(() => {
          window.location.href = '/home';
        }, 150);
      }
    };

    const handleKeyUp = () => {
      setPressedButton(null);
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  useEffect(() => {
    let timer: NodeJS.Timeout;

    if (isLoading && countdown > 0) {
      timer = setTimeout(() => {
        setCountdown(countdown - 1);
      }, 1000);
    } else if (isLoading && countdown === 0) {
      signOut();
    }

    return () => {
      clearTimeout(timer);
    };
  }, [isLoading, countdown]);

  const handleSignOut = () => {
    setPressedButton('signout');
    setIsLoading(true);
  };

  const handleCancel = () => {
    setPressedButton('cancel');
    setTimeout(() => {
      window.location.href = '/home';
    }, 150);
  };

  return (
    <div className="min-h-screen flex flex-col text-slate-800 dark:text-amber-50 relative overflow-hidden bg-gradient-to-tr from-amber-50 via-amber-100/70 to-amber-200/50 dark:from-slate-800 dark:via-amber-900/20 dark:to-slate-900/90">
      <div
        className="absolute inset-0"
        style={{
          backgroundImage: 'url(/noise.png)',
          backgroundRepeat: 'repeat',
          opacity: 0.025,
        }}
      />
      <div
        className="
          absolute inset-0 pointer-events-none
          [background-image:linear-gradient(90deg,rgba(241,194,125,0.15)_1px,transparent_1px),linear-gradient(180deg,rgba(241,194,125,0.15)_1px,transparent_1px)]
          dark:[background-image:linear-gradient(90deg,rgba(251,191,36,0.2)_1px,transparent_1px),linear-gradient(180deg,rgba(251,191,36,0.2)_1px,transparent_1px)]
          [background-size:20px_20px]
        "
      />

      <div className="absolute top-1/3 left-1/4 w-96 h-96 bg-amber-200/20 dark:bg-amber-500/20 rounded-full blur-3xl"></div>
      <div className="absolute bottom-1/3 right-1/4 w-64 h-64 bg-amber-300/20 dark:bg-amber-600/15 rounded-full blur-3xl"></div>

      <div className="flex-grow flex items-center justify-center p-4 relative z-10">
        <Card className="w-full max-w-md bg-white/70 dark:bg-slate-800/70 backdrop-blur-sm border border-amber-200/50 dark:border-amber-700/40 shadow-xl dark:shadow-amber-900/30">
          <CardHeader className="space-y-1 text-center pb-1 pt-6">
            <div className="flex justify-between items-center mb-6">
              <Button
                variant="outline"
                className="h-9 w-9 p-0 rounded-md border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900
                shadow-[0_4px_0_0_#fcd34d] hover:shadow-[0_2px_0_0_#fcd34d] hover:translate-y-[2px]
                dark:bg-slate-800/70 dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50
                dark:shadow-[0_4px_0_0_#475569] dark:hover:shadow-[0_2px_0_0_#475569]"
                onClick={() => (window.location.href = '/home')}
              >
                <HomeIcon className="h-5 w-5" />
              </Button>

              <ChessCloudIcon className="h-12 w-12" />

              <ThemeSwitch />
            </div>

            <CardTitle className="text-2xl font-bold text-amber-900 dark:text-amber-100 font-display">
              Exit ChessClouds
            </CardTitle>
            <CardDescription className="text-amber-700 dark:text-amber-300">
              Are you sure you <em>really</em> want to sign out?
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4 pt-6">
            <Button
              className={`w-full bg-amber-600 hover:bg-amber-700 text-white px-6 rounded-md transition-all 
              shadow-[0_4px_0_0_#b45309] hover:shadow-[0_2px_0_0_#92400e] hover:translate-y-[2px]
              dark:bg-amber-500 dark:hover:bg-amber-600
              dark:shadow-[0_4px_0_0_#92400e] dark:hover:shadow-[0_2px_0_0_#78350f]
              ${
                pressedButton === 'signout'
                  ? 'transform translate-y-[4px] shadow-none bg-amber-700 dark:bg-amber-600'
                  : ''
              }`}
              disabled={isLoading}
              onClick={handleSignOut}
            >
              {isLoading ? `Signing out in ${countdown}s...` : 'Sign out'}
            </Button>

            <Button
              variant="outline"
              className={`w-full border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900 px-6 rounded-md transition-all 
              shadow-[0_4px_0_0_#fcd34d] hover:shadow-[0_2px_0_0_#fcd34d] hover:translate-y-[2px]
              dark:bg-slate-800/70 dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50
              dark:shadow-[0_4px_0_0_#475569] dark:hover:shadow-[0_2px_0_0_#475569]
              ${
                pressedButton === 'cancel'
                  ? 'transform translate-y-[4px] shadow-none bg-amber-100 dark:bg-slate-800'
                  : ''
              }`}
              disabled={isLoading}
              onClick={handleCancel}
            >
              Cancel
              <span
                className={`ml-1 text-xs px-1 rounded transition-colors ${
                  pressedButton === 'cancel'
                    ? 'bg-amber-200 text-amber-900 dark:bg-slate-700 dark:text-amber-100'
                    : 'bg-amber-100 dark:bg-slate-800'
                }`}
              >
                C
              </span>
            </Button>
          </CardContent>
          <Separator className="my-1 bg-amber-200/30 dark:bg-amber-700/20" />
          <CardFooter className="flex flex-col space-y-4 pt-4">
            <div className="text-center text-sm text-amber-700 dark:text-amber-300">
              Want to stay signed in?{' '}
              <Link
                href="/home"
                className="text-amber-600 hover:text-amber-700 dark:text-amber-400 dark:hover:text-amber-300 font-medium underline underline-offset-4"
              >
                Return to Home
              </Link>
            </div>
          </CardFooter>
        </Card>
      </div>
    </div>
  );
}
</file>

<file path="web/src/app/layout.tsx">
import './globals.css';
import type { Metadata } from 'next';
import { Playfair_Display, Roboto_Mono, Inter } from 'next/font/google';
import ClientLayout from '@/lib/ClientLayout';
import { Toaster } from '@/components/ui/sonner';
import { MatchmakingProvider } from '@/lib/MatchmakingContext';
import { LoadingProvider } from '@/lib/LoadingContext';

const playfair = Playfair_Display({
  subsets: ['latin'],
  display: 'swap',
  variable: '--font-playfair',
});
const robotoMono = Roboto_Mono({
  subsets: ['latin'],
  display: 'swap',
  variable: '--font-roboto-mono',
});
const inter = Inter({
  subsets: ['latin'],
  display: 'swap',
  variable: '--font-inter',
});

export const metadata: Metadata = {
  title: 'ChessClouds',
  description:
    'The next-generation chess platform designed for high-performance gameplay with players worldwide.',
  icons: {
    icon: [
      {
        url: 'icon/chess-cloud-light.ico',
        media: '(prefers-color-scheme: light)',
      },
      {
        url: 'icon/chess-cloud-dark.ico',
        media: '(prefers-color-scheme: dark)',
      },
    ],
  },
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const initThemeScript = `
    (function() {
      function getInitialTheme() {
        const storedTheme = localStorage.getItem('theme');
        if (storedTheme === 'dark' || storedTheme === 'light') {
          return storedTheme;
        }
        return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
      }
      const theme = getInitialTheme();
      document.documentElement.classList.toggle('dark', theme === 'dark');
    })();
  `;

  return (
    <html lang="en" suppressHydrationWarning>
      <head>
        <script dangerouslySetInnerHTML={{ __html: initThemeScript }} />
      </head>
      <body
        className={`${inter.variable} ${playfair.variable} ${robotoMono.variable} font-sans`}
      >
        <div className="min-h-screen relative bg-amber-50 dark:bg-slate-900">
          <div
            className="absolute inset-0 pointer-events-none bg-[url('/noise.png')] bg-repeat"
            style={{ opacity: 0.03 }}
          />
          <div
            className="
              absolute inset-0 pointer-events-none
              [background-image:linear-gradient(90deg,rgba(241,194,125,0.15)_1px,transparent_1px),linear-gradient(180deg,rgba(241,194,125,0.15)_1px,transparent_1px)]
              dark:[background-image:linear-gradient(90deg,rgba(255,191,0,0.15)_1px,transparent_1px),linear-gradient(180deg,rgba(255,191,0,0.15)_1px,transparent_1px)]
              [background-size:20px_20px]
            "
          />
          <MatchmakingProvider>
            <LoadingProvider>
              <ClientLayout>{children}</ClientLayout>
              <Toaster richColors />
            </LoadingProvider>
          </MatchmakingProvider>
        </div>
      </body>
    </html>
  );
}
</file>

<file path="web/src/app/not-found.tsx">
'use client';

import { useState, useEffect } from 'react';
import Link from 'next/link';
import { useRouter } from 'next/navigation';
import { Button } from '@/components/ui/button';
import {
  HomeIcon,
  ArrowPathIcon,
  ChevronRightIcon,
} from '@heroicons/react/24/outline';
import CustomChessBoard from '@/components/DisplayChessBoard';
import { isAuthenticated } from '@/lib/auth/googleAuth';

export default function NotFound() {
  const router = useRouter();
  const [chessAnimation, setChessAnimation] = useState(0);
  const animations = [
    '1. e4 e5 2. Nf3 Nc6 3. d4 exd4 4. Bc4',
    '1. d4 d5 2. c4 e6 3. Nc3 Nf6 4. Bg5',
    '1. e4 c5 2. Nf3 d6 3. d4 cxd4 4. Nxd4 Nf6 5. Nc3',
    '1. e4 e5 2. Nf3 Nc6 3. Bb5 a6 4. Ba4 Nf6 5. O-O Be7 6. Re1 b5 7. Bb3 O-O 8. c3 d5 9. exd5 Nxd5 10. Nxe5 Nxe5 11. Rxe5 c6 12. d4 Bd6 13. Re1 Qh4 14. g3 Qh3',
    '1. d4 Nf6 2. c4 g6 3. Nc3 Bg7 4. e4 d6',
    '1. e4 c6 2. d4 d5 3. Nc3 dxe4 4. Nxe4 Nf6',
  ];

  useEffect(() => {
    const interval = setInterval(() => {
      setChessAnimation((prev) => (prev + 1) % animations.length);
    }, 8000);
    return () => clearInterval(interval);
  }, [animations.length]);

  return (
    <div className="min-h-screen flex items-center justify-center p-4 relative overflow-hidden bg-gradient-to-br from-amber-50 via-amber-100/70 to-amber-200/50 dark:from-slate-800 dark:via-amber-900/20 dark:to-slate-900/90">
      <div
        className="absolute inset-0"
        style={{
          backgroundImage: 'url(/noise.png)',
          backgroundRepeat: 'repeat',
          opacity: 0.025,
        }}
      />
      <div
        className="
          absolute inset-0 pointer-events-none
          [background-image:linear-gradient(90deg,rgba(241,194,125,0.15)_1px,transparent_1px),linear-gradient(180deg,rgba(241,194,125,0.15)_1px,transparent_1px)]
          dark:[background-image:linear-gradient(90deg,rgba(251,191,36,0.2)_1px,transparent_1px),linear-gradient(180deg,rgba(251,191,36,0.2)_1px,transparent_1px)]
          [background-size:20px_20px]
        "
      />

      <div className="absolute top-1/3 left-1/3 w-96 h-96 bg-amber-200/20 dark:bg-amber-500/20 rounded-full blur-3xl"></div>
      <div className="absolute bottom-1/3 right-1/3 w-64 h-64 bg-amber-300/20 dark:bg-amber-600/15 rounded-full blur-3xl"></div>

      <div className="w-full max-w-5xl z-10">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8 items-center">
          <div className="order-2 md:order-1 p-6">
            <div className="mb-2 text-lg text-amber-600 dark:text-amber-400 font-medium">
              Error 404
            </div>
            <h1 className="text-4xl md:text-5xl font-bold text-amber-900 dark:text-amber-100 font-display mb-6">
              Missing Piece
            </h1>
            <p className="text-amber-800 dark:text-amber-200 mb-8">
              The page you&apos;re looking for has moved, been captured, or
              never existed. Like a forgotten chess piece, it&apos;s no longer
              on the board.
            </p>

            <div className="flex flex-col sm:flex-row gap-4">
              <Button
                onClick={() => router.push(isAuthenticated() ? '/home' : '/')}
                className="bg-amber-600 hover:bg-amber-700 text-white px-6 rounded-md 
                shadow-[0_4px_0_0_#b45309] hover:shadow-[0_2px_0_0_#92400e] hover:translate-y-[2px]
                dark:bg-amber-500 dark:hover:bg-amber-600
                dark:shadow-[0_4px_0_0_#92400e] dark:hover:shadow-[0_2px_0_0_#78350f]"
              >
                <HomeIcon className="mr-2 h-5 w-5" />
                Return Home
              </Button>

              <Button
                variant="outline"
                onClick={() => router.back()}
                className="border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900
                shadow-[0_4px_0_0_#fcd34d] hover:shadow-[0_2px_0_0_#fcd34d] hover:translate-y-[2px]
                dark:bg-slate-800/70 dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50
                dark:shadow-[0_4px_0_0_#475569] dark:hover:shadow-[0_2px_0_0_#475569]"
              >
                <ArrowPathIcon className="mr-2 h-5 w-5" />
                Go Back
              </Button>
            </div>

            <div className="mt-12">
              <div className="text-sm text-amber-700 dark:text-amber-300">
                Looking for something specific?
              </div>
              <div className="mt-2 flex gap-6">
                <Link
                  href="/game"
                  className="text-amber-600 hover:text-amber-700 dark:text-amber-400 dark:hover:text-amber-300 flex items-center text-sm"
                >
                  Play Game
                  <ChevronRightIcon className="ml-1 h-4 w-4" />
                </Link>
                <Link
                  href="/home"
                  className="text-amber-600 hover:text-amber-700 dark:text-amber-400 dark:hover:text-amber-300 flex items-center text-sm"
                >
                  Dashboard
                  <ChevronRightIcon className="ml-1 h-4 w-4" />
                </Link>
              </div>
            </div>
          </div>

          <div className="order-1 md:order-2 p-6 flex justify-center">
            <div className="w-full max-w-sm relative">
              <div className="absolute z-1 -top-8 -left-8 md:-top-14 md:-left-14 w-20 h-20 md:w-32 md:h-32 rounded-full bg-white dark:bg-slate-800 shadow-md flex items-center justify-center">
                <div className="text-6xl md:text-8xl font-bold text-amber-300 dark:text-amber-600 font-display">
                  ?
                </div>
              </div>
              <div className="chess-board-container">
                <CustomChessBoard
                  className="shadow-2xl dark:shadow-black/30"
                  pgn={animations[chessAnimation]}
                />
              </div>
              <div className="absolute -bottom-8 -right-8 md:-bottom-12 md:-right-12 w-20 h-20 md:w-32 md:h-32 rounded-full bg-white dark:bg-slate-800 shadow-md flex items-center justify-center">
                <div className="text-6xl md:text-8xl font-bold text-amber-300 dark:text-amber-600 font-display">
                  4
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="web/src/app/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import CustomChessBoard from '@/components/DisplayChessBoard';
import ChessNotations from '@/components/ChessNotations';
import { Button } from '@/components/ui/button';
import {
  ChevronRightIcon,
  PlayIcon,
  DocumentDuplicateIcon,
  BoltIcon,
  SparklesIcon,
  UserGroupIcon,
} from '@heroicons/react/24/outline';
import { toast } from 'sonner';
import { useRouter } from 'next/navigation';
import { useMatchmaking } from '@/lib/MatchmakingContext';
import { getUserInfo, isAuthenticated } from '@/lib/auth/googleAuth';

export default function HomePage() {
  const [pressedKey, setPressedKey] = useState<string | null>(null);
  const router = useRouter();

  const {
    isMatchmaking,
    startMatchmaking,
    cancelMatchmaking,
    playCooldownState,
    cooldownRemaining,
  } = useMatchmaking();

  const userInfo = getUserInfo();
  const username = userInfo?.email?.split('@')[0] || 'anonymous';
  const authenticated = isAuthenticated();

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (pressedKey !== null) return;

      if (e.key.toLowerCase() === 'p') {
        setPressedKey('p');

        handlePlayNow();
      } else if (e.key.toLowerCase() === 's') {
        setPressedKey('s');
        setTimeout(() => {
          router.push('/signup');
          setPressedKey(null);
        }, 150);
      }
    };

    const handleKeyUp = () => {
      if (pressedKey !== null) {
        setTimeout(() => setPressedKey(null), 50);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [router, pressedKey, isMatchmaking, playCooldownState]);

  const handleSignUp = () => {
    setPressedKey('s');
    setTimeout(() => {
      router.push('/signup');
      setPressedKey(null);
    }, 150);
  };

  const handleLearnMore = () => {
    router.push('/learn');
  };

  const handlePlayNow = () => {
    if (pressedKey === 'p') return;

    setPressedKey('p');

    if (playCooldownState === 'cooldown' && !isMatchmaking) {
      toast.info(
        `Please wait ${Math.ceil(
          cooldownRemaining / 1000
        )} seconds before trying again`
      );
      setTimeout(() => setPressedKey(null), 150);
      return;
    }

    if (isMatchmaking) {
      cancelMatchmaking();
      toast.info('Matchmaking canceled');
      setTimeout(() => setPressedKey(null), 150);
      return;
    }

    if (!authenticated) {
      setTimeout(() => {
        router.push('/signin');
        setPressedKey(null);
      }, 150);
      return;
    }

    startMatchmaking(username);
    toast.success('Finding a match...', {
      description: "We'll connect you with an opponent soon",
    });
    setTimeout(() => setPressedKey(null), 150);
  };

  const pgn = '1. e4 e5 2. Nf3 Nc6 3. Bc4 Bc5 4. O-O Nf6 5. d3 d6';

  return (
    <>
      <section className="pt-16 pb-20 md:pt-24 md:pb-28 relative">
        <div className="absolute inset-0 bg-gradient-to-b from-amber-50/70 to-amber-100/50 dark:from-slate-900/70 dark:to-slate-800/50">
          <div
            className="absolute inset-0"
            style={{
              backgroundImage: 'url(/noise.png)',
              backgroundRepeat: 'repeat',
              opacity: 0.025,
            }}
          />
        </div>
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 text-center relative z-10">
          <h1 className="text-4xl sm:text-5xl md:text-6xl font-bold text-amber-900 dark:text-amber-100 max-w-4xl mx-auto leading-tight font-display">
            The definition of modern chess platform
          </h1>
          <p className="mt-6 text-lg text-amber-800 dark:text-amber-200 max-w-2xl mx-auto">
            ChessClouds is a next-generation chess platform designed for
            high-performance gameplay with players worldwide.
          </p>

          <div className="mt-10 flex justify-center space-x-4">
            <Button
              className={`h-12 bg-amber-600 hover:bg-amber-700 text-white px-6 rounded-md transition-all 
              shadow-[0_4px_0_0_#b45309] hover:shadow-[0_2px_0_0_#92400e] hover:translate-y-[2px] 
              dark:bg-amber-500 dark:hover:bg-amber-600
              dark:shadow-[0_4px_0_0_#92400e] dark:hover:shadow-[0_2px_0_0_#78350f]
              ${
                pressedKey === 'p'
                  ? 'transform translate-y-[4px] shadow-none bg-amber-700 dark:bg-amber-600'
                  : ''
              }`}
              onClick={handlePlayNow}
              disabled={playCooldownState === 'cooldown' && !isMatchmaking}
            >
              {isMatchmaking ? (
                <>
                  Finding
                  <span className="inline-flex ml-1">
                    <span
                      className="animate-bounce mx-0.5"
                      style={{ animationDelay: '0ms' }}
                    >
                      .
                    </span>
                    <span
                      className="animate-bounce mx-0.5"
                      style={{ animationDelay: '150ms' }}
                    >
                      .
                    </span>
                    <span
                      className="animate-bounce mx-0.5"
                      style={{ animationDelay: '300ms' }}
                    >
                      .
                    </span>
                  </span>
                  <span
                    className={`ml-1 text-xs px-1 rounded transition-colors ${
                      pressedKey === 'p'
                        ? 'bg-amber-800 dark:bg-amber-700'
                        : 'bg-amber-700 dark:bg-amber-600'
                    }`}
                  >
                    P
                  </span>
                </>
              ) : playCooldownState === 'cooldown' ? (
                <>Wait {Math.ceil(cooldownRemaining / 1000)}s</>
              ) : (
                <>
                  <PlayIcon className="mr-2 h-5 w-5" /> Play now
                  <span
                    className={`ml-1 text-xs px-1 rounded transition-colors ${
                      pressedKey === 'p'
                        ? 'bg-amber-800 dark:bg-amber-700'
                        : 'bg-amber-700 dark:bg-amber-600'
                    }`}
                  >
                    P
                  </span>
                </>
              )}
            </Button>
            <Button
              variant="outline"
              className={`h-12 border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900 px-6 rounded-md transition-all 
              shadow-[0_4px_0_0_#fcd34d] hover:shadow-[0_2px_0_0_#fcd34d] hover:translate-y-[2px]
              dark:bg-slate-800/70 dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50
              dark:shadow-[0_4px_0_0_#475569] dark:hover:shadow-[0_2px_0_0_#475569]
              ${
                pressedKey === 's'
                  ? 'transform translate-y-[4px] shadow-none bg-amber-100 dark:bg-slate-800'
                  : ''
              }`}
              onClick={handleSignUp}
            >
              <DocumentDuplicateIcon className="mr-2 h-5 w-5" /> Sign up
              <span
                className={`ml-1 text-xs px-1 rounded transition-colors ${
                  pressedKey === 's'
                    ? 'bg-amber-200 text-amber-900 dark:bg-slate-700 dark:text-amber-100'
                    : 'bg-amber-100 dark:bg-slate-800'
                }`}
              >
                S
              </span>
            </Button>
          </div>

          <div className="mt-6 flex justify-center items-center text-sm text-amber-700 dark:text-amber-300">
            <span className="flex items-center">
              <svg
                className="h-4 w-4 mr-1.5 text-amber-600 dark:text-amber-400"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M5 13l4 4L19 7"
                />
              </svg>
              Available for Web, iOS, and Android
            </span>
          </div>
        </div>
      </section>

      <section className="py-16 relative">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
            <div className="bg-white/50 dark:bg-slate-800/50 backdrop-blur-sm border border-amber-200/50 dark:border-amber-800/30 p-8 rounded-lg shadow-md hover:shadow-lg transition-all">
              <div className="flex items-center mb-4">
                <div className="h-8 w-8 rounded-full bg-amber-100 dark:bg-amber-700/50 flex items-center justify-center text-amber-600 dark:text-amber-300 mr-3">
                  <BoltIcon className="h-5 w-5" />
                </div>
                <h3 className="text-lg font-medium text-amber-900 dark:text-amber-100">
                  Fast
                </h3>
              </div>
              <p className="text-sm text-amber-800 dark:text-amber-200 leading-relaxed">
                Written from scratch to efficiently leverage multiple CPU cores
                and multiple instances for lightning-fast gameplay performance.
              </p>
            </div>

            <div className="bg-white/50 dark:bg-slate-800/50 backdrop-blur-sm border border-amber-200/50 dark:border-amber-800/30 p-8 rounded-lg shadow-md hover:shadow-lg transition-all">
              <div className="flex items-center mb-4">
                <div className="h-8 w-8 rounded-full bg-amber-100 dark:bg-amber-700/50 flex items-center justify-center text-amber-600 dark:text-amber-300 mr-3">
                  <SparklesIcon className="h-5 w-5" />
                </div>
                <h3 className="text-lg font-medium text-amber-900 dark:text-amber-100">
                  Intelligent
                </h3>
              </div>
              <p className="text-sm text-amber-800 dark:text-amber-200 leading-relaxed">
                Integrate multiple chess engines into your workflow to generate,
                transform, and analyze strategies.
              </p>
            </div>

            <div className="bg-white/50 dark:bg-slate-800/50 backdrop-blur-sm border border-amber-200/50 dark:border-amber-800/30 p-8 rounded-lg shadow-md hover:shadow-lg transition-all">
              <div className="flex items-center mb-4">
                <div className="h-8 w-8 rounded-full bg-amber-100 dark:bg-amber-700/50 flex items-center justify-center text-amber-600 dark:text-amber-300 mr-3">
                  <UserGroupIcon className="h-5 w-5" />
                </div>
                <h3 className="text-lg font-medium text-amber-900 dark:text-amber-100">
                  Collaborative
                </h3>
              </div>
              <p className="text-sm text-amber-800 dark:text-amber-200 leading-relaxed">
                Collaborate gameing experiecne together, and share your
                strategies and projects. All included.
              </p>
            </div>
          </div>
        </div>
      </section>

      <section className="py-16 relative">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <h2 className="text-3xl font-bold text-amber-900 dark:text-amber-100 font-display text-center mb-8">
            Experience Chess in a New Way
          </h2>
          <div className="bg-amber-50 dark:bg-slate-800 backdrop-blur-sm border border-amber-200/40 dark:border-amber-800/30 p-8 rounded-lg shadow-lg relative overflow-hidden">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
              <div className="order-2 md:order-1">
                <h2 className="text-2xl font-bold text-amber-900 dark:text-amber-100 mb-4 font-display">
                  Ready for your next move?
                </h2>
                <p className="text-amber-800 dark:text-amber-200 mb-6">
                  Join thousands of players already experiencing the next
                  generation of online chess. Get started today and elevate your
                  game.
                </p>
                <div className="flex flex-col sm:flex-row gap-4 mb-6">
                  <Button
                    className={`bg-amber-600 hover:bg-amber-700 text-white transition-all 
                    shadow-[0_4px_0_0_#b45309] hover:shadow-[0_2px_0_0_#92400e] hover:translate-y-[2px]
                    dark:bg-amber-500 dark:hover:bg-amber-600
                    dark:shadow-[0_4px_0_0_#92400e] dark:hover:shadow-[0_2px_0_0_#78350f]
                    ${
                      pressedKey === 's'
                        ? 'transform translate-y-[4px] shadow-none bg-amber-700 dark:bg-amber-600'
                        : ''
                    }`}
                    onClick={handleSignUp}
                  >
                    Sign up free
                    <ChevronRightIcon className="ml-2 h-4 w-4" />
                    <span
                      className={`ml-1 text-xs px-1 rounded transition-colors ${
                        pressedKey === 's'
                          ? 'bg-amber-800 dark:bg-amber-700'
                          : 'bg-amber-700 dark:bg-amber-600'
                      }`}
                    >
                      S
                    </span>
                  </Button>
                  <Button
                    variant="outline"
                    className="border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900
                    shadow-[0_4px_0_0_#fcd34d] hover:shadow-[0_2px_0_0_#fcd34d] hover:translate-y-[2px]
                    dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-700/50
                    dark:shadow-[0_4px_0_0_#475569] dark:hover:shadow-[0_2px_0_0_#475569]"
                    onClick={handleLearnMore}
                  >
                    Learn more
                  </Button>
                </div>

                <div className="hidden md:block">
                  <ChessNotations pgn={pgn} />
                </div>
              </div>
              <div className="relative flex items-center justify-center order-1 md:order-2">
                <div className="w-full">
                  <CustomChessBoard
                    className="shadow-xl dark:shadow-amber-900/20"
                    pgn={pgn}
                  />
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>
    </>
  );
}
</file>

<file path="web/src/lib/matchmakingService.ts">
import { Color } from '@/types/shared';

export type MatchRequest = {
  user_id: string;
};

export type MatchResponse =
  | { result: 'Ok'; value: { game_id: string; color: Color } }
  | { result: 'Err'; value: string };

let matchmakingInstance: MatchMakingService | null = null;

export class MatchMakingService {
  private severUrl: string;
  private requestInProgresss: boolean = false;
  private abortController: AbortController | null = null;
  private timeoutId: NodeJS.Timeout | null = null;

  constructor(serverUrl?: string) {
    this.severUrl =
      serverUrl ||
      process.env.NEXT_PUBLIC_MATCHMAKING_SERVER_URL ||
      'http://localhost:8001';
  }

  static getInstance(serverUrl?: string): MatchMakingService {
    if (!matchmakingInstance) {
      matchmakingInstance = new MatchMakingService(serverUrl);
    }
    return matchmakingInstance;
  }

  static resetInstace(): void {
    matchmakingInstance = null;
  }

  async findMatch(
    user_id: string
  ): Promise<{ game_id: string; color: 'w' | 'b' }> {
    if (this.requestInProgresss) {
      throw new Error('Matching is already in progress');
    }

    this.requestInProgresss = true;
    this.abortController = new AbortController();
    const signal = this.abortController.signal;

    // Add a request timeout
    const REQUEST_TIMEOUT = 15000; // 15 seconds
    this.timeoutId = setTimeout(() => {
      if (this.abortController) {
        this.abortController.abort();
      }
    }, REQUEST_TIMEOUT);

    try {
      const response = await fetch(`${this.severUrl}/match`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ user_id: user_id }),
        signal,
      });

      // Clear the timeout since we got a response
      if (this.timeoutId) {
        clearTimeout(this.timeoutId);
        this.timeoutId = null;
      }

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Server error: ${errorText || response.status}`);
      }

      const matchResponse = (await response.json()) as MatchResponse;

      if (matchResponse.result === 'Err') {
        throw new Error(`Failed to find match: ${matchResponse.value}`);
      }

      const { game_id, color } = matchResponse.value;
      return {
        game_id,
        color: color === 'White' ? 'w' : 'b',
      };
    } catch (error) {
      // Clear the timeout if there was an error
      if (this.timeoutId) {
        clearTimeout(this.timeoutId);
        this.timeoutId = null;
      }

      if (error instanceof DOMException && error.name === 'AbortError') {
        console.log('Match finding aborted');
        throw new Error('Match finding was canceled or timed out');
      }
      console.error('Matchmaking error:', error);
      throw error;
    } finally {
      this.requestInProgresss = false;
      this.abortController = null;
    }
  }

  cancelMatch(): void {
    if (this.abortController) {
      this.abortController.abort();
      this.requestInProgresss = false;
      this.abortController = null;
    }

    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
  }
}
</file>

<file path="web/src/types/socket-types.ts">
export type Color = 'Black' | 'White';
export type GameOutcome =
  | { type: 'Decisive'; winner: 'w' | 'b' }
  | { type: 'Draw' }
  | { type: 'Ongoing' };
export type ErrorType =
  | 'Deserialization'
  | 'Unauthorized'
  | 'InvalidTurn'
  | 'InvalidMove';
export type ClientMessage =
  | { kind: 'Auth'; value: { game_id: string; user_id: string } }
  | { kind: 'Move'; value: string };
export type ServerMessage =
  | { kind: 'Move'; value: string }
  | { kind: 'GameEnd'; value: GameOutcome }
  | { kind: 'Error'; value: ErrorType }
  | { kind: 'AuthSuccess' }
  | { kind: 'MoveHistory'; value: string[] };
</file>

<file path="ws_server/src/lib.rs">
pub mod message;
pub mod route;
pub mod state;

pub const MAX_CHANNEL_CAPACITY: usize = 64;
pub const HOST: &'static str = "0.0.0.0:8000";
pub const MAX_DB_CONNECTIONS: u32 = 5;
pub const DEFERRED_CLEAN_UP_DURATION: u64 = 60;
</file>

<file path="matchmaking/Cargo.toml">
[package]
name = "matchmaking"
version = "0.1.0"
edition = "2021"

[dependencies]
anyhow = "1.0.98"
axum = { version = "0.8.3", features = ["ws"] }
axum-macros = "0.5.0"
dotenvy = "0.15.7"
serde = { version = "1.0.219", features = ["derive"] }
serde_json = "1.0.140"
sqlx = { version = "0.8.5", features = ["macros", "postgres", "runtime-tokio", "tls-native-tls", "uuid"] }
tokio = { version = "1.44.1", features = ["full"] }
tracing = "0.1.41"
tracing-subscriber = "0.3.19"
ts-rs = "10.1.0"
uuid = { version = "1.16.0", features = ["v4"] }
tower-http = { version = "0.5.2", features = ["cors"] }
</file>

<file path="web/src/app/debug/page.tsx">
'use client';

import { useState, useEffect, useRef } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import {
  ChevronRightIcon,
  SignalIcon,
  SignalSlashIcon,
  ClipboardIcon,
} from '@heroicons/react/24/outline';
import { toast } from 'sonner';
import { MatchMakingService } from '@/lib/matchmakingService';

export type Color = 'Black' | 'White';
export type GameOutcome = { Decisive: { winner: Color } } | 'Draw';
export type ErrorType =
  | 'Deserialization'
  | 'Unauthorized'
  | 'InvalidTurn'
  | 'InvalidMove';
export type ClientMessage =
  | { kind: 'Auth'; value: { game_id: string; user_id: string } }
  | { kind: 'Move'; value: string };
export type ServerMessage =
  | { kind: 'Move'; value: string }
  | { kind: 'GameEnd'; value: GameOutcome }
  | { kind: 'Error'; value: ErrorType }
  | { kind: 'AuthSuccess' }
  | { kind: 'MoveHistory'; value: string[] };

export default function DevPage() {
  const [host, setHost] = useState('localhost');
  const [port, setPort] = useState('8000');
  const [socket, setSocket] = useState<WebSocket | null>(null);
  const [connected, setConnected] = useState(false);
  const [authenticated, setAuthenticated] = useState(false);
  const [messages, setMessages] = useState<string[]>([]);
  const [gameId, setGameId] = useState('test');
  const [userId, setUserId] = useState('white');
  const [moveToSend, setMoveToSend] = useState('e4');
  const [copySuccess, setCopySuccess] = useState(false);
  const logRef = useRef<HTMLDivElement>(null);

  const [isMatchmaking, setIsMatchmaking] = useState(false);
  const [matchmakingError, setMatchmakingError] = useState<string | null>(null);

  const logMessage = (message: string) => {
    setMessages((prev) => [
      ...prev,
      `${new Date().toLocaleTimeString()}: ${message}`,
    ]);

    setTimeout(() => {
      if (logRef.current) {
        logRef.current.scrollTop = logRef.current.scrollHeight;
      }
    }, 50);
  };

  const connectWebSocket = () => {
    try {
      const serverUrl = `ws://${host}:${port}/ws`;
      logMessage(`Connecting to WebSocket at ${serverUrl}`);

      const ws = new WebSocket(serverUrl);
      setSocket(ws);

      ws.addEventListener('open', () => {
        setConnected(true);
        logMessage('WebSocket connection established');
      });

      ws.addEventListener('message', (event) => {
        try {
          const data = JSON.parse(event.data) as ServerMessage;
          logMessage(`Received: ${JSON.stringify(data)}`);

          if (data.kind === 'AuthSuccess') {
            setAuthenticated(true);
            logMessage('Authentication successful');
          } else if (data.kind === 'Error') {
            logMessage(`Error: ${data.value}`);
          } else if (data.kind === 'MoveHistory') {
            logMessage(`Move history: ${data.value.join(', ')}`);
          } else if (data.kind === 'Move') {
            logMessage(`Move: ${data.value}`);
          } else if (data.kind === 'GameEnd') {
            logMessage(`Game ended: ${JSON.stringify(data.value)}`);
          }
        } catch (error) {
          logMessage(`Raw message received: ${event.data}`);
          logMessage(`Error parsing message: ${error}`);
        }
      });

      ws.addEventListener('error', (error) => {
        logMessage(`WebSocket error: ${error}`);
      });

      ws.addEventListener('close', (event) => {
        setConnected(false);
        setAuthenticated(false);
        logMessage(`WebSocket closed: ${event.code} ${event.reason}`);
      });

      return ws;
    } catch (error) {
      logMessage(`Error creating WebSocket: ${error}`);
      return null;
    }
  };

  const initializeGame = async () => {
    try {
      logMessage(`Initializing game ${gameId} with white: white, black: black`);

      const initBody = {
        game_id: gameId,
        white_user_id: 'white',
        black_user_id: 'black',
      };

      const response = await fetch(`http://${host}:${port}/init`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json',
        },
        body: JSON.stringify(initBody),
      });

      if (response.ok) {
        logMessage('Game initialized successfully');
        toast.success('Game initialized successfully', {
          description: 'Ready to connect and play!',
        });
        return true;
      } else {
        const text = await response.text();
        if (text === 'Game already exists') {
          logMessage('Game already exists, ready to connect');
          toast.info('Game already exists', {
            description: 'You can connect to this existing game',
          });
          return true;
        } else {
          logMessage(`Game initialization failed: ${response.status} ${text}`);
          toast.error('Game initialization failed', {
            description: text,
          });
          return false;
        }
      }
    } catch (error) {
      logMessage(`Error initializing game: ${error}`);
      toast.error('Error initializing game', {
        description: String(error),
      });
      return false;
    }
  };

  const authenticate = () => {
    if (!socket || socket.readyState !== WebSocket.OPEN) {
      logMessage('Cannot authenticate: WebSocket not connected');
      return;
    }

    try {
      const authMsg: ClientMessage = {
        kind: 'Auth',
        value: {
          game_id: gameId,
          user_id: userId,
        },
      };

      logMessage(`Sending auth: ${JSON.stringify(authMsg)}`);
      socket.send(JSON.stringify(authMsg));
    } catch (error) {
      logMessage(`Error sending auth: ${error}`);
    }
  };

  const sendMove = () => {
    if (!socket || socket.readyState !== WebSocket.OPEN) {
      logMessage('Cannot send move: WebSocket not connected');
      return;
    }

    if (!authenticated) {
      logMessage('Cannot send move: Not authenticated');
      return;
    }

    try {
      const moveMsg: ClientMessage = {
        kind: 'Move',
        value: moveToSend,
      };

      logMessage(`Sending move: ${JSON.stringify(moveMsg)}`);
      socket.send(JSON.stringify(moveMsg));
    } catch (error) {
      logMessage(`Error sending move: ${error}`);
    }
  };

  const copyGameLink = () => {
    const playas = userId === 'white' ? 'b' : 'w';
    const url = `${window.location.origin}/socket?game_id=${gameId}&playas=${playas}`;

    navigator.clipboard
      .writeText(url)
      .then(() => {
        setCopySuccess(true);
        setTimeout(() => setCopySuccess(false), 2000);
        toast.success('Game link copied!', {
          description: 'Share this with your opponent',
        });
      })
      .catch((err) => {
        toast.error('Failed to copy', {
          description: String(err),
        });
      });
  };

  useEffect(() => {
    return () => {
      if (socket) {
        socket.close();
      }
    };
  }, [socket]);

  const findMatch = async () => {
    try {
      setIsMatchmaking(true);
      setMatchmakingError(null);
      logMessage(`Starting matchmaking for user: ${userId}`);

      const matchmakingService = MatchMakingService.getInstance();
      const { game_id, color } = await matchmakingService.findMatch(userId);

      setGameId(game_id);
      logMessage(`Match found! Game ID: ${game_id}, Playing as: ${color}`);
      toast.success('Match found!', {
        description: `Game ID: ${game_id}, Playing as: ${color}`,
      });

      // Optional: Auto-connect to game
      // window.location.href = `/socket?game_id=${game_id}&playas=${color}`;
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Unknown error';
      setMatchmakingError(errorMsg);
      logMessage(`Matchmaking error: ${errorMsg}`);
      toast.error('Matchmaking failed', { description: errorMsg });
    } finally {
      setIsMatchmaking(false);
    }
  };

  const cancelMatchmaking = () => {
    const matchmakingService = MatchMakingService.getInstance();
    matchmakingService.cancelMatch();
    setIsMatchmaking(false);
    logMessage('Matchmaking canceled');
  };

  return (
    <div className="container mx-auto py-8 px-4">
      <h1 className="text-2xl font-bold mb-6 text-amber-900 dark:text-amber-100 font-display">
        Chess Game Setup
      </h1>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <Card className="bg-white/50 dark:bg-slate-800/50 backdrop-blur-sm border border-amber-200/50 dark:border-amber-800/30 shadow-md">
          <CardHeader className="pb-3">
            <CardTitle className="text-xl text-amber-900 dark:text-amber-100">
              Game Settings
            </CardTitle>
          </CardHeader>
          <CardContent className="p-6 space-y-5">
            <div className="flex gap-4">
              <div className="flex-1">
                <label className="block text-sm mb-1 text-amber-700 dark:text-amber-300">
                  Server Host
                </label>
                <input
                  type="text"
                  value={host}
                  onChange={(e) => setHost(e.target.value)}
                  className="w-full p-2 border rounded bg-amber-50/80 dark:bg-slate-700/80 border-amber-200 dark:border-slate-600 focus:outline-none focus:ring-2 focus:ring-amber-500"
                  placeholder="localhost"
                />
              </div>
              <div className="w-1/3">
                <label className="block text-sm mb-1 text-amber-700 dark:text-amber-300">
                  Port
                </label>
                <input
                  type="text"
                  value={port}
                  onChange={(e) => setPort(e.target.value)}
                  className="w-full p-2 border rounded bg-amber-50/80 dark:bg-slate-700/80 border-amber-200 dark:border-slate-600 focus:outline-none focus:ring-2 focus:ring-amber-500"
                  placeholder="8000"
                />
              </div>
            </div>

            <div>
              <label className="block text-sm mb-1 text-amber-700 dark:text-amber-300">
                Game ID
              </label>
              <div className="flex gap-2">
                <input
                  type="text"
                  value={gameId}
                  onChange={(e) => setGameId(e.target.value)}
                  className="w-full p-2 border rounded bg-amber-50/80 dark:bg-slate-700/80 border-amber-200 dark:border-slate-600 focus:outline-none focus:ring-2 focus:ring-amber-500"
                />
                <Button
                  onClick={initializeGame}
                  className="bg-amber-600 hover:bg-amber-700 text-white shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[2px]
                   dark:bg-amber-500 dark:hover:bg-amber-600 dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f]"
                >
                  Initialize
                  <ChevronRightIcon className="ml-1 h-4 w-4" />
                </Button>
              </div>
            </div>

            <div>
              <label className="block text-sm mb-1 text-amber-700 dark:text-amber-300">
                User ID
              </label>
              <select
                value={userId}
                onChange={(e) => setUserId(e.target.value)}
                className="w-full p-2 border rounded bg-amber-50/80 dark:bg-slate-700/80 border-amber-200 dark:border-slate-600 focus:outline-none focus:ring-2 focus:ring-amber-500"
              >
                <option value="white">white</option>
                <option value="black">black</option>
              </select>
            </div>

            <div className="flex gap-2">
              <Button
                onClick={connectWebSocket}
                disabled={connected}
                className="flex-1 bg-amber-600 hover:bg-amber-700 text-white shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[2px]
                 dark:bg-amber-500 dark:hover:bg-amber-600 dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f] disabled:opacity-50 disabled:shadow-none"
              >
                Connect WebSocket
              </Button>

              <Button
                onClick={authenticate}
                disabled={!connected || authenticated}
                className="flex-1 border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900 shadow-[0_3px_0_0_#fcd34d] hover:shadow-[0_1px_0_0_#fcd34d] hover:translate-y-[2px]
                dark:bg-slate-800/70 dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50 dark:shadow-[0_3px_0_0_#475569] dark:hover:shadow-[0_1px_0_0_#475569] disabled:opacity-50 disabled:shadow-none"
                variant="outline"
              >
                Authenticate
              </Button>
            </div>

            <div className="flex gap-2">
              {isMatchmaking ? (
                <Button
                  onClick={cancelMatchmaking}
                  className="flex-1 bg-red-600 hover:bg-red-700 text-white shadow-[0_3px_0_0_#b91c1c] hover:shadow-[0_1px_0_0_#991b1b] hover:translate-y-[2px]
                    dark:bg-red-500 dark:hover:bg-red-600 dark:shadow-[0_3px_0_0_#991b1b] dark:hover:shadow-[0_1px_0_0_#7f1d1d]"
                >
                  Cancel Matchmaking
                </Button>
              ) : (
                <Button
                  onClick={findMatch}
                  className="flex-1 bg-amber-600 hover:bg-amber-700 text-white shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[2px]
                    dark:bg-amber-500 dark:hover:bg-amber-600 dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f]"
                >
                  Find Match
                </Button>
              )}
            </div>

            {matchmakingError && (
              <div className="mt-2 text-red-600 dark:text-red-400 text-sm">
                {matchmakingError}
              </div>
            )}

            <div>
              <label className="block text-sm mb-1 text-amber-700 dark:text-amber-300">
                Move (e.g., e4)
              </label>
              <div className="flex gap-2">
                <input
                  type="text"
                  value={moveToSend}
                  onChange={(e) => setMoveToSend(e.target.value)}
                  className="w-full p-2 border rounded bg-amber-50/80 dark:bg-slate-700/80 border-amber-200 dark:border-slate-600 focus:outline-none focus:ring-2 focus:ring-amber-500"
                />
                <Button
                  onClick={sendMove}
                  disabled={!authenticated}
                  className="bg-amber-600 hover:bg-amber-700 text-white shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[2px]
                   dark:bg-amber-500 dark:hover:bg-amber-600 dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f] disabled:opacity-50 disabled:shadow-none"
                >
                  Send Move
                  <ChevronRightIcon className="ml-1 h-4 w-4" />
                </Button>
              </div>
            </div>

            <div className="flex flex-col gap-2 pt-2">
              <div className="flex gap-4 items-center">
                <div className="flex gap-2 items-center">
                  <Badge
                    className={`${
                      connected ? 'bg-green-600' : 'bg-red-600'
                    } text-white w-6 h-6 flex items-center justify-center p-0`}
                  >
                    {connected ? (
                      <SignalIcon className="h-4 w-4" />
                    ) : (
                      <SignalSlashIcon className="h-4 w-4" />
                    )}
                  </Badge>
                  <span className="text-sm text-amber-700 dark:text-amber-300">
                    {connected ? 'Connected' : 'Disconnected'}
                  </span>
                </div>

                <div className="flex gap-2 items-center ml-4">
                  <Badge
                    className={`${
                      authenticated ? 'bg-green-600' : 'bg-red-600'
                    } text-white w-6 h-6 flex items-center justify-center p-0`}
                  >
                    {authenticated ? (
                      <svg
                        xmlns="http://www.w3.org/2000/svg"
                        fill="none"
                        viewBox="0 0 24 24"
                        stroke="currentColor"
                        className="h-4 w-4"
                      >
                        <path
                          strokeLinecap="round"
                          strokeLinejoin="round"
                          strokeWidth={2}
                          d="M5 13l4 4L19 7"
                        />
                      </svg>
                    ) : (
                      <svg
                        xmlns="http://www.w3.org/2000/svg"
                        fill="none"
                        viewBox="0 0 24 24"
                        stroke="currentColor"
                        className="h-4 w-4"
                      >
                        <path
                          strokeLinecap="round"
                          strokeLinejoin="round"
                          strokeWidth={2}
                          d="M6 18L18 6M6 6l12 12"
                        />
                      </svg>
                    )}
                  </Badge>
                  <span className="text-sm text-amber-700 dark:text-amber-300">
                    {authenticated ? 'Authenticated' : 'Not Authenticated'}
                  </span>
                </div>
              </div>

              <Button
                onClick={copyGameLink}
                className="bg-amber-600 hover:bg-amber-700 text-white shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[2px]
                dark:bg-amber-500 dark:hover:bg-amber-600 dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f]"
              >
                {copySuccess ? 'Copied!' : 'Copy Game Link for Opponent'}
                <ClipboardIcon className="ml-2 h-4 w-4" />
              </Button>

              <a
                href={`/socket?game_id=${gameId}&playas=${
                  userId === 'white' ? 'w' : 'b'
                }`}
                target="_blank"
                className="text-center p-2 border border-amber-300 dark:border-amber-700 rounded-md text-amber-700 dark:text-amber-300 hover:bg-amber-50 dark:hover:bg-slate-700"
              >
                Open Game in This Browser
              </a>
            </div>
          </CardContent>
        </Card>

        <Card className="bg-white/50 dark:bg-slate-800/50 backdrop-blur-sm border border-amber-200/50 dark:border-amber-800/30 shadow-md">
          <CardHeader className="pb-3 flex flex-row justify-between items-center">
            <CardTitle className="text-xl text-amber-900 dark:text-amber-100">
              Message Log
            </CardTitle>
            <Button
              onClick={() => setMessages([])}
              size="sm"
              variant="outline"
              className="h-8 border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900 shadow-[0_2px_0_0_#fcd34d] hover:shadow-[0_1px_0_0_#fcd34d] hover:translate-y-[1px]
                dark:bg-slate-800/70 dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50 dark:shadow-[0_2px_0_0_#475569] dark:hover:shadow-[0_1px_0_0_#475569]"
            >
              Clear Log
            </Button>
          </CardHeader>
          <CardContent className="p-6">
            <div
              ref={logRef}
              className="bg-amber-50/80 dark:bg-slate-700/80 border border-amber-200/50 dark:border-slate-600/50 rounded-lg p-3 h-[400px] overflow-y-auto font-mono text-sm"
            >
              {messages.length === 0 ? (
                <div className="text-center text-amber-600 dark:text-amber-400 py-4">
                  No messages yet
                </div>
              ) : (
                messages.map((msg, i) => (
                  <div
                    key={i}
                    className="py-1 border-b border-amber-100/50 dark:border-slate-600/50 text-xs"
                  >
                    {msg}
                  </div>
                ))
              )}
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
</file>

<file path="web/src/components/dashboard/Overview.tsx">
'use client';

import { getUserHistoryGames } from '@/app/actions/gameActions';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { getLastTime } from '@/lib/time';
import { DashboardTabProps } from '@/types/dashboard-props';
import { useEffect, useState } from 'react';
import { toast } from 'sonner';
import LoadingScreen from '../LoadingScreen';

const HISTORY_LIMIT = 10;
// const FRIEND_PER_PAGE = 5;

export default function OverviewTab({
  setActiveTab,
  username,
}: DashboardTabProps) {
  const handleViewGames = () => {
    setActiveTab('games');
  };

  // const handleViewFriends = () => {
  //   setActiveTab('friends');
  // };

  // const getStatusColor = (status: string) => {
  //   switch (status) {
  //     case 'online':
  //       return 'bg-green-600';
  //     case 'playing':
  //       return 'bg-amber-600';
  //     case 'offline':
  //       return 'bg-slate-400';
  //     default:
  //       return 'bg-slate-400';
  //   }
  // };

  const [gameHistory, setGameHistory] = useState<
    Awaited<ReturnType<typeof getUserHistoryGames>>['games']
  >([]);
  const [loadingGameHistory, setLoadingGameHistory] = useState(true);

  useEffect(() => {
    const fetchGameHistory = async () => {
      try {
        setLoadingGameHistory(true);
        const { success, games = [] } = await getUserHistoryGames(username);
        if (success) {
          setGameHistory(games);
        } else {
          toast.error('Failed to load game history');
        }
      } catch (err) {
        console.error(err);
        toast.error('Error loading game history');
      } finally {
        setLoadingGameHistory(false);
      }
    };

    if (username) fetchGameHistory();
  }, [username]);

  if (loadingGameHistory) {
    return <LoadingScreen />;
  }

  return (
    <>
      {/* Player Stats Row */}
      <Card className="w-full bg-white/50 dark:bg-slate-800/50 backdrop-blur-sm border border-amber-200/50 dark:border-amber-800/30 shadow-md mb-6">
        <CardHeader>
          <CardTitle className="text-lg font-semibold text-amber-900 dark:text-amber-100">
            Player Stats
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-2 sm:grid-cols-4 gap-4 sm:gap-6">
            <div className="flex flex-col items-center bg-amber-50/80 dark:bg-slate-700/50 p-4 rounded-lg border border-amber-200/40 dark:border-amber-800/20">
              <div className="text-2xl sm:text-3xl font-bold text-amber-900 dark:text-amber-100">
                {gameHistory === undefined
                  ? 500
                  : Math.max(
                      100,
                      500 -
                        gameHistory.filter(
                          (g) =>
                            (g.status === 'WHITE_WINS' &&
                              g.black === username) ||
                            (g.status === 'BLACK_WINS' && g.white === username)
                        ).length *
                          10 +
                        gameHistory.filter(
                          (g) =>
                            (g.status === 'WHITE_WINS' &&
                              g.white === username) ||
                            (g.status === 'BLACK_WINS' && g.black === username)
                        ).length *
                          10
                    )}
              </div>
              <div className="text-sm text-amber-700 dark:text-amber-300">
                Rating
              </div>
            </div>

            <div className="flex flex-col items-center bg-amber-50/80 dark:bg-slate-700/50 p-4 rounded-lg border border-amber-200/40 dark:border-amber-800/20">
              <div className="text-2xl sm:text-3xl font-bold text-amber-900 dark:text-amber-100">
                {gameHistory?.length ?? 0}
              </div>
              <div className="text-sm text-amber-700 dark:text-amber-300">
                Games Played
              </div>
            </div>

            <div className="flex flex-col items-center bg-amber-50/80 dark:bg-slate-700/50 p-4 rounded-lg border border-amber-200/40 dark:border-amber-800/20">
              <div className="text-2xl sm:text-3xl font-bold text-amber-900 dark:text-amber-100">
                {gameHistory === undefined
                  ? 0
                  : gameHistory.length
                  ? Math.round(
                      (100 *
                        gameHistory.filter(
                          (g) =>
                            (g.status === 'WHITE_WINS' &&
                              g.white === username) ||
                            (g.status === 'BLACK_WINS' && g.black === username)
                        ).length) /
                        gameHistory.length
                    )
                  : 0}
                %
              </div>
              <div className="text-sm text-amber-700 dark:text-amber-300">
                Win Rate
              </div>
            </div>

            <div className="flex flex-col items-center bg-amber-50/80 dark:bg-slate-700/50 p-4 rounded-lg border border-amber-200/40 dark:border-amber-800/20">
              <div className="text-2xl sm:text-3xl font-bold text-amber-900 dark:text-amber-100">
                {gameHistory === undefined
                  ? 0
                  : ((i) => (i === -1 ? gameHistory.length : i))(
                      gameHistory.findIndex(
                        (g) =>
                          !(
                            (g.status === 'WHITE_WINS' &&
                              g.white === username) ||
                            (g.status === 'BLACK_WINS' && g.black === username)
                          )
                      )
                    )}
              </div>
              <div className="text-sm text-amber-700 dark:text-amber-300">
                Current Streak
              </div>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Content area - separate divs instead of grid */}
      <div className="w-full flex flex-col xl:flex-row gap-6">
        {/* Recent Games */}
        <div className="w-full xl:flex-1">
          <Card className="w-full bg-white/50 dark:bg-slate-800/50 backdrop-blur-sm border border-amber-200/50 dark:border-amber-800/30 shadow-md">
            <CardHeader className="flex flex-row items-center justify-between pb-2">
              <CardTitle className="text-lg font-semibold text-amber-900 dark:text-amber-100">
                Recent Games
              </CardTitle>
              <Button
                variant="outline"
                size="sm"
                className="h-8 border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900
                  shadow-[0_2px_0_0_#fcd34d] hover:shadow-[0_1px_0_0_#fcd34d] hover:translate-y-[1px]
                  dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50
                  dark:shadow-[0_2px_0_0_#475569] dark:hover:shadow-[0_1px_0_0_#475569]"
                onClick={handleViewGames}
              >
                View All
              </Button>
            </CardHeader>
            <CardContent>
              <div className="overflow-x-auto -mx-4 sm:mx-0">
                <div className="inline-block min-w-full align-middle px-4 sm:px-0">
                  <table className="min-w-full text-sm">
                    <thead className="text-amber-700 dark:text-amber-300 border-b border-amber-200/30 dark:border-amber-700/30">
                      <tr>
                        <th className="text-left py-2 px-2">Opponent</th>
                        <th className="text-left py-2 px-2">Result</th>
                        <th className="hidden md:table-cell text-left py-2 px-2">
                          Date
                        </th>
                        <th className="text-center py-2 px-2">Moves</th>
                      </tr>
                    </thead>
                    <tbody>
                      {gameHistory !== undefined &&
                        gameHistory.slice(0, HISTORY_LIMIT).map((game, i) => (
                          <tr
                            key={i}
                            className="border-b border-amber-100/50 dark:border-slate-700/30 hover:bg-amber-50 hover:text-amber-900 dark:hover:text-slate-100/80 dark:hover:bg-slate-700/30 transition-colors"
                          >
                            <td className="py-2 px-2 font-medium truncate max-w-[100px] sm:max-w-none">
                              {game.black === username
                                ? game.white
                                : game.black}
                            </td>
                            <td
                              className={`py-2 px-2 font-medium ${
                                (game.status === 'WHITE_WINS' &&
                                  game.white === username) ||
                                (game.status === 'BLACK_WINS' &&
                                  game.black === username)
                                  ? 'text-green-600 dark:text-green-400'
                                  : game.status === 'DRAW'
                                  ? 'text-amber-600 dark:text-amber-400'
                                  : 'text-red-600 dark:text-red-400'
                              }`}
                            >
                              {game.status === 'DRAW'
                                ? '½-½'
                                : (game.status === 'WHITE_WINS' &&
                                    game.white === username) ||
                                  (game.status === 'BLACK_WINS' &&
                                    game.black === username)
                                ? '1-0'
                                : '0-1'}
                            </td>
                            <td className="hidden md:table-cell py-2 px-2">
                              {game.createdat
                                ? getLastTime(game.createdat)
                                : '—'}
                            </td>
                            <td className="text-center py-2 px-2">
                              {game.pgn
                                ? (
                                    game.pgn.match(
                                      /\b([PNBRQK]?[a-h]?[1-8]?x?[a-h][1-8](?:=[NBRQ])?|O-O(?:-O)?|[a-h][1-8])\b/g
                                    ) || []
                                  ).length
                                : 0}
                            </td>
                          </tr>
                        ))}
                    </tbody>
                  </table>
                </div>
              </div>
            </CardContent>
          </Card>
        </div>

        {/* Friends */}
        {/* <div className="w-full xl:w-80 flex-shrink-0">
          <Card className="w-full bg-white/50 dark:bg-slate-800/50 backdrop-blur-sm border border-amber-200/50 dark:border-amber-800/30 shadow-md">
            <CardHeader className="pb-2">
              <CardTitle className="text-lg font-semibold text-amber-900 dark:text-amber-100 flex justify-between items-center">
                <span>Friends</span>
                <span className="text-sm text-amber-600 dark:text-amber-400">
                  {mockFriends.length}
                </span>
              </CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-2 pr-1">
                {mockFriends.slice(0, FRIEND_PER_PAGE).map((friend, i) => (
                  <div
                    key={i}
                    className="flex items-center justify-between p-2 rounded-md hover:bg-amber-50/70 dark:hover:bg-slate-700/50 transition-colors border border-transparent hover:border-amber-200/30 dark:hover:border-amber-800/20"
                  >
                    <div className="flex items-center gap-2">
                      <div className="relative">
                        <div className="h-8 w-8 rounded-full bg-amber-100 dark:bg-slate-700 flex items-center justify-center text-amber-600 dark:text-amber-400 font-medium">
                          {friend.name[0].toUpperCase()}
                        </div>
                        <div
                          className={`absolute -bottom-1 -right-1 h-3 w-3 rounded-full border-2 border-white dark:border-slate-800 ${getStatusColor(
                            friend.status
                          )}`}
                        ></div>
                      </div>
                      <div className="min-w-0">
                        <div className="font-medium text-sm text-amber-800 dark:text-amber-200 truncate max-w-[120px]">
                          {friend.name}
                        </div>
                        <div className="text-xs text-amber-600 dark:text-amber-400">
                          {friend.rating}
                        </div>
                      </div>
                    </div>
                    <button className="text-amber-600 dark:text-amber-400 hover:text-amber-800 dark:hover:text-amber-200 flex-shrink-0">
                      <svg
                        xmlns="http://www.w3.org/2000/svg"
                        fill="none"
                        viewBox="0 0 24 24"
                        strokeWidth={1.5}
                        stroke="currentColor"
                        className="w-5 h-5"
                      >
                        <path
                          strokeLinecap="round"
                          strokeLinejoin="round"
                          d="M21 8.25c0-2.485-2.099-4.5-4.688-4.5-1.935 0-3.597 1.126-4.312 2.733-.715-1.607-2.377-2.733-4.313-2.733C5.1 3.75 3 5.765 3 8.25c0 7.22 9 12 9 12s9-4.78 9-12z"
                        />
                      </svg>
                    </button>
                  </div>
                ))}
              </div>
              <div className="mt-4 text-center">
                <Button
                  variant="outline"
                  className="border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900 w-full
                  shadow-[0_3px_0_0_#fcd34d] hover:shadow-[0_1px_0_0_#fcd34d] hover:translate-y-[2px]
                  dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50
                  dark:shadow-[0_3px_0_0_#475569] dark:hover:shadow-[0_1px_0_0_#475569]"
                  onClick={handleViewFriends}
                >
                  View All Friends
                </Button>
              </div>
            </CardContent>
          </Card>
        </div> */}
      </div>
    </>
  );
}
</file>

<file path="web/src/lib/MatchmakingContext.tsx">
'use client';

import React, {
  createContext,
  useContext,
  useState,
  ReactNode,
  useRef,
  useEffect,
} from 'react';
import { MatchMakingService } from '@/lib/matchmakingService';
import { toast } from 'sonner';

type CooldownState = 'ready' | 'cooldown' | 'active';

type MatchmakingContextType = {
  isMatchmaking: boolean;
  startMatchmaking: (userId: string) => Promise<void>;
  cancelMatchmaking: () => void;
  matchmakingError: string | null;
  playCooldownState: CooldownState;
  cooldownDuration: number;
  cooldownRemaining: number;
};

const MatchmakingContext = createContext<MatchmakingContextType | undefined>(
  undefined
);

const MAX_RETRY_ATTEMPTS = 5;
const RETRY_DELAY = 2000;
const COOLDOWN_DURATION = 5000;

export function MatchmakingProvider({ children }: { children: ReactNode }) {
  const [isMatchmaking, setIsMatchmaking] = useState(false);
  const [matchmakingError, setMatchmakingError] = useState<string | null>(null);
  const [playCooldownState, setPlayCooldownState] =
    useState<CooldownState>('ready');
  const [cooldownRemaining, setCooldownRemaining] = useState(0);
  const [retryCount, setRetryCount] = useState(0);

  const cooldownTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const cooldownIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const cooldownStartTimeRef = useRef<number>(0);
  const retryTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const cooldownDuration = COOLDOWN_DURATION;

  const isCancelledRef = useRef(false);

  useEffect(() => {
    return () => {
      if (cooldownTimeoutRef.current) {
        clearTimeout(cooldownTimeoutRef.current);
      }
      if (cooldownIntervalRef.current) {
        clearInterval(cooldownIntervalRef.current);
      }
      if (retryTimeoutRef.current) {
        clearTimeout(retryTimeoutRef.current);
      }
    };
  }, []);

  const startCooldown = () => {
    setPlayCooldownState('cooldown');
    cooldownStartTimeRef.current = Date.now();
    setCooldownRemaining(cooldownDuration);

    if (cooldownTimeoutRef.current) {
      clearTimeout(cooldownTimeoutRef.current);
    }

    if (cooldownIntervalRef.current) {
      clearInterval(cooldownIntervalRef.current);
    }

    cooldownIntervalRef.current = setInterval(() => {
      const elapsed = Date.now() - cooldownStartTimeRef.current;
      const remaining = Math.max(0, cooldownDuration - elapsed);
      setCooldownRemaining(remaining);

      if (remaining <= 0) {
        if (cooldownIntervalRef.current) {
          clearInterval(cooldownIntervalRef.current);
          cooldownIntervalRef.current = null;
        }
      }
    }, 100);

    cooldownTimeoutRef.current = setTimeout(() => {
      setPlayCooldownState('ready');
      cooldownTimeoutRef.current = null;

      if (cooldownIntervalRef.current) {
        clearInterval(cooldownIntervalRef.current);
        cooldownIntervalRef.current = null;
      }
    }, cooldownDuration);
  };

  const attemptMatchmaking = async (
    userId: string
  ): Promise<{ game_id: string; color: 'w' | 'b' }> => {
    try {
      const matchmakingService = MatchMakingService.getInstance();
      return await matchmakingService.findMatch(userId);
    } catch (error) {
      const isNetworkError =
        error instanceof Error &&
        (error.message.includes('Failed to fetch') ||
          error.message.includes('NetworkError') ||
          error.message.includes('timeout'));

      if (isNetworkError && retryCount < MAX_RETRY_ATTEMPTS) {
        setRetryCount((prev) => prev + 1);
        throw error;
      }

      throw error;
    }
  };

  const startMatchmaking = async (userId: string) => {
    if (isMatchmaking) return;

    if (playCooldownState === 'cooldown') {
      return;
    }

    isCancelledRef.current = false;

    try {
      setPlayCooldownState('active');
      setIsMatchmaking(true);
      setMatchmakingError(null);
      setRetryCount(0);

      let result;
      try {
        result = await attemptMatchmaking(userId);
      } catch (error) {
        if (isCancelledRef.current) {
          return;
        }
        if (retryCount < MAX_RETRY_ATTEMPTS) {
          toast.info(
            `Connection issue. Retrying... (${
              retryCount + 1
            }/${MAX_RETRY_ATTEMPTS})`
          );

          await new Promise((resolve) => {
            retryTimeoutRef.current = setTimeout(() => {
              resolve(null);
            }, RETRY_DELAY * Math.pow(2, retryCount));
          });

          result = await attemptMatchmaking(userId);
        } else {
          throw error;
        }
      }

      window.location.href = `/socket?game_id=${result.game_id}&playas=${result.color}`;
    } catch (error) {
      if (error instanceof Error && !error.message.includes('canceled')) {
        setMatchmakingError(
          error instanceof Error ? error.message : 'Match finding failed'
        );
        startCooldown();
      }

      setIsMatchmaking(false);
    }
  };

  const cancelMatchmaking = () => {
    const matchmakingService = MatchMakingService.getInstance();
    isCancelledRef.current = true;
    matchmakingService.cancelMatch();
    setIsMatchmaking(false);
    startCooldown();
  };

  return (
    <MatchmakingContext.Provider
      value={{
        isMatchmaking,
        startMatchmaking,
        cancelMatchmaking,
        matchmakingError,
        playCooldownState,
        cooldownDuration,
        cooldownRemaining,
      }}
    >
      {children}
    </MatchmakingContext.Provider>
  );
}

export function useMatchmaking() {
  const context = useContext(MatchmakingContext);
  if (context === undefined) {
    throw new Error('useMatchmaking must be used within a MatchmakingProvider');
  }
  return context;
}
</file>

<file path="web/Dockerfile">
FROM oven/bun:1 AS builder
WORKDIR /app
COPY . .
ENV NEXT_TELEMETRY_DISABLED=1
RUN apt-get update && \
    apt-get install -y openssl && \
    rm -rf /var/lib/apt/lists/*
RUN touch bun.lockb                         
RUN bun install                                 
RUN bun add tailwindcss @tailwindcss/postcss postcss autoprefixer

RUN bunx prisma generate
RUN bun run build

FROM oven/bun:1 AS runner
WORKDIR /app
ENV NEXT_TELEMETRY_DISABLED=1
RUN apt-get update && \
    apt-get install -y openssl && \
    rm -rf /var/lib/apt/lists/*
COPY --from=builder /app/.next ./.next
COPY --from=builder /app/public ./public
COPY --from=builder /app/package.json ./package.json
COPY --from=builder /app/bun.lockb ./bun.lockb
COPY --from=builder /app/prisma ./prisma
COPY --from=builder /app/node_modules/.prisma/client ./node_modules/.prisma/client

RUN bun install --production
ARG PORT
EXPOSE ${PORT:-3000}
CMD ["bun", "start"]
</file>

<file path="engine/.gitignore">
# === Rust ===
**/target/
**/*.rs.bk
Cargo.lock

# === Docker ===
*.tar

# === Logs / Runtime files ===
*.log
*.pid
*.seed
*.sock

# === Editor/IDE ===
.vscode/
.idea/
*.sw?
*~
*.bak

# === macOS / Linux / Windows OS files ===
.DS_Store
Thumbs.db

# === Project-specific ===
*repomix-output.xml
</file>

<file path="web/src/app/actions/gameActions.ts">
'use server';

import { GameStatus } from '@prisma/client';
import { v4 as uuidv4 } from 'uuid';
import prisma from '@/lib/prisma';
import { getLastTime } from '@/lib/time';

/**
 * Create a new game in the gamestate table
 */
export async function createGame(white: string, black: string) {
  try {
    const game = await prisma.gamestate.create({
      data: {
        gameid: uuidv4(),
        white,
        black,
        pgn: '',
        status: 'ONGOING',
      },
    });

    return { success: true, gameId: game.gameid };
  } catch (error) {
    console.error('Error creating game:', error);
    return { success: false, error: 'Failed to create game' };
  }
}

/**
 * Update game PGN
 */
export async function updateGamePgn(gameId: string, pgn: string) {
  try {
    await prisma.gamestate.update({
      where: { gameid: gameId },
      data: { pgn },
    });

    return { success: true };
  } catch (error) {
    console.error('Error updating game PGN:', error);
    return { success: false, error: 'Failed to update game PGN' };
  }
}

/**
 * Update game status when game ends
 */
export async function updateGameStatus(gameId: string, status: GameStatus) {
  try {
    await prisma.gamestate.update({
      where: { gameid: gameId },
      data: { status },
    });

    return { success: true };
  } catch (error) {
    console.error('Error updating game status:', error);
    return { success: false, error: 'Failed to update game status' };
  }
}

/**
 * Get game by id
 */
export async function getGame(gameId: string) {
  try {
    const game = await prisma.gamestate.findUnique({
      where: { gameid: gameId },
    });

    return { success: true, game };
  } catch (error) {
    console.error('Error fetching game:', error);
    return { success: false, error: 'Failed to fetch game' };
  }
}

/**
 * Get user's game history (not ONGOING STATUS)
 */
export async function getUserHistoryGames(username: string, offset = 0) {
  try {
    const games = await prisma.gamestate.findMany({
      where: {
        OR: [{ white: username }, { black: username }],
        NOT: {
          status: { in: ['ONGOING', 'ABORTED'] },
        },
      },
      orderBy: {
        createdat: 'desc',
      },
      skip: offset,
    });

    return { success: true, games };
  } catch (error) {
    console.error('Error fetching completed games:', error);
    return { success: false, error: 'Failed to fetch completed games' };
  }
}

/**
 * Get user's ongoing games
 */
export async function getUserOngoingGames(username: string) {
  try {
    const games = await prisma.gamestate.findMany({
      where: {
        OR: [{ white: username }, { black: username }],
        status: 'ONGOING',
      },
      orderBy: {
        createdat: 'desc',
      },
    });

    const processedGames = games.map((game) => {
      const lastMove = getLastMoveFromPgn(game.pgn);
      const lastMoveTime = getLastTime(game.createdat);

      return {
        ...game,
        opponent: game.white === username ? game.black : game.white,
        lastMove: lastMove || 'Game started',
        lastMoveTime: lastMoveTime,
      };
    });

    return { success: true, games: processedGames };
  } catch (error) {
    console.error('Error fetching ongoing games:', error);
    return { success: false, error: 'Failed to fetch ongoing games' };
  }
}

/**
 * Get turn from pgn
 */
function getLastMoveFromPgn(pgn: string): string {
  if (!pgn || pgn.trim() === '') return '';

  const moveRegex =
    /\d+\.\s+([A-Za-z0-9\+\#\=\-]+)(?:\s+([A-Za-z0-9\+\#\=\-]+))?/g;
  let lastMatch;
  let match;

  while ((match = moveRegex.exec(pgn)) !== null) {
    lastMatch = match;
  }

  if (lastMatch) {
    return lastMatch[2] ? lastMatch[2] : lastMatch[1];
  }

  return '';
}
</file>

<file path="web/src/components/dashboard/Game.tsx">
import { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import {
  ArrowLeftIcon,
  ArrowRightIcon,
  MagnifyingGlassIcon,
  ArrowPathIcon,
} from '@heroicons/react/24/outline';
import { getUserHistoryGames } from '@/app/actions/gameActions';
import { gamestate } from '@prisma/client';
import { toast } from 'sonner';
import LoadingScreen from '../LoadingScreen';

export default function GamesTab({ username }: { username: string }) {
  const [currentPage, setCurrentPage] = useState(1);
  const [searchTerm, setSearchTerm] = useState('');
  const [resultFilter, setResultFilter] = useState('All');
  const [games, setGames] = useState<gamestate[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [searchInputFocused, setSearchInputFocused] = useState(false);

  const itemsPerPage = 25;

  useEffect(() => {
    const fetchGames = async () => {
      try {
        setIsLoading(true);
        const result = await getUserHistoryGames(username);
        if (result.success) {
          setGames(result.games || []);
        } else {
          toast.error('Failed to load game history');
        }
      } catch (error) {
        console.error('Error fetching games:', error);
        toast.error('Error loading game history');
      } finally {
        setIsLoading(false);
      }
    };

    fetchGames();
  }, [username]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (searchInputFocused) {
        e.stopPropagation();
      }
    };

    document.addEventListener('keydown', handleKeyDown, true);
    return () => {
      document.removeEventListener('keydown', handleKeyDown, true);
    };
  }, [searchInputFocused]);

  const getGameResult = (game: gamestate): string => {
    if (game.status === 'DRAW') return '½-½';
    if (game.status === 'WHITE_WINS')
      return game.white === username ? '1-0' : '0-1';
    if (game.status === 'BLACK_WINS')
      return game.black === username ? '1-0' : '0-1';
    return '-';
  };

  const getOpponent = (game: gamestate): string => {
    return game.white === username ? game.black : game.white;
  };

  const getMoveCount = (pgn: string): number => {
    const moves = pgn.match(
      /\b([PNBRQK]?[a-h]?[1-8]?x?[a-h][1-8](?:=[NBRQ])?|O-O(?:-O)?|[a-h][1-8])\b/g
    );
    return moves ? moves.length : 0;
  };

  const getFormattedDate = (createdat: Date | null): string => {
    if (!createdat) return '-';
    const date = new Date(createdat);
    return `${date.getMonth() + 1}/${date.getDate()}/${date.getFullYear()}`;
  };

  const filteredGames = games.filter((game) => {
    const opponent = getOpponent(game);
    const result = getGameResult(game);

    const matchesSearch =
      searchTerm === '' ||
      opponent.toLowerCase().includes(searchTerm.toLowerCase());

    const matchesResult =
      resultFilter === 'All' ||
      (resultFilter === 'Win' && result === '1-0') ||
      (resultFilter === 'Loss' && result === '0-1') ||
      (resultFilter === 'Draw' && result === '½-½');

    return matchesSearch && matchesResult;
  });

  const totalPages = Math.ceil(filteredGames.length / itemsPerPage);
  const paginatedGames = filteredGames.slice(
    (currentPage - 1) * itemsPerPage,
    currentPage * itemsPerPage
  );

  const handlePreviousPage = () => {
    if (currentPage > 1) {
      setCurrentPage(currentPage - 1);
    }
  };

  const handleNextPage = () => {
    if (currentPage < totalPages) {
      setCurrentPage(currentPage + 1);
    }
  };

  const handleResetFilters = () => {
    setSearchTerm('');
    setResultFilter('All');
  };

  const getResultClass = (result: string) => {
    if (result === '1-0') return 'text-green-600 dark:text-green-400';
    if (result === '0-1') return 'text-red-600 dark:text-red-400';
    return 'text-amber-600 dark:text-amber-400';
  };

  if (isLoading) {
    return <LoadingScreen />;
  }

  return (
    <div className="flex flex-col lg:flex-row gap-4 sm:gap-6">
      <div className="w-full lg:flex-1 order-2 lg:order-1">
        <Card className="w-full bg-white/50 dark:bg-slate-800/50 backdrop-blur-sm border border-amber-200/50 dark:border-amber-800/30 shadow-md">
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-lg font-semibold text-amber-900 dark:text-amber-100">
              Game History
            </CardTitle>
            <div className="text-sm text-amber-700 dark:text-amber-300">
              {filteredGames.length} games
            </div>
          </CardHeader>
          <CardContent>
            <div className="overflow-x-auto -mx-4 sm:mx-0">
              <div className="inline-block min-w-full align-middle px-4 sm:px-0">
                <table className="min-w-full text-sm">
                  <thead className="text-amber-700 dark:text-amber-300 border-b border-amber-200/30 dark:border-amber-700/30">
                    <tr>
                      <th className="text-left py-2 px-2">Opponent</th>
                      <th className="text-left py-2 px-2">Result</th>
                      <th className="hidden sm:table-cell text-left py-2 px-2">
                        Date
                      </th>
                      <th className="text-center py-2 px-2">Moves</th>
                    </tr>
                  </thead>
                  <tbody>
                    {isLoading ? (
                      <tr>
                        <td colSpan={4} className="text-center py-6">
                          Loading game history...
                        </td>
                      </tr>
                    ) : paginatedGames.length === 0 ? (
                      <tr>
                        <td colSpan={4} className="text-center py-6">
                          No games found
                        </td>
                      </tr>
                    ) : (
                      paginatedGames.map((game) => {
                        const result = getGameResult(game);
                        const opponent = getOpponent(game);
                        const moveCount = getMoveCount(game.pgn);
                        const date = getFormattedDate(game.createdat);

                        return (
                          <tr
                            key={game.gameid}
                            className="border-b border-amber-100/50 dark:border-slate-700/30 hover:bg-amber-50 hover:text-amber-900 dark:hover:bg-slate-700/30 dark:hover:text-slate-100/80 transition-colors"
                          >
                            <td className="py-2 px-2 font-medium truncate max-w-[100px] sm:max-w-none">
                              {opponent}
                            </td>
                            <td
                              className={`py-2 px-2 font-medium ${getResultClass(
                                result
                              )}`}
                            >
                              {result}
                            </td>
                            <td className="hidden sm:table-cell py-2 px-2">
                              {date}
                            </td>
                            <td className="py-2 px-2 text-center">
                              {moveCount}
                            </td>
                          </tr>
                        );
                      })
                    )}
                  </tbody>
                </table>
              </div>
            </div>

            {totalPages > 1 && (
              <div className="flex flex-col sm:flex-row justify-between items-center mt-4 gap-2">
                <div className="text-sm text-amber-700 dark:text-amber-300 order-2 sm:order-1">
                  Showing {(currentPage - 1) * itemsPerPage + 1} to{' '}
                  {Math.min(currentPage * itemsPerPage, filteredGames.length)}{' '}
                  of {filteredGames.length} games
                </div>
                <div className="flex space-x-2 order-1 sm:order-2">
                  <Button
                    variant="outline"
                    size="sm"
                    className="h-8 w-8 p-0 border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900
                    shadow-[0_2px_0_0_#fcd34d] hover:shadow-[0_1px_0_0_#fcd34d] hover:translate-y-[1px]
                    dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50
                    dark:shadow-[0_2px_0_0_#475569] dark:hover:shadow-[0_1px_0_0_#475569]"
                    onClick={handlePreviousPage}
                    disabled={currentPage === 1}
                  >
                    <ArrowLeftIcon className="h-4 w-4" />
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    className="h-8 w-8 p-0 border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900
                    shadow-[0_2px_0_0_#fcd34d] hover:shadow-[0_1px_0_0_#fcd34d] hover:translate-y-[1px]
                    dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50
                    dark:shadow-[0_2px_0_0_#475569] dark:hover:shadow-[0_1px_0_0_#475569]"
                    onClick={handleNextPage}
                    disabled={currentPage === totalPages}
                  >
                    <ArrowRightIcon className="h-4 w-4" />
                  </Button>
                </div>
              </div>
            )}
          </CardContent>
        </Card>
      </div>

      <div className="w-full lg:w-80 lg:flex-shrink-0 order-1 lg:order-2">
        <Card className="w-full bg-white/50 dark:bg-slate-800/50 backdrop-blur-sm border border-amber-200/50 dark:border-amber-800/30 shadow-md">
          <CardHeader className="pb-2">
            <CardTitle className="text-lg font-semibold text-amber-900 dark:text-amber-100">
              Search Games
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="space-y-2">
              <div className="text-sm text-amber-700 dark:text-amber-300">
                Opponent
              </div>
              <div className="relative">
                <Input
                  type="text"
                  placeholder="Search opponent"
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  onFocus={() => setSearchInputFocused(true)}
                  onBlur={() => setSearchInputFocused(false)}
                  className="pl-8 bg-amber-50/80 dark:bg-slate-700/80 border-amber-200 dark:border-slate-600 focus:border-amber-400 dark:focus:border-amber-400"
                />
                <MagnifyingGlassIcon className="absolute left-2.5 top-2.5 h-4 w-4 text-amber-700 dark:text-amber-300" />
              </div>
            </div>

            <div className="space-y-2">
              <div className="text-sm text-amber-700 dark:text-amber-300">
                Result
              </div>
              <div className="grid grid-cols-3 gap-2">
                <Button
                  variant={resultFilter === 'Draw' ? 'default' : 'outline'}
                  size="sm"
                  className={
                    resultFilter === 'Draw'
                      ? 'bg-amber-600 hover:bg-amber-700 text-white shadow-[0_2px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px] dark:bg-amber-500 dark:hover:bg-amber-600 dark:shadow-[0_2px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f]'
                      : 'border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900 shadow-[0_2px_0_0_#fcd34d] hover:shadow-[0_1px_0_0_#fcd34d] hover:translate-y-[1px] dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50 dark:shadow-[0_2px_0_0_#475569] dark:hover:shadow-[0_1px_0_0_#475569]'
                  }
                  onClick={() => setResultFilter('Draw')}
                >
                  Draws
                </Button>
                <Button
                  variant={resultFilter === 'Win' ? 'default' : 'outline'}
                  size="sm"
                  className={
                    resultFilter === 'Win'
                      ? 'bg-green-600 hover:bg-green-700 text-white shadow-[0_2px_0_0_#16a34a] hover:shadow-[0_1px_0_0_#15803d] hover:translate-y-[1px] dark:bg-green-500 dark:hover:bg-green-600 dark:shadow-[0_2px_0_0_#15803d] dark:hover:shadow-[0_1px_0_0_#166534]'
                      : 'border-green-300 text-green-800 hover:bg-green-50/50 hover:text-green-900 shadow-[0_2px_0_0_#86efac] hover:shadow-[0_1px_0_0_#86efac] hover:translate-y-[1px] dark:border-green-700/50 dark:text-green-200 dark:hover:bg-green-900/20 dark:shadow-[0_2px_0_0_#166534] dark:hover:shadow-[0_1px_0_0_#14532d]'
                  }
                  onClick={() => setResultFilter('Win')}
                >
                  Wins
                </Button>
                <Button
                  variant={resultFilter === 'Loss' ? 'default' : 'outline'}
                  size="sm"
                  className={
                    resultFilter === 'Loss'
                      ? 'bg-red-600 hover:bg-red-700 text-white shadow-[0_2px_0_0_#dc2626] hover:shadow-[0_1px_0_0_#b91c1c] hover:translate-y-[1px] dark:bg-red-500 dark:hover:bg-red-600 dark:shadow-[0_2px_0_0_#b91c1c] dark:hover:shadow-[0_1px_0_0_#991b1b]'
                      : 'border-red-300 text-red-800 hover:bg-red-50/50 hover:text-red-900 shadow-[0_2px_0_0_#fca5a5] hover:shadow-[0_1px_0_0_#fca5a5] hover:translate-y-[1px] dark:border-red-700/50 dark:text-red-200 dark:hover:bg-red-900/20 dark:shadow-[0_2px_0_0_#991b1b] dark:hover:shadow-[0_1px_0_0_#7f1d1d]'
                  }
                  onClick={() => setResultFilter('Loss')}
                >
                  Losses
                </Button>
              </div>
            </div>

            <Button
              variant="outline"
              size="sm"
              className="w-full mt-2 border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900
              shadow-[0_3px_0_0_#fcd34d] hover:shadow-[0_1px_0_0_#fcd34d] hover:translate-y-[2px]
              dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50
              dark:shadow-[0_3px_0_0_#475569] dark:hover:shadow-[0_1px_0_0_#475569]"
              onClick={handleResetFilters}
            >
              <ArrowPathIcon className="h-4 w-4 mr-2" />
              Reset Filters
            </Button>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
</file>

<file path="web/src/components/ComputerGamePane.tsx">
'use client';

import { useState, useEffect, useRef } from 'react';
import { Chess } from 'chess.js';
import type { Square } from 'chess.js';
import { Button } from '@/components/ui/button';
import { ChessBoard } from '@/components/ChessBoard';
import { Card, CardContent } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import {
  ChevronDoubleLeftIcon,
  ChevronDoubleRightIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
  ArrowUturnLeftIcon,
  FlagIcon,
  ArrowPathIcon,
  SignalIcon,
  ExclamationTriangleIcon,
  SignalSlashIcon,
  HomeIcon,
  XCircleIcon,
} from '@heroicons/react/24/outline';
import { UserInfo } from '@/types/googleAuthTypes';
import { getUserInfo } from '@/lib/auth/googleAuth';

interface GameProps {
  chess: Chess;
  fen: string;
  lastMove?: [Square, Square];
  selectVisible: boolean;
  pendingMove?: [Square, Square];
  previewIndex: number | null;
  previewFen: string | null;
  onMove: (from: Square, to: Square) => void;
  promotion: (piece: 'q' | 'r' | 'n' | 'b') => void;
  previewMove: (index: number) => void;
  handleFirstMove: () => void;
  handlePrevious: () => void;
  handleNext: () => void;
  handleLastMove: () => void;
  playingAs: 'w' | 'b';
  gameOver?: boolean;
  engineStatus: 'connected' | 'degraded' | 'disconnected' | 'pending';
  isThinking: boolean;
  handleTakeBack: () => void;
  handleResign: () => void;
  handleRetry: () => void;
  handleAbort: () => void;
}

interface PaneProps {
  playingAs: 'w' | 'b';
  gameProps: GameProps;
}

function getGameStatus(chess: Chess, gameOver?: boolean): string {
  if (gameOver) {
    const winner = chess.turn() === 'w' ? 'Black' : 'White';
    if (chess.isCheckmate()) {
      return `${winner} wins by checkmate`;
    }

    if (chess.isStalemate()) {
      return 'Draw by stalemate';
    }

    if (chess.isThreefoldRepetition()) {
      return 'Draw by repetition';
    }

    if (chess.isInsufficientMaterial()) {
      return 'Draw by insufficient material';
    }

    if (chess.isDrawByFiftyMoves()) {
      return 'Draw by fifty-move rule';
    }

    if (!chess.isGameOver()) {
      const loser = chess.turn() !== 'w' ? 'Black' : 'White';
      return `${loser} Resigned, ${winner} Wins`;
    }

    return `Game ended`;
  }

  return 'Game in progress';
}

export default function ComputerGamePane({ playingAs, gameProps }: PaneProps) {
  const {
    chess,
    fen,
    lastMove,
    selectVisible,
    previewIndex,
    previewFen,
    onMove,
    promotion,
    previewMove,
    handleFirstMove,
    handlePrevious,
    handleNext,
    handleLastMove,
    gameOver,
    engineStatus,
    isThinking,
    handleTakeBack,
    handleResign,
    handleRetry,
    handleAbort,
  } = gameProps;

  const [pressedKeys, setPressedKeys] = useState<Set<string>>(new Set());
  const moveListRef = useRef<HTMLDivElement>(null);
  const [userInfo, setUserInfo] = useState<UserInfo | null>(null);

  useEffect(() => {
    const info = getUserInfo();
    setUserInfo(info);
  }, []);

  const username = userInfo?.email?.split('@')[0] || 'anonymous';

  useEffect(() => {
    if (
      moveListRef.current &&
      chess.history().length > 0 &&
      previewIndex === null
    ) {
      moveListRef.current.scrollTop = moveListRef.current.scrollHeight;
    }
  }, [chess, previewIndex]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
        e.preventDefault();
        setPressedKeys((prev) => new Set(prev).add(e.key));

        if (e.key === 'ArrowLeft') handlePrevious();
        else if (e.key === 'ArrowRight') handleNext();
        else if (e.key === 'ArrowUp') handleFirstMove();
        else if (e.key === 'ArrowDown') handleLastMove();
      }
    };

    const handleKeyUp = (e: KeyboardEvent) => {
      if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
        setPressedKeys((prev) => {
          const updated = new Set(prev);
          updated.delete(e.key);
          return updated;
        });
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [handlePrevious, handleNext, handleFirstMove, handleLastMove]);

  const movePairs = [];
  const history = chess.history();

  for (let i = 0; i < history.length; i += 2) {
    movePairs.push({
      moveNumber: Math.floor(i / 2) + 1,
      whiteMove: history[i],
      blackMove: i + 1 < history.length ? history[i + 1] : undefined,
      whiteIndex: i,
      blackIndex: i + 1,
    });
  }

  const boardFen = previewFen ? previewFen : fen;
  const gameStatus = getGameStatus(chess, gameOver);
  const turnColor = chess.turn();
  const isPlayerTurn = turnColor === playingAs;

  const getEngineStatusBadge = () => {
    switch (engineStatus) {
      case 'connected':
        return (
          <Badge className="bg-green-600 text-white flex items-center gap-1">
            <SignalIcon className="h-3 w-3" />
            Connected
          </Badge>
        );
      case 'degraded':
        return (
          <Badge className="bg-amber-600 text-white flex items-center gap-1">
            <ExclamationTriangleIcon className="h-3 w-3" />
            Degraded
          </Badge>
        );
      case 'disconnected':
        return (
          <Badge className="bg-red-600 text-white flex items-center gap-1">
            <SignalSlashIcon className="h-3 w-3" />
            Disconnected
          </Badge>
        );
      default:
        return (
          <Badge className="bg-amber-600 text-white flex items-center gap-1">
            <SignalIcon className="h-3 w-3" />
            Pending
          </Badge>
        );
    }
  };

  const handleHome = () => {
    window.location.href = `/home`;
  };

  return (
    <Card className="w-full h-full bg-white/50 dark:bg-slate-800/50 backdrop-blur-sm border border-amber-200/50 dark:border-amber-800/30 shadow-md rounded-xl overflow-hidden">
      <CardContent className="p-4 md:p-6">
        <div className="md:hidden flex flex-col gap-4">
          <Card className="bg-white dark:bg-slate-700 border border-amber-200/50 dark:border-slate-600/50 shadow-none">
            <CardContent className="text-center p-4">
              <div className="flex justify-between items-center mb-2">
                <div className="font-medium text-base text-amber-800 dark:text-amber-200">
                  {playingAs === 'w'
                    ? `${username} vs Computer`
                    : `Computer vs ${username}`}
                </div>
                {getEngineStatusBadge()}
              </div>
              <div className="text-sm text-amber-600 dark:text-amber-300">
                {gameStatus}
              </div>
              <div className="text-sm font-medium mt-2">
                {!gameOver && (
                  <span
                    className={
                      isPlayerTurn
                        ? 'text-green-600 dark:text-green-400'
                        : 'text-amber-600 dark:text-amber-400'
                    }
                  >
                    {isPlayerTurn ? 'Your turn' : 'Engine is thinking'}
                  </span>
                )}
              </div>
            </CardContent>
          </Card>

          <div className="w-full flex items-center justify-center">
            <div className="w-full max-w-lg">
              <ChessBoard
                fen={boardFen}
                onMove={onMove}
                lastMove={lastMove}
                playingAs={playingAs}
                selectVisible={selectVisible}
                promotion={promotion}
                previewIndex={previewIndex}
                chess={chess}
                viewOnly={gameOver || previewIndex !== null || isThinking}
              />
            </div>
          </div>

          <div className="flex justify-center items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              data-key="ArrowUp"
              className={`w-10 h-10 p-1 bg-amber-600 hover:text-white hover:bg-amber-700 border-none text-white shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px] dark:bg-amber-500 dark:hover:bg-amber-600 dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f] ${
                pressedKeys.has('ArrowUp')
                  ? 'translate-y-[2px] shadow-none'
                  : ''
              }`}
              onClick={handleFirstMove}
              disabled={chess.history().length === 0}
              aria-label="First move"
            >
              <ChevronDoubleLeftIcon className="h-5 w-5" />
            </Button>
            <Button
              variant="outline"
              size="sm"
              data-key="ArrowLeft"
              className={`w-10 h-10 p-1 bg-amber-600 hover:text-white hover:bg-amber-700 border-none text-white shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px] dark:bg-amber-500 dark:hover:bg-amber-600 dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f] ${
                pressedKeys.has('ArrowLeft')
                  ? 'translate-y-[2px] shadow-none'
                  : ''
              }`}
              onClick={handlePrevious}
              disabled={previewIndex === 0 || chess.history().length === 0}
              aria-label="Previous move"
            >
              <ChevronLeftIcon className="h-5 w-5" />
            </Button>
            <Button
              variant="outline"
              size="sm"
              data-key="ArrowRight"
              className={`w-10 h-10 p-1 bg-amber-600 hover:text-white hover:bg-amber-700 border-none text-white shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px] dark:bg-amber-500 dark:hover:bg-amber-600 dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f] ${
                pressedKeys.has('ArrowRight')
                  ? 'translate-y-[2px] shadow-none'
                  : ''
              }`}
              onClick={handleNext}
              disabled={previewIndex === null || chess.history().length === 0}
              aria-label="Next move"
            >
              <ChevronRightIcon className="h-5 w-5" />
            </Button>
            <Button
              variant="outline"
              size="sm"
              data-key="ArrowDown"
              className={`w-10 h-10 p-1 bg-amber-600 hover:text-white hover:bg-amber-700 border-none text-white shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px] dark:bg-amber-500 dark:hover:bg-amber-600 dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f] ${
                pressedKeys.has('ArrowDown')
                  ? 'translate-y-[2px] shadow-none'
                  : ''
              }`}
              onClick={handleLastMove}
              disabled={previewIndex === null}
              aria-label="Last move"
            >
              <ChevronDoubleRightIcon className="h-5 w-5" />
            </Button>
          </div>

          <div className="flex justify-center items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              className="w-10 h-10 p-1 bg-amber-100 text-amber-800 border-amber-300 hover:bg-amber-200 hover:text-amber-900 dark:bg-amber-600 dark:text-amber-200 dark:border-amber-600 dark:hover:bg-amber-600 shadow-[0_3px_0_0_#fcd34d] hover:shadow-[0_1px_0_0_#fcd34d] hover:translate-y-[1px] dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f]"
              onClick={handleTakeBack}
              disabled={gameOver || chess.history().length < 2}
              aria-label="Take Back"
            >
              <ArrowUturnLeftIcon className="h-5 w-5" />
            </Button>
            {gameOver ? (
              <Button
                variant="outline"
                size="sm"
                className="w-10 h-10 p-1 bg-green-100 text-green-800 border-green-300 hover:bg-green-200 dark:bg-slate-700 dark:text-green-400 dark:bg-green-700 hover:dark:bg-green-800 dark:border-green-700 shadow-[0_3px_0_0_#86efac] hover:shadow-[0_1px_0_0_#86efac] hover:translate-y-[1px] dark:shadow-[0_3px_0_0_#166534] dark:hover:shadow-[0_1px_0_0_#14532d]"
                onClick={handleHome}
                aria-label="Play Again"
              >
                <HomeIcon className="h-5 w-5" />
              </Button>
            ) : (
              <Button
                variant="outline"
                size="sm"
                className="w-10 h-10 p-1 bg-red-100 text-red-800 border-red-300 hover:bg-red-200 hover:text-red-900 dark:bg-red-600 dark:text-amber-200 dark:border-red-700 dark:hover:bg-red-600 shadow-[0_3px_0_0_#fca5a5] hover:shadow-[0_1px_0_0_#fca5a5] hover:translate-y-[1px] dark:shadow-[0_3px_0_0_#991b1b] dark:hover:shadow-[0_1px_0_0_#7f1d1d]"
                onClick={handleResign}
                aria-label="Resign"
              >
                <FlagIcon className="h-5 w-5" />
              </Button>
            )}
            <Button
              variant="outline"
              size="sm"
              className="w-10 h-10 p-1 bg-yellow-100 text-yellow-800 border-yellow-300 hover:bg-yellow-200 hover:text-yellow-900 dark:bg-yellow-600 dark:text-yellow-400 dark:border-yellow-700 dark:hover:bg-yellow-600 shadow-[0_3px_0_0_#fde68a] hover:shadow-[0_1px_0_0_#fde68a] hover:translate-y-[1px] dark:shadow-yellow-500/50 dark:hover:shadow-yellow-500/75"
              onClick={handleAbort}
              disabled={gameOver}
              aria-label="Abort Game"
            >
              <XCircleIcon className="h-5 w-5" />
            </Button>
            {engineStatus === 'disconnected' && (
              <Button
                variant="outline"
                size="sm"
                className="w-10 h-10 p-1 bg-green-100 text-green-800 border-green-300 hover:bg-green-200 dark:bg-slate-700 dark:text-green-400 dark:border-green-700 dark:hover:bg-slate-600 shadow-[0_3px_0_0_#86efac] hover:shadow-[0_1px_0_0_#86efac] hover:translate-y-[1px] dark:shadow-[0_3px_0_0_#166534] dark:hover:shadow-[0_1px_0_0_#14532d]"
                onClick={handleRetry}
                aria-label="Retry"
              >
                <ArrowPathIcon className="h-5 w-5" />
              </Button>
            )}
          </div>

          <div className="bg-amber-50 dark:bg-slate-800 rounded-lg border border-amber-200/50 dark:border-amber-800/30 overflow-hidden shadow-md flex flex-col h-[300px]">
            <div
              ref={moveListRef}
              className="overflow-y-auto flex-grow max-h-[300px] px-4 font-mono text-sm"
            >
              <div className="pt-2" />
              <table className="w-full table-fixed">
                <thead className="text-left text-amber-700 dark:text-amber-300 border-b border-amber-200/50 dark:border-amber-700/30 sticky top-0 bg-amber-50 dark:bg-slate-800">
                  <tr>
                    <th className="w-10 py-2">#</th>
                    <th className="w-1/2 py-2">White</th>
                    <th className="w-1/2 py-2">Black</th>
                  </tr>
                </thead>
                <tbody>
                  {movePairs.length > 0 ? (
                    movePairs.map((move) => (
                      <tr
                        key={move.moveNumber}
                        className="hover:bg-amber-50 dark:hover:bg-amber-900/20"
                      >
                        <td className="py-1 text-amber-600 dark:text-amber-400">
                          {move.moveNumber}.
                        </td>
                        <td className="py-1">
                          {move.whiteMove && (
                            <button
                              className={`font-semibold text-amber-800 dark:text-amber-200 ${
                                previewIndex === move.whiteIndex
                                  ? 'bg-amber-100 dark:bg-amber-900/30 px-2 py-0.5 rounded'
                                  : 'hover:bg-amber-100/50 dark:hover:bg-amber-900/20 px-2 py-0.5 rounded'
                              }`}
                              onClick={() => previewMove(move.whiteIndex)}
                            >
                              {move.whiteMove}
                            </button>
                          )}
                        </td>
                        <td className="py-1">
                          {move.blackMove && (
                            <button
                              className={`font-semibold text-amber-800 dark:text-amber-200 ${
                                previewIndex === move.blackIndex
                                  ? 'bg-amber-100 dark:bg-amber-900/30 px-2 py-0.5 rounded'
                                  : 'hover:bg-amber-100/50 dark:hover:bg-amber-900/20 px-2 py-0.5 rounded'
                              }`}
                              onClick={() => previewMove(move.blackIndex)}
                            >
                              {move.blackMove}
                            </button>
                          )}
                        </td>
                      </tr>
                    ))
                  ) : (
                    <tr>
                      <td
                        colSpan={3}
                        className="text-center text-amber-500 dark:text-amber-400 py-4"
                      >
                        No moves yet
                      </td>
                    </tr>
                  )}
                </tbody>
              </table>
            </div>
          </div>
        </div>

        <div className="hidden md:flex md:flex-col md:flex-row gap-6">
          <div className="w-full md:w-1/2 flex flex-center items-center justify-center min-h-full">
            <div className="w-full max-w-lg">
              <ChessBoard
                fen={boardFen}
                onMove={onMove}
                lastMove={lastMove}
                playingAs={playingAs}
                selectVisible={selectVisible}
                promotion={promotion}
                previewIndex={previewIndex}
                chess={chess}
                viewOnly={gameOver || previewIndex !== null}
              />
            </div>
          </div>

          <div className="w-full md:w-1/2 flex flex-col gap-4">
            <Card className="bg-white dark:bg-slate-700 border border-amber-200/50 dark:border-slate-600/50 shadow-none">
              <CardContent className="text-center px-4">
                <div className="flex justify-between items-center mb-2">
                  <div className="font-medium text-base text-amber-800 dark:text-amber-200">
                    {playingAs === 'w'
                      ? `${username} vs Computer`
                      : `Computer vs ${username}`}
                  </div>
                  {getEngineStatusBadge()}
                </div>
                <div className="text-sm text-amber-600 dark:text-amber-300">
                  {gameStatus}
                </div>
                <div className="text-sm font-medium mt-2">
                  {!gameOver ? (
                    <span
                      className={
                        isPlayerTurn
                          ? 'text-green-600 dark:text-green-400'
                          : 'text-amber-600 dark:text-amber-400'
                      }
                    >
                      {isPlayerTurn ? 'Your turn' : 'Engine is thinking'}
                    </span>
                  ) : (
                    <span className="text-red-600 dark:text-red-400">
                      Game Over
                    </span>
                  )}
                </div>
              </CardContent>
            </Card>

            <div className="flex-1 bg-amber-50 dark:bg-slate-800 rounded-lg border border-amber-200/50 dark:border-amber-800/30 overflow-hidden shadow-md flex flex-col h-[420px]">
              <div
                ref={moveListRef}
                className="overflow-y-auto flex-grow max-h-[325px] px-4 font-mono text-sm"
              >
                <div className="pt-2" />
                <table className="w-full table-fixed">
                  <thead className="text-left text-amber-700 dark:text-amber-300 border-b border-amber-200/50 dark:border-amber-700/30 sticky top-0 bg-amber-50 dark:bg-slate-800">
                    <tr>
                      <th className="w-10 py-2">#</th>
                      <th className="w-1/2 py-2">White</th>
                      <th className="w-1/2 py-2">Black</th>
                    </tr>
                  </thead>
                  <tbody>
                    {movePairs.length > 0 ? (
                      movePairs.map((move) => (
                        <tr
                          key={move.moveNumber}
                          className="hover:bg-amber-50 dark:hover:bg-amber-900/20"
                        >
                          <td className="py-1 text-amber-600 dark:text-amber-400">
                            {move.moveNumber}.
                          </td>
                          <td className="py-1">
                            {move.whiteMove && (
                              <button
                                className={`font-semibold text-amber-800 dark:text-amber-200 ${
                                  previewIndex === move.whiteIndex
                                    ? 'bg-amber-100 dark:bg-amber-900/30 px-2 py-0.5 rounded'
                                    : 'hover:bg-amber-100/50 dark:hover:bg-amber-900/20 px-2 py-0.5 rounded'
                                }`}
                                onClick={() => previewMove(move.whiteIndex)}
                              >
                                {move.whiteMove}
                              </button>
                            )}
                          </td>
                          <td className="py-1">
                            {move.blackMove && (
                              <button
                                className={`font-semibold text-amber-800 dark:text-amber-200 ${
                                  previewIndex === move.blackIndex
                                    ? 'bg-amber-100 dark:bg-amber-900/30 px-2 py-0.5 rounded'
                                    : 'hover:bg-amber-100/50 dark:hover:bg-amber-900/20 px-2 py-0.5 rounded'
                                }`}
                                onClick={() => previewMove(move.blackIndex)}
                              >
                                {move.blackMove}
                              </button>
                            )}
                          </td>
                        </tr>
                      ))
                    ) : (
                      <tr>
                        <td
                          colSpan={3}
                          className="text-center text-amber-500 dark:text-amber-400 py-4"
                        >
                          No moves yet
                        </td>
                      </tr>
                    )}
                  </tbody>
                </table>
              </div>

              <div className="border-t border-amber-200/50 dark:border-amber-700/30 mt-auto px-4 py-2">
                <div className="flex justify-center items-center gap-2 mb-4">
                  <Button
                    variant="outline"
                    size="sm"
                    data-key="ArrowUp"
                    className={`w-10 h-10 p-1 bg-amber-600 hover:text-white hover:bg-amber-700 border-none text-white shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px] dark:bg-amber-500 dark:hover:bg-amber-600 dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f] ${
                      pressedKeys.has('ArrowUp')
                        ? 'translate-y-[2px] shadow-none'
                        : ''
                    }`}
                    onClick={handleFirstMove}
                    disabled={chess.history().length === 0}
                    aria-label="First move"
                  >
                    <ChevronDoubleLeftIcon className="h-5 w-5" />
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    data-key="ArrowLeft"
                    className={`w-10 h-10 p-1 bg-amber-600 hover:text-white hover:bg-amber-700 border-none text-white shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px] dark:bg-amber-500 dark:hover:bg-amber-600 dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f] ${
                      pressedKeys.has('ArrowLeft')
                        ? 'translate-y-[2px] shadow-none'
                        : ''
                    }`}
                    onClick={handlePrevious}
                    disabled={
                      previewIndex === 0 || chess.history().length === 0
                    }
                    aria-label="Previous move"
                  >
                    <ChevronLeftIcon className="h-5 w-5" />
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    data-key="ArrowRight"
                    className={`w-10 h-10 p-1 bg-amber-600 hover:text-white hover:bg-amber-700 border-none text-white shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px] dark:bg-amber-500 dark:hover:bg-amber-600 dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f] ${
                      pressedKeys.has('ArrowRight')
                        ? 'translate-y-[2px] shadow-none'
                        : ''
                    }`}
                    onClick={handleNext}
                    disabled={
                      previewIndex === null || chess.history().length === 0
                    }
                    aria-label="Next move"
                  >
                    <ChevronRightIcon className="h-5 w-5" />
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    data-key="ArrowDown"
                    className={`w-10 h-10 p-1 bg-amber-600 hover:text-white hover:bg-amber-700 border-none text-white shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px] dark:bg-amber-500 dark:hover:bg-amber-600 dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f] ${
                      pressedKeys.has('ArrowDown')
                        ? 'translate-y-[2px] shadow-none'
                        : ''
                    }`}
                    onClick={handleLastMove}
                    disabled={previewIndex === null}
                    aria-label="Last move"
                  >
                    <ChevronDoubleRightIcon className="h-5 w-5" />
                  </Button>
                </div>

                <div className="flex justify-center items-center gap-2">
                  <Button
                    variant="outline"
                    size="sm"
                    className="w-10 h-10 p-1 bg-amber-100 text-amber-800 border-amber-300 hover:bg-amber-200 hover:text-amber-900 dark:bg-amber-600 dark:text-amber-200 dark:border-amber-600 dark:hover:bg-amber-600 shadow-[0_3px_0_0_#fcd34d] hover:shadow-[0_1px_0_0_#fcd34d] hover:translate-y-[1px] dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f]"
                    onClick={handleTakeBack}
                    disabled={gameOver || chess.history().length < 2}
                    aria-label="Take Back"
                  >
                    <ArrowUturnLeftIcon className="h-5 w-5" />
                  </Button>
                  {gameOver ? (
                    <Button
                      variant="outline"
                      size="sm"
                      className="w-10 h-10 p-1 bg-green-100 text-green-800 border-green-300 hover:bg-green-200 dark:bg-slate-700 dark:text-green-400 dark:border-green-700 dark:bg-green-700 hover:dark:bg-green-800 shadow-[0_3px_0_0_#86efac] hover:shadow-[0_1px_0_0_#86efac] hover:translate-y-[1px] dark:shadow-[0_3px_0_0_#166534] dark:hover:shadow-[0_1px_0_0_#14532d]"
                      onClick={handleHome}
                      aria-label="Play Again"
                    >
                      <HomeIcon className="h-5 w-5" />
                    </Button>
                  ) : (
                    <Button
                      variant="outline"
                      size="sm"
                      className="w-10 h-10 p-1 bg-red-100 text-red-800 border-red-300 hover:bg-red-200 hover:text-red-900 dark:bg-red-600 dark:text-amber-200 dark:border-red-700 dark:hover:bg-red-600 shadow-[0_3px_0_0_#fca5a5] hover:shadow-[0_1px_0_0_#fca5a5] hover:translate-y-[1px] dark:shadow-[0_3px_0_0_#991b1b] dark:hover:shadow-[0_1px_0_0_#7f1d1d]"
                      onClick={handleResign}
                      aria-label="Resign"
                    >
                      <FlagIcon className="h-5 w-5" />
                    </Button>
                  )}
                  <Button
                    variant="outline"
                    size="sm"
                    className="w-10 h-10 p-1 bg-yellow-100 text-yellow-800 border-yellow-300 hover:bg-yellow-200 hover:text-yellow-900 dark:bg-yellow-600 dark:text-yellow-400 dark:border-yellow-700 dark:hover:bg-yellow-600 shadow-[0_3px_0_0_#fde68a] hover:shadow-[0_1px_0_0_#fde68a] hover:translate-y-[1px] dark:shadow-yellow-500/50 dark:hover:shadow-yellow-500/75"
                    onClick={handleAbort}
                    disabled={gameOver}
                    aria-label="Abort Game"
                  >
                    <XCircleIcon className="h-5 w-5" />
                  </Button>
                  {engineStatus === 'disconnected' && (
                    <Button
                      variant="outline"
                      size="sm"
                      className="w-10 h-10 p-1 bg-green-100 text-green-800 border-green-300 hover:bg-green-200 dark:bg-slate-700 dark:text-green-400 dark:border-green-700 dark:hover:bg-slate-600 shadow-[0_3px_0_0_#86efac] hover:shadow-[0_1px_0_0_#86efac] hover:translate-y-[1px] dark:shadow-[0_3px_0_0_#166534] dark:hover:shadow-[0_1px_0_0_#14532d]"
                      onClick={handleRetry}
                      aria-label="Retry"
                    >
                      <ArrowPathIcon className="h-5 w-5" />
                    </Button>
                  )}
                </div>
              </div>
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="ws_server/src/main.rs">
use axum::{
    http::{header, Method},
    routing::{any, get, post},
    Router,
};
use dotenvy::dotenv;
use scc::HashMap;
use sqlx::postgres::PgPoolOptions;
use std::{env, sync::Arc};
use tower_http::cors::{AllowOrigin, CorsLayer};
use ws_server::{
    route::{games::get_games, init::post_init, ws::ws_handler},
    state::AppState,
    HOST, MAX_DB_CONNECTIONS,
};

#[tokio::main]
async fn main() {
    tracing_subscriber::fmt::init();
    dotenv().ok();

    let cors = CorsLayer::new()
        .allow_origin(AllowOrigin::any())
        .allow_methods([Method::GET, Method::POST, Method::OPTIONS])
        .allow_headers([
            header::CONTENT_TYPE,
            header::ACCEPT,
            header::ORIGIN,
            header::AUTHORIZATION,
        ])
        .allow_credentials(false);

    let pool = PgPoolOptions::new()
        .max_connections(MAX_DB_CONNECTIONS)
        .connect(&env::var("DATABASE_URL").expect("expecting DATABASE_URL in .env"))
        .await
        .unwrap();

    let state = AppState {
        active_games: Arc::new(HashMap::default()),
        pool,
    };

    let app = Router::new()
        .route("/ws", any(ws_handler))
        .route("/init", post(post_init))
        .route("/games", get(get_games))
        .with_state(state)
        .layer(cors);

    let listener = tokio::net::TcpListener::bind(HOST).await.unwrap();
    tracing::info!("Running at {HOST}");
    axum::serve(listener, app).await.unwrap();
}
</file>

<file path="web/src/app/dashboard/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import { Card } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { getUserInfo } from '@/lib/auth/googleAuth';
import OverviewTab from '@/components/dashboard/Overview';
import GamesTab from '@/components/dashboard/Game';
// import FriendsTab from '@/components/dashboard/Friend';
import { UserInfo } from '@/types/googleAuthTypes';
import { Button } from '@/components/ui/button';

export default function Dashboard() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [userInfo, setUserInfo] = useState<UserInfo | null>(null);

  // Get active tab from URL query parameter
  const activeTab = searchParams.get('tab') || 'overview';

  useEffect(() => {
    const info = getUserInfo();
    setUserInfo(info);
  }, []);

  const username = userInfo?.email?.split('@')[0] || 'anonymous';
  const isVerified = userInfo?.email_verified || true;

  const setActiveTab = (tab: string) => {
    router.push(`/dashboard?tab=${tab}`);
  };

  const renderTabContent = () => {
    const sharedProps = { setActiveTab, username };
    switch (activeTab) {
      case 'overview':
        return <OverviewTab {...sharedProps} />;
      case 'games':
        return <GamesTab username={username} />;
      // case 'friends':
      //   return <FriendsTab />;
      default:
        return <OverviewTab {...sharedProps} />;
    }
  };

  const handleSignOut = () => {
    router.push('/signout');
  };

  return (
    <div className="container mx-auto py-4 sm:py-6 md:py-8 px-4 max-w-7xl relative">
      <div className="grid grid-cols-1 gap-4 sm:gap-6">
        <Card className="py-0 bg-white/50 dark:bg-slate-800/50 backdrop-blur-sm border border-amber-200/50 dark:border-amber-800/30 shadow-md hover:shadow-lg transition-all">
          <div className="p-4 sm:p-6 pt-8 sm:pt-12">
            <div className="flex flex-col md:flex-row md:items-center gap-4 sm:gap-6">
              {/* Profile Picture */}
              <div className="relative flex justify-center md:justify-start">
                <div className="h-16 w-16 sm:h-20 sm:w-20 rounded-full bg-amber-600 dark:bg-amber-500 shadow-md dark:shadow-amber-600/20"></div>
              </div>

              {/* User Info */}
              <div className="flex-1 text-center md:text-left">
                <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-2">
                  <h1 className="text-2xl sm:text-3xl font-bold text-amber-900 dark:text-amber-100 font-display flex items-center justify-center md:justify-start">
                    {username}
                    {isVerified && (
                      <Badge className="ml-3 bg-green-600 text-white">
                        <svg
                          xmlns="http://www.w3.org/2000/svg"
                          className="h-4 w-4 mr-1"
                          viewBox="0 0 24 24"
                          fill="none"
                          stroke="currentColor"
                          strokeWidth="2"
                          strokeLinecap="round"
                          strokeLinejoin="round"
                        >
                          <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" />
                          <polyline points="22 4 12 14.01 9 11.01" />
                        </svg>
                        Verified
                      </Badge>
                    )}
                  </h1>
                  <Button
                    variant="outline"
                    onClick={handleSignOut}
                    className="flex items-center ml-auto h-9 px-4 text-sm border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900 transition-all shadow-[0_3px_0_0_#fcd34d] hover:shadow-[0_1px_0_0_#fcd34d] hover:translate-y-[2px] dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50 dark:shadow-[0_3px_0_0_#475569] dark:hover:shadow-[0_1px_0_0_#475569]"
                  >
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      className="h-5 w-5 mr-2"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      strokeWidth="2"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                    >
                      <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4" />
                      <polyline points="16 17 21 12 16 7" />
                      <line x1="21" y1="12" x2="9" y2="12" />
                    </svg>
                    Sign Out
                  </Button>
                </div>

                <div className="flex flex-wrap gap-x-4 sm:gap-x-6 gap-y-2 mt-2 sm:mt-3 text-amber-700 dark:text-amber-300 justify-center md:justify-start">
                  <div className="flex items-center">
                    <span className="text-green-600 font-bold mr-2">•</span>
                    Online now
                  </div>
                  {/* <div>
                    <span className="font-medium">Feb 11, 2023</span> Joined
                  </div>
                  <div>
                    <span className="font-medium">7</span> Friends
                  </div> */}
                </div>
              </div>
            </div>
          </div>

          {/* Submenu - Scrollable on mobile */}
          <div className="flex justify-center md:justify-start border-t border-amber-200/30 dark:border-slate-700/30 overflow-x-auto scrollbar-hide px-6">
            <button
              className={`py-3 px-4 sm:px-6 font-medium text-base sm:text-lg whitespace-nowrap ${
                activeTab === 'overview'
                  ? 'text-amber-600 dark:text-amber-400 bg-amber-100/60 dark:bg-amber-900/30 rounded-b-lg'
                  : 'text-amber-800 dark:text-amber-200 hover:text-amber-600 dark:hover:text-amber-400'
              }`}
              onClick={() => setActiveTab('overview')}
            >
              Overview
            </button>
            <button
              className={`py-3 px-4 sm:px-6 font-medium text-base sm:text-lg whitespace-nowrap ${
                activeTab === 'games'
                  ? 'text-amber-600 dark:text-amber-400 bg-amber-100/60 dark:bg-amber-900/30 rounded-b-lg'
                  : 'text-amber-800 dark:text-amber-200 hover:text-amber-600 dark:hover:text-amber-400'
              }`}
              onClick={() => setActiveTab('games')}
            >
              Games
            </button>
            {/* <button
              className={`py-3 px-4 sm:px-6 font-medium text-base sm:text-lg whitespace-nowrap ${
                activeTab === 'friends'
                  ? 'text-amber-600 dark:text-amber-400 bg-amber-100/60 dark:bg-amber-900/30 rounded-b-lg'
                  : 'text-amber-800 dark:text-amber-200 hover:text-amber-600 dark:hover:text-amber-400'
              }`}
              onClick={() => setActiveTab('friends')}
            >
              Friends
            </button> */}
          </div>
        </Card>

        <div className="w-full">{renderTabContent()}</div>
      </div>
    </div>
  );
}
</file>

<file path="ws_server/src/route/ws.rs">
use std::{sync::Arc, time::Duration};

use axum::{
    extract::{
        ws::{Message, Utf8Bytes, WebSocket},
        State, WebSocketUpgrade,
    },
    response::Response,
};
use shakmaty::{san::San, Color, Position};
use tokio::sync::{
    broadcast,
    mpsc::{self, Receiver, Sender},
};
use uuid::Uuid;

use crate::{
    message::{ClientMessage, Error, ServerMessage},
    state::{ActiveGame, ActiveGameMap, AppState},
    DEFERRED_CLEAN_UP_DURATION, MAX_CHANNEL_CAPACITY,
};
use futures_util::{
    sink::SinkExt,
    stream::{SplitSink, SplitStream, StreamExt},
};

type Result<T> = std::result::Result<T, Error>;

struct Connection {
    pub game_id: String,
    pub color: Color,
    pub tx_broadcast: broadcast::Sender<ServerMessage>,
}

pub async fn ws_handler(ws: WebSocketUpgrade, State(state): State<AppState>) -> Response {
    ws.on_upgrade(|socket| handle_socket(socket, state))
}

async fn send_msg(
    writer: &mut SplitSink<WebSocket, Message>,
    msg: &ServerMessage,
) -> std::result::Result<(), axum::Error> {
    writer
        .send(Message::Text(Utf8Bytes::from(
            serde_json::to_string(&msg).unwrap(),
        )))
        .await
}

async fn handle_socket(socket: WebSocket, state: AppState) {
    tracing::info!("socket connected");

    let (mut writer, mut reader) = socket.split();
    let (tx_local, rx_local) = mpsc::channel(MAX_CHANNEL_CAPACITY);

    let connection = match auth_socket(&mut reader, &state).await {
        Ok(info) => {
            let msg = ServerMessage::AuthSuccess;
            let _ = send_msg(&mut writer, &msg).await;
            tracing::info!("auth success: {} {}", info.game_id, info.color);
            Arc::new(info)
        }
        Err(err) => {
            let msg = ServerMessage::Error(err);
            let _ = send_msg(&mut writer, &msg).await;
            tracing::error!("auth failed");
            return;
        }
    };

    state
        .active_games
        .get(&connection.game_id)
        .expect("game should exist")
        .connect(connection.color);

    let move_history = state
        .active_games
        .read(&connection.game_id, |_, v| v.moves.clone())
        .expect("game should exist");
    if send_msg(&mut writer, &ServerMessage::MoveHistory(move_history))
        .await
        .is_err()
    {
        return;
    }

    let rx_broadcast = connection.tx_broadcast.subscribe();

    let mut read_task = tokio::spawn(handle_socket_read(
        reader,
        state.active_games.clone(),
        connection.clone(),
        tx_local,
    ));
    let mut write_task = tokio::spawn(handle_socket_write(writer, rx_broadcast, rx_local));

    tokio::select! {
        _ = &mut read_task => write_task.abort(),
        _ = &mut write_task => read_task.abort()
    }

    tracing::info!("socket closing {} {}", connection.game_id, connection.color);

    state
        .active_games
        .get(&connection.game_id)
        .expect("game should exist")
        .disconnect(connection.color);

    if state
        .active_games
        .read(&connection.game_id, |_, v| {
            !v.black_connected && !v.white_connected
        })
        .expect("game should exist")
    {
        // both players disconnect, initiate deferred clean up
        if state
            .active_games
            .read(&connection.game_id, |_, v| v.clean_up_task.is_none())
            .expect("game should exist")
        {
            let cloned_state = state.clone();
            let cloned_game_id = connection.game_id.clone();

            let join_handle = tokio::spawn(async move {
                tracing::info!("initiating deferred clean up for {}", cloned_game_id);

                tokio::time::sleep(Duration::from_secs(DEFERRED_CLEAN_UP_DURATION)).await;

                tracing::info!("cleaning up state for {}", cloned_game_id);

                cloned_state
                    .active_games
                    .remove(&cloned_game_id)
                    .expect("game should exist");
                // if let Err(e) = sqlx::query!(
                //     "UPDATE GameState SET Status = 'Abort' WHERE GameID = $1",
                //     Uuid::parse_str(&cloned_game_id).expect("game_id should be a valid UUID")
                // )
                // .execute(&cloned_state.pool)
                // .await
                // {
                //     tracing::error!("removing active game failed: {e}");
                // }
            });

            state
                .active_games
                .get(&connection.game_id)
                .expect("game should exist")
                .clean_up_task = Some(join_handle);
        }
    }
}

fn get_connection_from_map(
    state: &AppState,
    game_id: &str,
    user_id: &str,
) -> Option<Result<Connection>> {
    state.active_games.read(game_id, |_, v| {
        if v.black_user_id.as_str() == user_id && !v.black_connected {
            return Ok(Connection {
                game_id: game_id.to_owned(),
                color: Color::Black,
                tx_broadcast: v.tx_broadcast.clone(),
            });
        } else if v.white_user_id.as_str() == user_id && !v.white_connected {
            return Ok(Connection {
                game_id: game_id.to_owned(),
                color: Color::White,
                tx_broadcast: v.tx_broadcast.clone(),
            });
        }
        tracing::error!("connection not found in appstate");
        Err(Error::Unauthorized)
    })
}

async fn auth_socket(socket: &mut SplitStream<WebSocket>, state: &AppState) -> Result<Connection> {
    while let Some(Ok(Message::Text(text))) = socket.next().await {
        let client_msg: ClientMessage = match serde_json::from_str(text.as_str()) {
            Ok(msg) => msg,
            Err(_) => {
                tracing::error!("auth deserialization failed");
                return Err(Error::Deserialization);
            }
        };

        if let ClientMessage::Auth { game_id, user_id } = client_msg {
            // find active game in server's HashMap first
            match get_connection_from_map(state, &game_id, &user_id) {
                Some(conn) => return conn,

                // if not found, find from DB and add to HashMap
                None => {
                    let game_uuid = match Uuid::parse_str(&game_id) {
                        Ok(uuid) => uuid,
                        Err(_) => {
                            tracing::error!("Failed to parse GameID UUID");
                            return Err(Error::Unauthorized);
                        }
                    };

                    let row = sqlx::query!(
                        r#"SELECT GameID, Black, White FROM GameState WHERE GameId = $1 AND Status = 'On Going'"#,
                        game_uuid
                    )
                    .fetch_one(&state.pool)
                    .await;

                    match row {
                        Ok(row) => {
                            let _ = state
                                .active_games
                                .insert(game_id.clone(), ActiveGame::new(row.white, row.black));

                            tracing::info!("adding to app state");
                            return get_connection_from_map(state, &game_id, &user_id)
                                .expect("game should exist");
                        }
                        Err(_) => {
                            tracing::error!("auth row not found in DB");
                            return Err(Error::Unauthorized);
                        }
                    }
                }
            }
        }
    }

    tracing::error!("auth failed outside while let");
    Err(Error::Unauthorized)
}

async fn handle_socket_read(
    mut reader: SplitStream<WebSocket>,
    state: ActiveGameMap,
    connection: Arc<Connection>,
    #[allow(unused_variables)] tx_local: Sender<ServerMessage>,
) {
    while let Some(Ok(Message::Text(text))) = reader.next().await {
        let client_msg: ClientMessage = match serde_json::from_str(&text.to_string()) {
            Ok(msg) => msg,
            Err(_) => {
                let _ = tx_local
                    .send(ServerMessage::Error(Error::Deserialization))
                    .await;
                tracing::error!("deserialization failed");
                continue;
            }
        };

        if let ClientMessage::Move(san_str) = client_msg {
            // check if is current player turn
            if !state
                .read(&connection.game_id, |_, v| {
                    connection.color == v.board.turn()
                })
                .expect("game should exist")
            // game existence is validated from auth step
            {
                let _ = tx_local
                    .send(ServerMessage::Error(Error::InvalidTurn))
                    .await;
                tracing::error!("invalid turn");
                continue;
            }

            let san: San = match san_str.parse() {
                Ok(san) => san,
                Err(_) => {
                    let _ = tx_local
                        .send(ServerMessage::Error(Error::InvalidMove))
                        .await;
                    tracing::error!("invalid move");
                    continue;
                }
            };

            let m = match state
                .read(&connection.game_id, |_, v| san.to_move(&v.board))
                .expect("game should exist")
            {
                Ok(m) => m,
                Err(_) => {
                    let _ = tx_local
                        .send(ServerMessage::Error(Error::InvalidMove))
                        .await;
                    tracing::error!("invalid move");
                    continue;
                }
            };

            state
                .get(&connection.game_id)
                .expect("game should exist")
                .board
                .play_unchecked(&m); // move is already validated when calling `san.to_move`

            tracing::info!("broadcasting move {san_str}");
            connection
                .tx_broadcast
                .send(ServerMessage::Move(san_str.clone()))
                .unwrap();

            state
                .get(&connection.game_id)
                .expect("game should exist")
                .moves
                .push(san_str.clone());

            let outcome = state
                .read(&connection.game_id, |_, v| v.board.outcome())
                .expect("game should exist");

            if let Some(outcome) = outcome {
                connection
                    .tx_broadcast
                    .send(ServerMessage::GameEnd(outcome))
                    .unwrap();
                tracing::info!("game ended {} {}", connection.game_id, outcome);
            }
        }
    }
}

async fn handle_socket_write(
    mut writer: SplitSink<WebSocket, Message>,
    mut rx_broadcast: broadcast::Receiver<ServerMessage>,
    mut rx_local: Receiver<ServerMessage>,
) {
    loop {
        tokio::select! {
            Ok(msg) = rx_broadcast.recv() => {
                if send_msg(&mut writer, &msg).await
                    .is_err()
                {
                    tracing::error!("socket send failed");
                    break;
                }
                if msg.is_game_end() {
                    break;
                }
            }
            Some(msg) = rx_local.recv() => {
                if send_msg(&mut writer, &msg).await
                    .is_err()
                {
                    tracing::error!("socket send failed");
                    break;
                }
            }
        }
    }
}
</file>

<file path="matchmaking/src/main.rs">
use std::{
    collections::VecDeque,
    env,
    sync::{Arc, Mutex},
};

use axum::{
    http::{header, Method, StatusCode},
    routing::post,
    Json, Router,
};
use dotenvy::dotenv;
use serde::{Deserialize, Serialize};
use sqlx::{postgres::PgPoolOptions, Pool, Postgres};
use tokio::sync::{mpsc, oneshot};
use tower_http::cors::{AllowOrigin, CorsLayer};
use ts_rs::TS;

const MAX_CHANNEL_SIZE: usize = 4096;
const HOST: &'static str = "0.0.0.0:8001";

type ConcurrentQueue<T> = Arc<Mutex<VecDeque<T>>>;

struct AutoDrop {
    user_id: String,
    queue: ConcurrentQueue<MatchingPlayer>,
}

impl Drop for AutoDrop {
    fn drop(&mut self) {
        tracing::info!(
            "User {} closed connection, removing matching player record",
            self.user_id
        );
        self.queue
            .lock()
            .unwrap()
            .retain(|x| x.user_id != self.user_id)
    }
}

#[derive(Deserialize, TS)]
#[ts(export)]
pub struct MatchRequest {
    pub user_id: String,
}

#[derive(Serialize, Debug, TS)]
#[ts(export)]
pub enum Color {
    White,
    Black,
}

#[derive(Serialize, Debug, TS)]
#[serde(tag = "result", content = "value")]
#[ts(export)]
pub enum MatchResponse {
    Ok { game_id: String, color: Color },
    Err(String),
}

impl MatchResponse {
    pub fn is_err(&self) -> bool {
        match self {
            MatchResponse::Err(_) => true,
            _ => false,
        }
    }
}

pub struct MatchingPlayer {
    pub user_id: String,
    pub tx: oneshot::Sender<MatchResponse>,
}

async fn matcher(
    mut rx: mpsc::Receiver<()>,
    player_queue: ConcurrentQueue<MatchingPlayer>,
    pool: Pool<Postgres>,
) {
    while let Some(_) = rx.recv().await {
        loop {
            let (player1, player2) = {
                let mut queue = player_queue.lock().unwrap();
                if queue.len() < 2 {
                    break;
                }
                (
                    queue.pop_front().expect("Player should exist"),
                    queue.pop_front().expect("Player should exist"),
                )
            };

            let game_id = uuid::Uuid::new_v4();

            if let Err(e) = sqlx::query!(
                r#"INSERT INTO GameState (GameID, Black, White, PGN) VALUES ($1, $2, $3, '')"#,
                game_id,
                player2.user_id,
                player1.user_id
            )
            .execute(&pool)
            .await
            {
                let _ = player1.tx.send(MatchResponse::Err(
                    format!("DB insertion failed: {e}]").to_string(),
                ));
                let _ = player2.tx.send(MatchResponse::Err(
                    format!("DB insertion failed: {e}").to_string(),
                ));
                continue;
            }

            tracing::info!("Matched {} and {}", player1.user_id, player2.user_id);

            if let Err(_) = player1.tx.send(MatchResponse::Ok {
                game_id: game_id.to_string(),
                color: Color::White,
            }) {
                tracing::error!("Connection closed unexpectedly, proceeding anyway");
            }
            if let Err(_) = player2.tx.send(MatchResponse::Ok {
                game_id: game_id.to_string(),
                color: Color::Black,
            }) {
                tracing::error!("Connection closed unexpectedly, proceeding anyway");
            }
        }
    }
}

pub async fn post_match(
    notify_tx: mpsc::Sender<()>,
    player_queue: ConcurrentQueue<MatchingPlayer>,
    Json(body): Json<MatchRequest>,
) -> (StatusCode, Json<MatchResponse>) {
    let (res_tx, res_rx) = oneshot::channel();

    {
        let mut queue = player_queue.lock().unwrap();

        if queue.iter().any(|player| player.user_id == body.user_id) {
            tracing::error!("User {} already in queue", body.user_id);
            return (
                StatusCode::BAD_REQUEST,
                Json(MatchResponse::Err("Player already in queue".to_string())),
            );
        }

        queue.push_back(MatchingPlayer {
            user_id: body.user_id.clone(),
            tx: res_tx,
        });
    }

    tracing::info!("User {} requests a match", body.user_id);

    #[allow(unused_variables)]
    let auto_drop = AutoDrop {
        user_id: body.user_id.clone(),
        queue: player_queue.clone(),
    };

    notify_tx.send(()).await.unwrap();

    let res = res_rx.await.unwrap();
    if res.is_err() {
        (StatusCode::INTERNAL_SERVER_ERROR, Json(res))
    } else {
        (StatusCode::OK, Json(res))
    }
}

#[tokio::main]
async fn main() {
    tracing_subscriber::fmt::init();
    dotenv().ok();

    let (notify_tx, notify_rx) = mpsc::channel(MAX_CHANNEL_SIZE);

    let player_queue = Arc::new(Mutex::new(VecDeque::<MatchingPlayer>::new()));

    let pool = PgPoolOptions::new()
        .max_connections(5)
        .connect(&env::var("DATABASE_URL").expect("expecting DATABASE_URL in .env"))
        .await
        .unwrap();

    let cors = CorsLayer::new()
        .allow_origin(AllowOrigin::any())
        .allow_methods([Method::POST])
        .allow_headers([
            header::CONTENT_TYPE,
            header::ACCEPT,
            header::ORIGIN,
            header::AUTHORIZATION,
        ])
        .allow_credentials(false);

    let app = Router::new()
        .route(
            "/match",
            post({
                let cloned_queue = player_queue.clone();
                move |body| post_match(notify_tx, cloned_queue, body)
            }),
        )
        .layer(cors);

    tokio::spawn(matcher(notify_rx, player_queue.clone(), pool));

    let listener = tokio::net::TcpListener::bind(HOST).await.unwrap();
    tracing::info!("Running at {HOST}");
    axum::serve(listener, app).await.unwrap();
}
</file>

<file path="web/src/lib/socketService.ts">
import {
  ServerMessage,
  MoveCallback,
  ConnectCallback,
  ErrorCallback,
  HistoryCallback,
  GameEndCallback,
} from '@/types/shared';

let socketInstance: SocketService | null = null;

export class SocketService {
  private socket: WebSocket | null = null;
  private gameId: string = '';
  private userId: string = '';
  private onMoveCallback: MoveCallback | null = null;
  private onConnectCallback: ConnectCallback | null = null;
  private onErrorCallback: ErrorCallback | null = null;
  private onHistoryCallback: HistoryCallback | null = null;
  private onGameEndCallback: GameEndCallback | null = null;
  private authenticated: boolean = false;
  private connecting: boolean = false;
  private serverUrl: string;

  constructor(serverUrl?: string) {
    this.serverUrl =
      serverUrl ||
      process.env.NEXT_PUBLIC_WS_SERVER_URL ||
      'ws://localhost:8000/ws';
  }

  static getInstance(
    serverUrl: string = 'ws://localhost:8000/ws'
  ): SocketService {
    if (!socketInstance) {
      socketInstance = new SocketService(serverUrl);
    }
    return socketInstance;
  }

  static resetInstance(): void {
    if (socketInstance) {
      socketInstance.disconnect();
      socketInstance = null;
    }
  }

  connect(gameId: string, userId: string): void {
    if (
      this.isConnected() &&
      this.gameId === gameId &&
      this.userId === userId
    ) {
      console.log('Already connected to the same game');
      if (this.onConnectCallback) this.onConnectCallback();
      return;
    }

    this.gameId = gameId;
    this.userId = userId;
    this.authenticated = false;

    if (this.connecting) {
      console.log('Connection attempt already in progress');
      return;
    }

    this.createSocketConnection();
  }

  private createSocketConnection(): void {
    if (this.connecting) return;
    this.connecting = true;

    if (this.socket) {
      if (
        this.socket.readyState === WebSocket.OPEN ||
        this.socket.readyState === WebSocket.CONNECTING
      ) {
        this.socket.close();
      }
      this.socket = null;
    }

    try {
      console.log(`Creating socket connection to ${this.serverUrl}...`);
      this.socket = new WebSocket(this.serverUrl);

      this.socket.onopen = () => {
        console.log('WebSocket connection opened, authenticating...');
        this.connecting = false;
        this.authenticate();
      };

      this.socket.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data) as ServerMessage;
          console.log('Received message:', message);

          switch (message.kind) {
            case 'Move':
              if (this.onMoveCallback) this.onMoveCallback(message.value);
              break;
            case 'AuthSuccess':
              this.authenticated = true;
              if (this.onConnectCallback) this.onConnectCallback();
              console.log('Authentication successful');
              break;
            case 'MoveHistory':
              if (this.onHistoryCallback) this.onHistoryCallback(message.value);
              break;
            case 'GameEnd':
              if (this.onGameEndCallback) this.onGameEndCallback(message.value);
              break;
            case 'Error':
              console.error('Server error:', message.value);
              if (this.onErrorCallback)
                this.onErrorCallback(
                  typeof message.value === 'string'
                    ? message.value
                    : String(message.value)
                );
              break;
          }
        } catch (error) {
          console.error('Error parsing message:', error, event.data);
          if (this.onErrorCallback) {
            this.onErrorCallback('Failed to parse server message');
          }
        }
      };

      this.socket.onerror = (event) => {
        this.connecting = false;
        console.error('WebSocket error:', event);
        if (this.onErrorCallback) {
          this.onErrorCallback('Connection error occurred');
        }
      };

      this.socket.onclose = (event) => {
        this.connecting = false;
        this.authenticated = false;
        console.log(
          `WebSocket closed: ${event.code} ${
            event.reason || 'No reason provided'
          }`
        );

        if (this.onErrorCallback) {
          this.onErrorCallback(
            'Connection closed: ' + (event.reason || 'Unknown reason')
          );
        }
      };
    } catch (error) {
      this.connecting = false;
      console.error('Failed to create WebSocket:', error);
      if (this.onErrorCallback) {
        this.onErrorCallback('Failed to create connection: ' + String(error));
      }
    }
  }

  private authenticate(): void {
    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {
      console.error('Cannot authenticate: socket not open');
      return;
    }

    const authMsg = {
      kind: 'Auth',
      value: {
        game_id: this.gameId,
        user_id: this.userId,
      },
    };

    console.log('Sending auth message:', authMsg);
    this.socket.send(JSON.stringify(authMsg));
  }

  sendMove(move: string): void {
    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {
      console.error('Cannot send move: socket not open');
      if (this.onErrorCallback) {
        this.onErrorCallback('Cannot send move: connection not open');
      }
      return;
    }

    if (!this.authenticated) {
      console.error('Cannot send move: not authenticated');
      if (this.onErrorCallback) {
        this.onErrorCallback('Cannot send move: not authenticated');
      }
      return;
    }

    const moveMsg = {
      kind: 'Move',
      value: move,
    };

    console.log('Sending move:', moveMsg);
    this.socket.send(JSON.stringify(moveMsg));
  }

  onMove(callback: MoveCallback): void {
    this.onMoveCallback = callback;
  }

  onConnect(callback: ConnectCallback): void {
    this.onConnectCallback = callback;
    if (this.isConnected()) {
      callback();
    }
  }

  onError(callback: ErrorCallback): void {
    this.onErrorCallback = callback;
  }

  onHistory(callback: HistoryCallback): void {
    this.onHistoryCallback = callback;
  }

  onGameEnd(callback: GameEndCallback): void {
    this.onGameEndCallback = callback;

    if (callback) {
      this.onGameEndCallback = (outcome) => {
        callback(outcome);
      };
    }
  }

  disconnect(): void {
    if (this.socket) {
      if (
        this.socket.readyState === WebSocket.OPEN ||
        this.socket.readyState === WebSocket.CONNECTING
      ) {
        this.socket.close(1000, 'Disconnected by user');
      }
      this.socket = null;
    }

    this.authenticated = false;
    this.connecting = false;
  }

  isConnected(): boolean {
    return this.socket?.readyState === WebSocket.OPEN && this.authenticated;
  }
}
</file>

<file path="web/src/components/SocketGamePane.tsx">
import { useState, useEffect, useRef } from 'react';
import { Chess } from 'chess.js';
import type { Square } from 'chess.js';
import { Button } from '@/components/ui/button';
import { ChessBoard } from '@/components/ChessBoard';
import { Card, CardContent } from '@/components/ui/card';
import {
  ChevronDoubleLeftIcon,
  ChevronDoubleRightIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
  ChevronDownIcon,
  ChevronUpIcon,
  SignalIcon,
  SignalSlashIcon,
} from '@heroicons/react/24/outline';
import { Badge } from '@/components/ui/badge';
import { GameOutcome } from '@/types/shared';

interface GameProps {
  chess: Chess;
  fen: string;
  lastMove?: [Square, Square];
  selectVisible: boolean;
  pendingMove?: [Square, Square];
  previewIndex: number | null;
  previewFen: string | null;
  onMove: (from: Square, to: Square) => void;
  promotion: (piece: 'q' | 'r' | 'n' | 'b') => void;
  previewMove: (index: number) => void;
  handleFirstMove: () => void;
  handlePrevious: () => void;
  handleNext: () => void;
  handleLastMove: () => void;
  isConnected: boolean;
  gameId: string;
  playingAs: 'w' | 'b';
  gameOver?: boolean;
  gameOutcome?: GameOutcome | 'Draw';
  reconnect?: () => void;
}

interface PaneProps {
  playingAs: 'w' | 'b';
  gameProps: GameProps;
}

function getGameStatus(
  chess: Chess,
  gameOver?: boolean,
  gameOutcome?: GameOutcome | 'Draw'
): string {
  if (gameOver && gameOutcome) {
    if (gameOutcome === 'Draw') {
      return 'Game ended in a draw';
    } else if ('Decisive' in gameOutcome) {
      return gameOutcome.Decisive?.winner === 'White'
        ? 'White wins'
        : 'Black wins';
    } else {
      return 'Game ended';
    }
  }

  if (chess.isGameOver()) {
    if (chess.isCheckmate()) {
      const winner = chess.turn() === 'w' ? 'Black' : 'White';
      return `${winner} wins by checkmate`;
    }

    if (chess.isStalemate()) {
      return 'Draw by stalemate';
    }

    if (chess.isThreefoldRepetition()) {
      return 'Draw by repetition';
    }

    if (chess.isInsufficientMaterial()) {
      return 'Draw by insufficient material';
    }

    if (chess.isDrawByFiftyMoves()) {
      return 'Draw by fifty-move rule';
    }

    return 'Draw';
  }

  return 'Game in progress';
}

export default function SocketGamePane({ playingAs, gameProps }: PaneProps) {
  const {
    chess,
    fen,
    lastMove,
    selectVisible,
    previewIndex,
    previewFen,
    onMove,
    promotion,
    previewMove,
    handleFirstMove,
    handlePrevious,
    handleNext,
    handleLastMove,
    isConnected,
    gameId,
    gameOver,
    gameOutcome,
    reconnect,
  } = gameProps;

  const [pressedKeys, setPressedKeys] = useState<Set<string>>(new Set());
  const [showGameInfo, setShowGameInfo] = useState(false);
  const moveListRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (
      moveListRef.current &&
      chess.history().length > 0 &&
      previewIndex === null
    ) {
      moveListRef.current.scrollTop = moveListRef.current.scrollHeight;
    }
  }, [chess, previewIndex]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
        e.preventDefault();
        setPressedKeys((prev) => new Set(prev).add(e.key));
        if (e.key === 'ArrowLeft') handlePrevious();
        else if (e.key === 'ArrowRight') handleNext();
        else if (e.key === 'ArrowUp') handleFirstMove();
        else if (e.key === 'ArrowDown') handleLastMove();
      }
    };
    const handleKeyUp = (e: KeyboardEvent) => {
      if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
        setPressedKeys((prev) => {
          const updated = new Set(prev);
          updated.delete(e.key);
          return updated;
        });
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [handlePrevious, handleNext, handleFirstMove, handleLastMove]);

  const movePairs = [];
  const history = chess.history();
  for (let i = 0; i < history.length; i += 2) {
    movePairs.push({
      moveNumber: Math.floor(i / 2) + 1,
      whiteMove: history[i],
      blackMove: i + 1 < history.length ? history[i + 1] : undefined,
      whiteIndex: i,
      blackIndex: i + 1,
    });
  }

  const boardFen = previewFen ? previewFen : fen;
  const gameStatus = getGameStatus(chess, gameOver, gameOutcome);
  const turnColor = chess.turn();
  const isPlayerTurn = turnColor === playingAs;

  const toggleGameInfo = () => {
    setShowGameInfo(!showGameInfo);
  };

  const isPlayerWinner = () => {
    if (!gameOutcome) return false;

    if (gameOutcome === 'Draw') return false;

    if ('Decisive' in gameOutcome) {
      const winnerColor = gameOutcome.Decisive?.winner;
      return (
        (playingAs === 'w' && winnerColor === 'White') ||
        (playingAs === 'b' && winnerColor === 'Black')
      );
    }

    return false;
  };

  return (
    <Card className="w-full h-full bg-white/50 dark:bg-slate-800/50 backdrop-blur-sm border border-amber-200/50 dark:border-amber-800/30 shadow-md rounded-xl overflow-hidden">
      <CardContent className="p-4 md:p-6">
        <div className="md:hidden flex flex-col gap-4">
          <Card className="bg-white dark:bg-slate-700 border border-amber-200/50 dark:border-slate-600/50 shadow-none">
            <CardContent className="text-center">
              <div className="font-medium text-base text-amber-800 dark:text-amber-200">
                Player A (1600) - Player B (1600)
              </div>
              <div className="text-sm text-amber-600 dark:text-amber-300">
                {gameStatus}
              </div>
            </CardContent>
          </Card>
          <div className="w-full flex items-center justify-center">
            <div className="w-full max-w-lg">
              <ChessBoard
                fen={boardFen}
                onMove={onMove}
                lastMove={lastMove}
                playingAs={playingAs}
                selectVisible={selectVisible}
                promotion={promotion}
                previewIndex={previewIndex}
                chess={chess}
                viewOnly={gameOver || previewIndex !== null}
              />
            </div>
          </div>
          <div className="flex justify-center items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              data-key="ArrowUp"
              className={`w-10 h-10 p-1 bg-amber-600 hover:text-white hover:bg-amber-700 border-none text-white shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px] dark:bg-amber-500 dark:hover:bg-amber-600 dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f] ${
                pressedKeys.has('ArrowUp')
                  ? 'translate-y-[2px] shadow-none'
                  : ''
              }`}
              onClick={handleFirstMove}
              disabled={chess.history().length === 0}
              aria-label="First move"
            >
              <ChevronDoubleLeftIcon className="h-5 w-5" />
            </Button>
            <Button
              variant="outline"
              size="sm"
              data-key="ArrowLeft"
              className={`w-10 h-10 p-1 bg-amber-600 hover:text-white hover:bg-amber-700 border-none text-white shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px] dark:bg-amber-500 dark:hover:bg-amber-600 dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f] ${
                pressedKeys.has('ArrowLeft')
                  ? 'translate-y-[2px] shadow-none'
                  : ''
              }`}
              onClick={handlePrevious}
              disabled={previewIndex === 0 || chess.history().length === 0}
              aria-label="Previous move"
            >
              <ChevronLeftIcon className="h-5 w-5" />
            </Button>
            <Button
              variant="outline"
              size="sm"
              data-key="ArrowRight"
              className={`w-10 h-10 p-1 bg-amber-600 hover:text-white hover:bg-amber-700 border-none text-white shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px] dark:bg-amber-500 dark:hover:bg-amber-600 dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f] ${
                pressedKeys.has('ArrowRight')
                  ? 'translate-y-[2px] shadow-none'
                  : ''
              }`}
              onClick={handleNext}
              disabled={previewIndex === null || chess.history().length === 0}
              aria-label="Next move"
            >
              <ChevronRightIcon className="h-5 w-5" />
            </Button>
            <Button
              variant="outline"
              size="sm"
              data-key="ArrowDown"
              className={`w-10 h-10 p-1 bg-amber-600 hover:text-white hover:bg-amber-700 border-none text-white shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px] dark:bg-amber-500 dark:hover:bg-amber-600 dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f] ${
                pressedKeys.has('ArrowDown')
                  ? 'translate-y-[2px] shadow-none'
                  : ''
              }`}
              onClick={handleLastMove}
              disabled={previewIndex === null}
              aria-label="Last move"
            >
              <ChevronDoubleRightIcon className="h-5 w-5" />
            </Button>
          </div>
          <div className="bg-amber-50 dark:bg-slate-800 rounded-lg border border-amber-200/50 dark:border-amber-800/30 overflow-hidden shadow-md flex flex-col h-[300px]">
            <div
              ref={moveListRef}
              className="overflow-y-auto flex-grow max-h-[300px] px-4 font-mono text-sm"
            >
              <div className="pt-2" />
              <table className="w-full table-fixed">
                <thead className="text-left text-amber-700 dark:text-amber-300 border-b border-amber-200/50 dark:border-amber-700/30 sticky top-0 bg-amber-50 dark:bg-slate-800">
                  <tr>
                    <th className="w-10 py-2">#</th>
                    <th className="w-1/2 py-2">White</th>
                    <th className="w-1/2 py-2">Black</th>
                  </tr>
                </thead>
                <tbody>
                  {movePairs.length > 0 ? (
                    movePairs.map((move) => (
                      <tr
                        key={move.moveNumber}
                        className="hover:bg-amber-50 dark:hover:bg-amber-900/20"
                      >
                        <td className="py-1 text-amber-600 dark:text-amber-400">
                          {move.moveNumber}.
                        </td>
                        <td className="py-1">
                          {move.whiteMove && (
                            <button
                              className={`font-semibold text-amber-800 dark:text-amber-200 ${
                                previewIndex === move.whiteIndex
                                  ? 'bg-amber-100 dark:bg-amber-900/30 px-2 py-0.5 rounded'
                                  : 'hover:bg-amber-100/50 dark:hover:bg-amber-900/20 px-2 py-0.5 rounded'
                              }`}
                              onClick={() => previewMove(move.whiteIndex)}
                            >
                              {move.whiteMove}
                            </button>
                          )}
                        </td>
                        <td className="py-1">
                          {move.blackMove && (
                            <button
                              className={`font-semibold text-amber-800 dark:text-amber-200 ${
                                previewIndex === move.blackIndex
                                  ? 'bg-amber-100 dark:bg-amber-900/30 px-2 py-0.5 rounded'
                                  : 'hover:bg-amber-100/50 dark:hover:bg-amber-900/20 px-2 py-0.5 rounded'
                              }`}
                              onClick={() => previewMove(move.blackIndex)}
                            >
                              {move.blackMove}
                            </button>
                          )}
                        </td>
                      </tr>
                    ))
                  ) : (
                    <tr>
                      <td
                        colSpan={3}
                        className="text-center text-amber-500 dark:text-amber-400 py-4"
                      >
                        No moves yet
                      </td>
                    </tr>
                  )}
                </tbody>
              </table>
            </div>
          </div>
          <Card
            className="bg-white dark:bg-slate-700 border border-amber-200/50 dark:border-slate-600/50 shadow-none cursor-pointer py-4"
            onClick={toggleGameInfo}
          >
            <CardContent className="px-4 py-0 transition-all">
              <div className="flex justify-between items-center">
                <div className="flex items-center gap-2">
                  <span className="font-medium text-amber-800 dark:text-amber-200">
                    Game Info
                  </span>
                  <Badge
                    variant={isConnected ? 'default' : 'destructive'}
                    className={`${
                      isConnected ? 'bg-green-600' : 'bg-red-600'
                    } text-white flex items-center gap-1`}
                  >
                    {isConnected ? (
                      <SignalIcon className="h-3 w-3" />
                    ) : (
                      <SignalSlashIcon className="h-3 w-3" />
                    )}
                  </Badge>
                </div>
                {showGameInfo ? (
                  <ChevronUpIcon className="h-4 w-4 text-amber-600 dark:text-amber-400" />
                ) : (
                  <ChevronDownIcon className="h-4 w-4 text-amber-600 dark:text-amber-400" />
                )}
              </div>
              {showGameInfo && (
                <div className="mt-3 pt-3 border-t border-amber-200/30 dark:border-slate-700/30">
                  <div className="flex justify-between items-center mb-2">
                    <div className="text-sm text-amber-600 dark:text-amber-300">
                      Game ID: <span className="font-medium">{gameId}</span>
                    </div>
                    {!isConnected && reconnect && (
                      <Button
                        size="sm"
                        className="h-7 text-xs bg-amber-600"
                        onClick={(e) => {
                          e.stopPropagation();
                          reconnect();
                        }}
                      >
                        Reconnect
                      </Button>
                    )}
                  </div>
                  <div className="flex justify-between items-center mb-2">
                    <div className="text-sm text-amber-600 dark:text-amber-300">
                      Playing as:{' '}
                      <span className="font-medium">
                        {playingAs === 'w' ? 'White' : 'Black'}
                      </span>
                    </div>
                    {!gameOver && isConnected && (
                      <div className="text-sm font-medium">
                        {isPlayerTurn ? (
                          <span className="text-green-600 dark:text-green-400">
                            Your turn
                          </span>
                        ) : (
                          <span className="text-amber-600 dark:text-amber-400">
                            Opponent&apos;s turn
                          </span>
                        )}
                      </div>
                    )}
                  </div>
                  <div className="mb-2 text-sm font-medium">
                    {gameOver ? (
                      gameOutcome === 'Draw' ? (
                        <span className="text-amber-700 dark:text-amber-300">
                          {gameStatus}
                        </span>
                      ) : isPlayerWinner() ? (
                        <span className="text-green-600 dark:text-green-400">
                          {gameStatus}
                        </span>
                      ) : (
                        <span className="text-red-600 dark:text-red-400">
                          {gameStatus}
                        </span>
                      )
                    ) : (
                      <span className="text-amber-700 dark:text-amber-300">
                        {gameStatus}
                      </span>
                    )}
                  </div>
                </div>
              )}
            </CardContent>
          </Card>
        </div>
        <div className="hidden md:flex md:flex-col md:flex-row gap-6">
          <div className="w-full md:w-1/2 flex flex-center items-center justify-center min-h-full">
            <div className="w-full max-w-lg">
              <ChessBoard
                fen={boardFen}
                onMove={onMove}
                lastMove={lastMove}
                playingAs={playingAs}
                selectVisible={selectVisible}
                promotion={promotion}
                previewIndex={previewIndex}
                chess={chess}
                viewOnly={gameOver || previewIndex !== null}
              />
            </div>
          </div>
          <div className="w-full md:w-1/2 flex flex-col gap-4">
            <Card className="bg-white dark:bg-slate-700 border border-amber-200/50 dark:border-slate-600/50 shadow-none">
              <CardContent className="text-center">
                <div className="font-medium text-base text-amber-800 dark:text-amber-200">
                  Player A (1600) - Player B (1600)
                </div>
                <div className="text-sm text-amber-600 dark:text-amber-300">
                  {gameStatus}
                </div>
              </CardContent>
            </Card>
            <div className="flex-1 bg-amber-50 dark:bg-slate-800 rounded-lg border border-amber-200/50 dark:border-amber-800/30 overflow-hidden shadow-md flex flex-col h-[400px]">
              <div
                ref={moveListRef}
                className="overflow-y-auto flex-grow max-h-[365px] px-4 font-mono text-sm"
              >
                <div className="pt-2" />
                <table className="w-full table-fixed">
                  <thead className="text-left text-amber-700 dark:text-amber-300 border-b border-amber-200/50 dark:border-amber-700/30 sticky top-0 bg-amber-50 dark:bg-slate-800">
                    <tr>
                      <th className="w-10 py-2">#</th>
                      <th className="w-1/2 py-2">White</th>
                      <th className="w-1/2 py-2">Black</th>
                    </tr>
                  </thead>
                  <tbody>
                    {movePairs.length > 0 ? (
                      movePairs.map((move) => (
                        <tr
                          key={move.moveNumber}
                          className="hover:bg-amber-50 dark:hover:bg-amber-900/20"
                        >
                          <td className="py-1 text-amber-600 dark:text-amber-400">
                            {move.moveNumber}.
                          </td>
                          <td className="py-1">
                            {move.whiteMove && (
                              <button
                                className={`font-semibold text-amber-800 dark:text-amber-200 ${
                                  previewIndex === move.whiteIndex
                                    ? 'bg-amber-100 dark:bg-amber-900/30 px-2 py-0.5 rounded'
                                    : 'hover:bg-amber-100/50 dark:hover:bg-amber-900/20 px-2 py-0.5 rounded'
                                }`}
                                onClick={() => previewMove(move.whiteIndex)}
                              >
                                {move.whiteMove}
                              </button>
                            )}
                          </td>
                          <td className="py-1">
                            {move.blackMove && (
                              <button
                                className={`font-semibold text-amber-800 dark:text-amber-200 ${
                                  previewIndex === move.blackIndex
                                    ? 'bg-amber-100 dark:bg-amber-900/30 px-2 py-0.5 rounded'
                                    : 'hover:bg-amber-100/50 dark:hover:bg-amber-900/20 px-2 py-0.5 rounded'
                                }`}
                                onClick={() => previewMove(move.blackIndex)}
                              >
                                {move.blackMove}
                              </button>
                            )}
                          </td>
                        </tr>
                      ))
                    ) : (
                      <tr>
                        <td
                          colSpan={3}
                          className="text-center text-amber-500 dark:text-amber-400 py-4"
                        >
                          No moves yet
                        </td>
                      </tr>
                    )}
                  </tbody>
                </table>
              </div>
              <div className="border-t border-amber-200/50 dark:border-amber-700/30 mt-auto px-4 py-2">
                <div className="flex justify-center items-center gap-2 my-2">
                  <Button
                    variant="outline"
                    size="sm"
                    data-key="ArrowUp"
                    className={`w-10 h-10 p-1 bg-amber-600 hover:text-white hover:bg-amber-700 border-none text-white shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px] dark:bg-amber-500 dark:hover:bg-amber-600 dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f] ${
                      pressedKeys.has('ArrowUp')
                        ? 'translate-y-[2px] shadow-none'
                        : ''
                    }`}
                    onClick={handleFirstMove}
                    disabled={chess.history().length === 0}
                    aria-label="First move"
                  >
                    <ChevronDoubleLeftIcon className="h-5 w-5" />
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    data-key="ArrowLeft"
                    className={`w-10 h-10 p-1 bg-amber-600 hover:text-white hover:bg-amber-700 border-none text-white shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px] dark:bg-amber-500 dark:hover:bg-amber-600 dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f] ${
                      pressedKeys.has('ArrowLeft')
                        ? 'translate-y-[2px] shadow-none'
                        : ''
                    }`}
                    onClick={handlePrevious}
                    disabled={
                      previewIndex === 0 || chess.history().length === 0
                    }
                    aria-label="Previous move"
                  >
                    <ChevronLeftIcon className="h-5 w-5" />
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    data-key="ArrowRight"
                    className={`w-10 h-10 p-1 bg-amber-600 hover:text-white hover:bg-amber-700 border-none text-white shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px] dark:bg-amber-500 dark:hover:bg-amber-600 dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f] ${
                      pressedKeys.has('ArrowRight')
                        ? 'translate-y-[2px] shadow-none'
                        : ''
                    }`}
                    onClick={handleNext}
                    disabled={
                      previewIndex === null || chess.history().length === 0
                    }
                    aria-label="Next move"
                  >
                    <ChevronRightIcon className="h-5 w-5" />
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    data-key="ArrowDown"
                    className={`w-10 h-10 p-1 bg-amber-600 hover:text-white hover:bg-amber-700 border-none text-white shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px] dark:bg-amber-500 dark:hover:bg-amber-600 dark:shadow-[0_3px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f] ${
                      pressedKeys.has('ArrowDown')
                        ? 'translate-y-[2px] shadow-none'
                        : ''
                    }`}
                    onClick={handleLastMove}
                    disabled={previewIndex === null}
                    aria-label="Last move"
                  >
                    <ChevronDoubleRightIcon className="h-5 w-5" />
                  </Button>
                </div>
              </div>
            </div>
            <Card
              className="bg-white dark:bg-slate-700 border border-amber-200/50 dark:border-slate-600/50 shadow-none cursor-pointer py-4"
              onClick={toggleGameInfo}
            >
              <CardContent className="py-0 px-4 transition-all">
                <div className="flex justify-between items-center">
                  <div className="flex items-center gap-2">
                    <span className="font-medium text-amber-800 dark:text-amber-200">
                      Game Info
                    </span>
                    <Badge
                      variant={isConnected ? 'default' : 'destructive'}
                      className={`${
                        isConnected ? 'bg-green-600' : 'bg-red-600'
                      } text-white flex items-center gap-1`}
                    >
                      {isConnected ? (
                        <SignalIcon className="h-3 w-3" />
                      ) : (
                        <SignalSlashIcon className="h-3 w-3" />
                      )}
                    </Badge>
                  </div>
                  {showGameInfo ? (
                    <ChevronUpIcon className="h-4 w-4 text-amber-600 dark:text-amber-400" />
                  ) : (
                    <ChevronDownIcon className="h-4 w-4 text-amber-600 dark:text-amber-400" />
                  )}
                </div>
                {showGameInfo && (
                  <div className="mt-3 pt-3 border-t border-amber-200/30 dark:border-slate-700/30">
                    <div className="flex justify-between items-center mb-2">
                      <div className="text-sm text-amber-600 dark:text-amber-300">
                        Game ID: <span className="font-medium">{gameId}</span>
                      </div>
                      {!isConnected && reconnect && (
                        <Button
                          size="sm"
                          className="h-7 text-xs bg-amber-600"
                          onClick={(e) => {
                            e.stopPropagation();
                            reconnect();
                          }}
                        >
                          Reconnect
                        </Button>
                      )}
                    </div>
                    <div className="flex justify-between items-center mb-2">
                      <div className="text-sm text-amber-600 dark:text-amber-300">
                        Playing as:{' '}
                        <span className="font-medium">
                          {playingAs === 'w' ? 'White' : 'Black'}
                        </span>
                      </div>
                      {!gameOver && isConnected && (
                        <div className="text-sm font-medium">
                          {isPlayerTurn ? (
                            <span className="text-green-600 dark:text-green-400">
                              Your turn
                            </span>
                          ) : (
                            <span className="text-amber-600 dark:text-amber-400">
                              Opponent&apos;s turn
                            </span>
                          )}
                        </div>
                      )}
                    </div>
                    <div className="mb-2 text-sm font-medium">
                      {gameOver ? (
                        gameOutcome === 'Draw' ? (
                          <span className="text-amber-700 dark:text-amber-300">
                            {gameStatus}
                          </span>
                        ) : isPlayerWinner() ? (
                          <span className="text-green-600 dark:text-green-400">
                            {gameStatus}
                          </span>
                        ) : (
                          <span className="text-red-600 dark:text-red-400">
                            {gameStatus}
                          </span>
                        )
                      ) : (
                        <span className="text-amber-700 dark:text-amber-300">
                          {gameStatus}
                        </span>
                      )}
                    </div>
                  </div>
                )}
              </CardContent>
            </Card>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="web/src/app/computer/page.tsx">
'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import { Chess } from 'chess.js';
import type { Square } from 'chess.js';
import ComputerGamePane from '@/components/ComputerGamePane';
import UnauthorizedPage from '@/components/Unauthorized';
import ErrorPage from '@/components/Error';
import { toast } from 'sonner';
import { testEngine, getBestMove } from '@/lib/engine';
import {
  updateGamePgn,
  updateGameStatus,
  getGame,
} from '@/app/actions/gameActions';
import { getUserInfo } from '@/lib/auth/googleAuth';
import { GameStatus } from '@prisma/client';
import { useSearchParams } from 'next/navigation';

export default function ComputerGame() {
  const searchParams = useSearchParams();
  const gameId = searchParams.get('game_id');
  const colorParam = searchParams.get('color');

  const [chess] = useState(new Chess());
  const [fen, setFen] = useState(chess.fen());
  const [lastMove, setLastMove] = useState<[Square, Square]>();
  const [selectVisible, setSelectVisible] = useState(false);
  const [pendingMove, setPendingMove] = useState<[Square, Square]>();
  const [previewIndex, setPreviewIndex] = useState<number | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [gameOver, setGameOver] = useState(false);
  const [engineStatus, setEngineStatus] = useState<
    'connected' | 'degraded' | 'disconnected' | 'pending'
  >('pending');
  const [isThinking, setIsThinking] = useState(false);
  const [isAuthorized, setIsAuthorized] = useState(false);
  const [hasError, setHasError] = useState(false);
  const [isLoading, setIsLoading] = useState(true);

  const moveHistory = useRef<string[]>([]);
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);
  const lastSuccessRef = useRef<number | null>(null);

  const userInfo = getUserInfo();
  const username = userInfo?.email?.split('@')[0] || 'anonymous';

  const playingAs: 'w' | 'b' = colorParam === 'b' ? 'b' : 'w';

  useEffect(() => {
    if (!gameId) {
      toast.error('No game ID provided');
      setIsLoading(false);
      return;
    }

    if (colorParam !== 'w' && colorParam !== 'b') {
      toast.error('Invalid color parameter');
      setIsLoading(false);
      return;
    }

    const initializeGame = async () => {
      try {
        const gameResult = await getGame(gameId);

        if (!gameResult.success || !gameResult.game) {
          toast.error('Failed to load game');
          setHasError(true);
          setIsLoading(false);
          return;
        }

        const game = gameResult.game;
        const userIsWhite = game.white === username;
        const userIsBlack = game.black === username;
        const computerIsWhite = game.white === 'computer';
        const computerIsBlack = game.black === 'computer';

        const isAuthorizedPlayer =
          (colorParam === 'w' && userIsWhite && computerIsBlack) ||
          (colorParam === 'b' && userIsBlack && computerIsWhite);

        if (!isAuthorizedPlayer) {
          toast.error('You are not authorized to play this game');
          setIsAuthorized(false);
          setIsLoading(false);
          return;
        }

        setIsAuthorized(true);

        if (game.pgn) {
          try {
            chess.loadPgn(game.pgn);
            moveHistory.current = chess.history();

            const history = chess.history({ verbose: true });
            if (history.length > 0) {
              const last = history[history.length - 1];
              setLastMove([last.from as Square, last.to as Square]);
            }

            setFen(chess.fen());
          } catch (err) {
            setHasError(true);
            setIsLoading(false);
            console.error('Error: ', err);
            return;
          }
        }

        if (game.status !== 'ONGOING') {
          setGameOver(true);
        }

        setIsLoading(false);
      } catch (error) {
        toast.error('Error loading game');
        console.error(error);
        setHasError(true);
        setIsLoading(false);
      }
    };

    initializeGame();
  }, [gameId, colorParam, username, chess]);

  useEffect(() => {
    const updateStatusByAge = () => {
      const last = lastSuccessRef.current;
      if (last === null) {
        setEngineStatus('disconnected');
        setError('Failed to connect to chess engine');
        toast.error('Engine connection failed', {
          description: 'Unable to connect to the chess engine',
        });
        return;
      }
      const age = Date.now() - last;
      if (age >= 60000) {
        setEngineStatus('disconnected');
        setError('Chess engine unreachable (timeout)');
        toast.error('Engine disconnected', {
          description: 'No response from engine for over 60 s',
        });
      } else if (age >= 30000) {
        if (engineStatus !== 'degraded') {
          setEngineStatus('degraded');
          setError('Engine connection degraded');
          toast.warning('Engine connection degraded', {
            description: 'Responses taking too long',
          });
        }
      } else {
        if (engineStatus !== 'connected') {
          setEngineStatus('connected');
          setError(null);
          toast.success('Engine reconnected');
        }
      }
    };

    const ping = async () => {
      try {
        const res = await testEngine();
        if (res.status === 'success') {
          lastSuccessRef.current = Date.now();
          setError(null);
          setEngineStatus('connected');
        } else {
          if (lastSuccessRef.current === null)
            lastSuccessRef.current = Date.now();
          updateStatusByAge();
        }
      } catch {
        updateStatusByAge();
      }
    };

    ping();
    const id = setInterval(ping, 5000);
    return () => clearInterval(id);
  }, [engineStatus]);

  useEffect(() => {
    if (error) toast.error(error);
  }, [error]);

  const updateState = useCallback(() => {
    setFen(chess.fen());

    if (gameId) {
      const pgn = chess.pgn();
      updateGamePgn(gameId, pgn).catch(() => {});
    }

    const ended = chess.isGameOver();
    setGameOver((prev) => prev || ended);

    if (ended && gameId) {
      let status: GameStatus = 'ONGOING';

      if (chess.isCheckmate()) {
        status = chess.turn() === 'w' ? 'BLACK_WINS' : 'WHITE_WINS';
      } else if (chess.isDraw()) {
        status = 'DRAW';
      }

      if (status !== 'ONGOING')
        updateGameStatus(gameId, status).catch(() => {});
    }
  }, [chess, gameId]);

  const makeComputerMove = useCallback(async () => {
    if (gameOver || chess.turn() === playingAs || isThinking) return;
    setIsThinking(true);
    try {
      const { best_move } = await getBestMove(chess.fen());
      if (best_move) {
        const from = best_move.slice(0, 2) as Square;
        const to = best_move.slice(2, 4) as Square;
        const promotion =
          best_move.length > 4
            ? (best_move[4] as 'q' | 'r' | 'n' | 'b')
            : undefined;
        const m = chess.move({ from, to, promotion });
        if (m) {
          setLastMove([from, to]);
          moveHistory.current.push(m.san);
          updateState();
        }
      }
    } catch {
      setEngineStatus('degraded');
      toast.error('Engine move failed', {
        description: 'Could not get best move from engine',
      });
    } finally {
      setIsThinking(false);
    }
  }, [chess, gameOver, playingAs, isThinking, updateState]);

  const onMove = useCallback(
    (from: Square, to: Square) => {
      if (previewIndex !== null) {
        setPreviewIndex(null);
        return;
      }
      if (chess.turn() !== playingAs || gameOver || isThinking) return;
      const moves = chess.moves({ verbose: true });
      const mv = moves.find((m) => m.from === from && m.to === to);
      if (!mv) return;
      if (mv.promotion) {
        setPendingMove([from, to]);
        setSelectVisible(true);
      } else {
        const m = chess.move({ from, to });
        if (m) {
          setLastMove([from, to]);
          moveHistory.current.push(m.san);
          updateState();
          timeoutRef.current = setTimeout(makeComputerMove, 500);
        }
      }
    },
    [
      chess,
      previewIndex,
      updateState,
      playingAs,
      gameOver,
      isThinking,
      makeComputerMove,
    ]
  );

  const promotion = useCallback(
    (p: 'q' | 'r' | 'n' | 'b') => {
      if (!pendingMove) return;
      const [from, to] = pendingMove;
      const m = chess.move({ from, to, promotion: p });
      if (m) {
        setLastMove([from, to]);
        moveHistory.current.push(m.san);
        setSelectVisible(false);
        updateState();
        timeoutRef.current = setTimeout(makeComputerMove, 500);
      }
    },
    [chess, pendingMove, updateState, makeComputerMove]
  );

  useEffect(() => {
    if (!isLoading && isAuthorized && playingAs === 'b') {
      makeComputerMove();
    }
  }, [isLoading, isAuthorized, playingAs, makeComputerMove]);

  const previewMove = useCallback((i: number) => {
    setPreviewIndex(i >= moveHistory.current.length ? null : i);
  }, []);

  const handleFirstMove = useCallback(() => {
    if (moveHistory.current.length) setPreviewIndex(0);
  }, []);

  const handlePrevious = useCallback(() => {
    if (previewIndex === null) {
      if (moveHistory.current.length)
        setPreviewIndex(moveHistory.current.length - 2);
    } else if (previewIndex > 0) {
      setPreviewIndex(previewIndex - 1);
    }
  }, [previewIndex]);

  const handleNext = useCallback(() => {
    if (previewIndex === null) return;
    if (previewIndex < moveHistory.current.length - 1)
      setPreviewIndex(previewIndex + 1);
    else setPreviewIndex(null);
  }, [previewIndex]);

  const handleLastMove = useCallback(() => setPreviewIndex(null), []);

  const calcPreviewFen = useCallback(() => {
    if (previewIndex === null) return null;
    const tmp = new Chess();
    const hist = chess.history({ verbose: true });
    for (let i = 0; i <= previewIndex && i < hist.length; i++)
      tmp.move(hist[i].san);
    return tmp.fen();
  }, [previewIndex, chess]);

  const handleTakeBack = useCallback(() => {
    if (previewIndex !== null) {
      setPreviewIndex(null);
      return;
    }
    if (gameOver || moveHistory.current.length < 2) return;
    chess.undo();
    chess.undo();
    moveHistory.current.pop();
    moveHistory.current.pop();
    const h = chess.history({ verbose: true });
    if (h.length) {
      const last = h[h.length - 1];
      setLastMove([last.from as Square, last.to as Square]);
    } else {
      setLastMove(undefined);
    }
    updateState();
  }, [chess, gameOver, updateState, previewIndex]);

  const handleResign = useCallback(() => {
    if (gameOver) return;
    setGameOver(true);

    if (gameId) {
      const status: GameStatus =
        playingAs === 'w' ? 'BLACK_WINS' : 'WHITE_WINS';
      updateGameStatus(gameId, status).catch(() => {});
    }

    toast.info('Game ended', { description: 'You resigned the game' });
  }, [gameOver, gameId, playingAs]);

  const handleAbort = useCallback(() => {
    if (gameOver) return;
    setGameOver(true);

    if (gameId) {
      updateGameStatus(gameId, 'ABORTED').catch(() => {});
    }

    toast.info('Game aborted', { description: 'This game has been aborted' });
  }, [gameOver, gameId]);

  const handleRetry = useCallback(() => {
    if (engineStatus !== 'disconnected') return;
    setIsLoading(true);
    testEngine()
      .then((res) => {
        if (res.status === 'success') {
          setEngineStatus('connected');
          setError(null);
          toast.success('Engine connection restored');
        } else {
          setEngineStatus('degraded');
          setError('Engine connection degraded');
          toast.warning('Engine connection degraded');
        }
      })
      .catch(() => {
        setEngineStatus('disconnected');
        setError('Failed to connect to chess engine');
        toast.error('Engine connection failed');
      })
      .finally(() => setIsLoading(false));
  }, [engineStatus]);

  const gameProps = {
    chess,
    fen,
    lastMove,
    selectVisible,
    pendingMove,
    previewIndex,
    previewFen: calcPreviewFen(),
    onMove,
    promotion,
    previewMove,
    handleFirstMove,
    handlePrevious,
    handleNext,
    handleLastMove,
    playingAs,
    gameOver,
    engineStatus,
    isThinking,
    handleTakeBack,
    handleResign,
    handleRetry,
    handleAbort,
  };

  if (isLoading) {
    return null;
  }

  if (hasError) {
    return (
      <ErrorPage message="There was a problem loading this game" code="500" />
    );
  }

  if (!isAuthorized) {
    return <UnauthorizedPage />;
  }

  return (
    <div className="mx-auto px-4 sm:px-6 lg:px-8 py-8 max-w-7xl">
      <ComputerGamePane playingAs={playingAs} gameProps={gameProps} />
    </div>
  );
}
</file>

<file path="web/src/app/socket/page.tsx">
'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import { Chess } from 'chess.js';
import type { Square } from 'chess.js';
import SocketGamePane from '@/components/SocketGamePane';
import { SocketService } from '@/lib/socketService';
import LoadingScreen from '@/components/LoadingScreen';
import { toast } from 'sonner';
import { GameOutcome } from '@/types/shared';
import { getUserInfo } from '@/lib/auth/googleAuth';
import {
  updateGamePgn,
  updateGameStatus,
  getGame,
} from '@/app/actions/gameActions';
import { GameStatus } from '@prisma/client';
import ErrorPage from '@/components/Error';
import UnauthorizedPage from '@/components/Unauthorized';
import { useSearchParams } from 'next/navigation';

export default function SocketGame() {
  const [chess] = useState(new Chess());
  const [fen, setFen] = useState(chess.fen());
  const [lastMove, setLastMove] = useState<[Square, Square] | undefined>();
  const [selectVisible, setSelectVisible] = useState(false);
  const [pendingMove, setPendingMove] = useState<
    [Square, Square] | undefined
  >();
  const [previewIndex, setPreviewIndex] = useState<number | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [gameOver, setGameOver] = useState(false);
  const [gameOutcome, setGameOutcome] = useState<
    GameOutcome | 'Draw' | undefined
  >(undefined);
  const [isAuthorized, setIsAuthorized] = useState(false);
  const [hasError, setHasError] = useState(false);

  const lastLocalMoveRef = useRef<string | null>(null);

  const searchParams = useSearchParams();
  const gameId = searchParams.get('game_id') || '';
  const roleParam = searchParams.get('playas');
  const playingAs: 'w' | 'b' =
    roleParam === 'w' || roleParam === 'b' ? (roleParam as 'w' | 'b') : 'w';

  useEffect(() => {
    if (error) {
      if (gameOutcome !== undefined) {
        toast.success('Server closed, Game Completed');
      } else {
        toast.error(error);
      }
    }
  }, [error, gameOutcome]);

  const userInfo = getUserInfo();
  const userId = userInfo?.email?.split('@')[0] || 'anonymous';

  const updateState = useCallback(() => {
    setFen(chess.fen());

    if (gameId) {
      const pgn = chess.pgn();
      updateGamePgn(gameId, pgn).catch((err) => {
        console.error('Failed to update game PGN:', err);
      });
    }

    if (chess.isGameOver() || chess.isDraw()) {
      setGameOver(true);

      let status: GameStatus = 'ONGOING';

      if (chess.isCheckmate()) {
        const winner = chess.turn() === 'w' ? 'b' : 'w';
        if (winner === 'w') {
          setGameOutcome({ Decisive: { winner: 'White' } });
          status = 'WHITE_WINS';
        } else {
          setGameOutcome({ Decisive: { winner: 'Black' } });
          status = 'BLACK_WINS';
        }
      } else if (chess.isDraw()) {
        setGameOutcome('Draw');
        status = 'DRAW';
      }

      if (status !== 'ONGOING' && gameId) {
        updateGameStatus(gameId, status).catch((err) => {
          console.error('Failed to update game status:', err);
        });
      }
    }
  }, [chess, gameId]);

  useEffect(() => {
    if (!gameId) {
      setIsLoading(false);
      setError('No game ID provided');
      return;
    }

    const initializeGame = async () => {
      try {
        const gameResult = await getGame(gameId);

        if (!gameResult.success || !gameResult.game) {
          console.error('Failed to load game data:', gameResult.error);
          toast.error('Failed to load game');
          setIsAuthorized(false);
          setIsLoading(false);
          setHasError(true);
          return;
        }

        const game = gameResult.game;
        const userIsWhite = game.white === userId;
        const userIsBlack = game.black === userId;

        const isAuthorizedPlayer =
          (playingAs === 'w' && userIsWhite) ||
          (playingAs === 'b' && userIsBlack);

        if (!isAuthorizedPlayer) {
          toast.error('You are not authorized to play this game');
          setIsAuthorized(false);
          setIsLoading(false);
          return;
        }

        setIsAuthorized(true);

        if (game.pgn) {
          try {
            const movesOnly = game.pgn
              .replace(/^(\[.*\][\r\n]*)*/gm, '')
              .trim();
            chess.loadPgn(movesOnly);
            const history = chess.history({ verbose: true });
            if (history.length > 0) {
              const last = history[history.length - 1];
              setLastMove([last.from as Square, last.to as Square]);
            }
            setFen(chess.fen());
          } catch (err) {
            console.error('Error loading PGN:', err);
            setHasError(true);
            return;
          }
        }

        if (game.status !== 'ONGOING') {
          setGameOver(true);

          if (game.status === 'WHITE_WINS') {
            setGameOutcome({ Decisive: { winner: 'White' } });
          } else if (game.status === 'BLACK_WINS') {
            setGameOutcome({ Decisive: { winner: 'Black' } });
          } else if (game.status === 'DRAW') {
            setGameOutcome('Draw');
          }
        }
      } catch (err) {
        console.error('Error initializing game:', err);
        toast.error('Error loading game');
        setHasError(true);
      }

      const socketService = SocketService.getInstance();
      let retries = 0;
      const maxRetries = 3;
      const retryDelay = 5000;

      socketService.onConnect(() => {
        setIsConnected(true);
        setIsLoading(false);
        setError(null);
      });

      socketService.onMove((moveStr) => {
        if (lastLocalMoveRef.current === moveStr) {
          lastLocalMoveRef.current = null;
          return;
        }
        try {
          const move = chess.move(moveStr);
          if (move) {
            setLastMove([move.from as Square, move.to as Square]);
            updateState();
          }
        } catch (error) {
          console.error('Invalid move received from socket:', error);
        }
      });

      socketService.onHistory((moves) => {
        chess.reset();
        moves.forEach((moveStr) => {
          try {
            chess.move(moveStr);
          } catch (error) {
            console.error('Invalid move in history:', error);
          }
        });
        if (moves.length > 0) {
          const lastMoveObj = chess.history({ verbose: true }).pop();
          if (lastMoveObj) {
            setLastMove([lastMoveObj.from as Square, lastMoveObj.to as Square]);
          }
        }
        updateState();
      });

      socketService.onGameEnd((outcome) => {
        setGameOver(true);

        let status: GameStatus = 'ONGOING';

        if (outcome === 'Draw') {
          setGameOutcome('Draw');
          status = 'DRAW';
        } else if ('Decisive' in outcome) {
          setGameOutcome(outcome);
          status =
            outcome.Decisive?.winner === 'White' ? 'WHITE_WINS' : 'BLACK_WINS';
        }

        if (gameId && status !== 'ONGOING') {
          updateGameStatus(gameId, status).catch((err) => {
            console.error('Failed to update game status on server event:', err);
          });
        }
      });

      socketService.onError((errorMsg) => {
        retries += 1;
        if (!isConnected && retries < maxRetries) {
          setTimeout(() => {
            socketService.connect(gameId, userId);
          }, retryDelay);
        } else if (!isConnected) {
          setIsLoading(false);
          toast.error(
            'Unable to connect to game server. Please try again later'
          );
          console.error(errorMsg);
        }
      });

      socketService.connect(gameId, userId);
    };

    setIsLoading(true);
    initializeGame();

    return () => {
      const socketService = SocketService.getInstance();
      socketService.onConnect(() => {});
      socketService.onMove(() => {});
      socketService.onHistory(() => {});
      socketService.onGameEnd(() => {});
      socketService.onError(() => {});
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [gameId, userId, isConnected]);

  const onMove = useCallback(
    (from: Square, to: Square) => {
      if (previewIndex !== null) {
        setPreviewIndex(null);
        return;
      }
      if (chess.turn() !== playingAs) {
        return;
      }
      const moves = chess.moves({ verbose: true });
      const moveFound = moves.find((m) => m.from === from && m.to === to);
      if (!moveFound) return;
      if (moveFound.promotion) {
        setPendingMove([from, to]);
        setSelectVisible(true);
      } else {
        const moveResult = chess.move({ from, to });
        if (moveResult) {
          lastLocalMoveRef.current = moveResult.san;
          setLastMove([from, to]);
          updateState();
          SocketService.getInstance().sendMove(moveResult.san);
        }
      }
    },
    [chess, previewIndex, updateState, playingAs]
  );

  const promotion = useCallback(
    (piece: 'q' | 'r' | 'n' | 'b') => {
      if (!pendingMove) return;
      const [from, to] = pendingMove;
      const moveResult = chess.move({ from, to, promotion: piece });
      if (moveResult) {
        lastLocalMoveRef.current = moveResult.san;
        setLastMove([from, to]);
        setSelectVisible(false);
        updateState();
        SocketService.getInstance().sendMove(moveResult.san);
      }
    },
    [chess, pendingMove, updateState]
  );

  const previewMove = useCallback(
    (index: number) => {
      if (index >= chess.history().length) setPreviewIndex(null);
      else setPreviewIndex(index);
    },
    [chess]
  );

  const handleFirstMove = useCallback(() => {
    if (chess.history().length > 0) {
      setPreviewIndex(0);
    }
  }, [chess]);

  const handlePrevious = useCallback(() => {
    if (previewIndex === null && chess.history().length > 0) {
      setPreviewIndex(chess.history().length - 2);
    } else if (previewIndex !== null && previewIndex > 0) {
      setPreviewIndex(previewIndex - 1);
    }
  }, [previewIndex, chess]);

  const handleNext = useCallback(() => {
    if (previewIndex !== null && previewIndex < chess.history().length - 1) {
      setPreviewIndex(previewIndex + 1);
    } else if (
      previewIndex !== null &&
      previewIndex === chess.history().length - 1
    ) {
      setPreviewIndex(null);
    }
  }, [previewIndex, chess]);

  const handleLastMove = useCallback(() => {
    setPreviewIndex(null);
  }, []);

  const calcPreviewFen = useCallback(() => {
    if (previewIndex === null) return null;
    const temp = new Chess();
    const history = chess.history({ verbose: true });
    for (let i = 0; i <= previewIndex && i < history.length; i++) {
      temp.move(history[i].san);
    }
    return temp.fen();
  }, [previewIndex, chess]);

  const reconnect = useCallback(() => {
    setIsLoading(true);
    setError(null);
    SocketService.getInstance().connect(gameId, userId);
  }, [gameId, userId]);

  const gameProps = {
    chess,
    fen,
    lastMove,
    selectVisible,
    pendingMove,
    previewIndex,
    previewFen: calcPreviewFen(),
    onMove,
    promotion,
    previewMove,
    handleFirstMove,
    handlePrevious,
    handleNext,
    handleLastMove,
    isConnected,
    gameId,
    playingAs,
    gameOver,
    gameOutcome,
    reconnect,
  };

  if (isLoading) {
    return <LoadingScreen />;
  }

  if (!gameId) {
    return <ErrorPage message="No game ID provided" code="400" />;
  }

  if (!isAuthorized) {
    return <UnauthorizedPage />;
  }

  if (hasError) {
    return (
      <ErrorPage message="There was a problem loading this game" code="500" />
    );
  }

  return (
    <div className="mx-auto px-12 py-8">
      <SocketGamePane playingAs={playingAs} gameProps={gameProps} />
    </div>
  );
}
</file>

<file path="web/src/components/NavBar.tsx">
import { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import ThemeSwitch from './ThemeSwitch';
import { XMarkIcon, Bars3Icon } from '@heroicons/react/24/outline';
import { isAuthenticated } from '@/lib/auth/googleAuth';
import { usePathname, useRouter } from 'next/navigation';
import ChessCloudIcon from './ChessCloud';
import { useMatchmaking } from '@/lib/MatchmakingContext';
import { getUserInfo } from '@/lib/auth/googleAuth';
import { toast } from 'sonner';

type NavItem = {
  name: string;
  href: string;
  hasChildren?: boolean;
};

export default function Navbar() {
  const router = useRouter();
  const pathname = usePathname();

  const [scrolled, setScrolled] = useState(false);
  const [pressedKey, setPressedKey] = useState<string | null>(null);
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
  const [animating, setAnimating] = useState(false);
  const [authenticated, setAuthenticated] = useState(false);
  const {
    isMatchmaking,
    startMatchmaking,
    cancelMatchmaking,
    playCooldownState,
    cooldownRemaining,
  } = useMatchmaking();
  const userInfo = getUserInfo();
  const username = userInfo?.email?.split('@')[0] || 'anonymous';

  const navigationItems: NavItem[] = [
    { name: 'Features', href: '/features' },
    { name: 'Tournaments', href: '/tournaments' },
    { name: 'Docs', href: '/docs' },
    { name: 'Blog', href: '/blog' },
    { name: 'Resources', href: '/resources', hasChildren: true },
  ];

  const isDashboardPage = pathname.startsWith('/dashboard');
  const isGamePage =
    pathname.startsWith('/computer') || pathname.startsWith('/socket');

  const loadingDots = (
    <span className="inline-flex ml-1">
      <span className="animate-bounce mx-0.5" style={{ animationDelay: '0ms' }}>
        .
      </span>
      <span
        className="animate-bounce mx-0.5"
        style={{ animationDelay: '150ms' }}
      >
        .
      </span>
      <span
        className="animate-bounce mx-0.5"
        style={{ animationDelay: '300ms' }}
      >
        .
      </span>
    </span>
  );

  useEffect(() => {
    setAuthenticated(isAuthenticated());
    const handleScroll = () => setScrolled(window.scrollY > 10);
    const handleKeyUp = () => setPressedKey(null);
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.repeat) return;

      // Check if we're in a search field or other input
      const activeElement = document.activeElement;
      const isInputActive =
        activeElement?.tagName === 'INPUT' ||
        activeElement?.tagName === 'TEXTAREA' ||
        activeElement?.getAttribute('contenteditable') === 'true';

      if (isInputActive) return;

      const key = e.key.toLowerCase();
      if (key === 'p' && !isGamePage) {
        setPressedKey('p');
        if (authenticated) {
          if (isMatchmaking) {
            cancelMatchmaking();
            toast.info('Matchmaking canceled');
          } else {
            startMatchmaking(username);
            toast.success('Finding a match...', {
              description: "We'll connect you with a player soon",
            });
          }
        } else {
          setTimeout(() => router.push('/signin'), 150);
        }
      } else if (
        key === 'd' &&
        authenticated &&
        !isDashboardPage &&
        !isGamePage
      ) {
        setPressedKey('d');
        setTimeout(() => router.push('/dashboard'), 150);
      } else if (
        key === 'h' &&
        authenticated &&
        (isDashboardPage || isGamePage)
      ) {
        setPressedKey('h');
        setTimeout(() => router.push('/home'), 150);
      } else if (key === 's' && !authenticated) {
        setPressedKey('s');
        setTimeout(() => router.push('/signup'), 150);
      }
    };

    window.addEventListener('scroll', handleScroll);
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    return () => {
      window.removeEventListener('scroll', handleScroll);
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [
    authenticated,
    isMatchmaking,
    isDashboardPage,
    isGamePage,
    username,
    router,
    cancelMatchmaking,
    startMatchmaking,
  ]);

  const handleNavClick = (path: string) => {
    setMobileMenuOpen(false);
    router.push(path);
  };

  const handlePlayClick = async () => {
    setPressedKey('p');
    setMobileMenuOpen(false);
    setPressedKey(null);

    if (playCooldownState === 'cooldown' && !isMatchmaking) {
      toast.info(
        `Please wait ${Math.ceil(
          cooldownRemaining / 1000
        )} seconds before trying again`
      );
      return;
    }

    if (isMatchmaking) {
      toast.info('Matchmaking canceled');
      await cancelMatchmaking();
      return;
    }

    if (!authenticated) {
      setTimeout(() => router.push('/signin'), 150);
      return;
    }

    toast.success('Finding a match...', {
      description: "We'll connect you with a player soon",
    });

    try {
      await startMatchmaking(username);
    } finally {
      setPressedKey(null);
    }
  };

  const handleHomeClick = () => {
    setMobileMenuOpen(false);
    router.push('/home');
  };

  const handleDashboardSignUpClick = () => {
    setMobileMenuOpen(false);
    if (authenticated) {
      router.push(isDashboardPage ? '/home' : '/dashboard');
    } else {
      router.push('/signup');
    }
  };

  const toggleMobileMenu = () => {
    setAnimating(true);
    if (mobileMenuOpen) {
      setTimeout(() => {
        setMobileMenuOpen(false);
        setAnimating(false);
      }, 300);
    } else {
      setMobileMenuOpen(true);
      setTimeout(() => setAnimating(false), 50);
    }
  };

  return (
    <header
      className={`fixed top-0 left-0 right-0 z-50 border-b transition-all duration-200 ${
        scrolled
          ? 'border-amber-200/20 bg-amber-50/80 backdrop-blur-sm dark:border-slate-700/20 dark:bg-slate-900/80'
          : 'border-amber-200/10 bg-amber-50/90 dark:border-slate-700/10 dark:bg-slate-900/90'
      }`}
    >
      <div
        className="absolute inset-0"
        style={{
          backgroundImage: 'url(/noise.png)',
          backgroundRepeat: 'repeat',
          opacity: 0.025,
          pointerEvents: 'none',
        }}
      />

      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 h-16 flex items-center justify-between">
        {/* Logo & Desktop Nav */}
        <div className="flex items-center">
          <button
            onClick={() => handleNavClick(authenticated ? '/home' : '/')}
            className="flex items-center cursor-pointer"
          >
            <ChessCloudIcon />
            <span className="font-semibold text-lg text-amber-900 dark:text-amber-100 ml-2">
              ChessClouds
            </span>
          </button>
          <nav className="hidden xl:flex ml-10 space-x-8">
            {navigationItems.map((item) =>
              item.hasChildren ? (
                <div key={item.name} className="relative group">
                  <button className="text-sm text-amber-800 hover:text-amber-950 dark:text-amber-200 dark:hover:text-amber-50 flex items-center">
                    {item.name}
                    <svg
                      className="ml-1 h-4 w-4"
                      fill="none"
                      viewBox="0 0 24 24"
                      stroke="currentColor"
                    >
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M19 9l-7 7-7-7"
                      />
                    </svg>
                  </button>
                </div>
              ) : (
                <button
                  key={item.name}
                  onClick={() => handleNavClick(item.href)}
                  className="text-sm text-amber-800 hover:text-amber-950 dark:text-amber-200 dark:hover:text-amber-50"
                >
                  {item.name}
                </button>
              )
            )}
          </nav>
        </div>

        {/* Desktop Actions */}
        <div className="flex items-center space-x-3">
          <ThemeSwitch />

          {/* Dashboard / Sign up */}
          <div className="hidden md:block">
            {isAuthenticated() ? (
              <Button
                variant="outline"
                className={`h-9 text-sm border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900 transition-all shadow-[0_3px_0_0_#fcd34d] hover:shadow-[0_1px_0_0_#fcd34d] hover:translate-y-[2px] dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50 dark:shadow-[0_3px_0_0_#475569] dark:hover:shadow-[0_1px_0_0_#475569] ${
                  pressedKey === (isDashboardPage || isGamePage ? 'h' : 'd')
                    ? 'transform translate-y-[3px] shadow-none bg-amber-100 dark:bg-slate-800'
                    : ''
                }`}
                onClick={
                  isGamePage ? handleHomeClick : handleDashboardSignUpClick
                }
                onMouseUp={() => setPressedKey(null)}
              >
                {isGamePage ? 'Home' : isDashboardPage ? 'Home' : 'Dashboard'}
                <span
                  className={`ml-1 text-xs px-1 rounded ${
                    pressedKey === (isDashboardPage || isGamePage ? 'h' : 'd')
                      ? 'bg-amber-200 text-amber-900 dark:bg-slate-700 dark:text-amber-100'
                      : 'bg-amber-100 dark:bg-slate-800'
                  }`}
                >
                  {' '}
                  {isDashboardPage || isGamePage ? 'H' : 'D'}{' '}
                </span>
              </Button>
            ) : (
              <Button
                variant="outline"
                className={`h-9 text-sm border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900 transition-all shadow-[0_3px_0_0_#fcd34d] hover:shadow-[0_1px_0_0_#fcd34d] hover:translate-y-[2px] dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50 dark:shadow-[0_3px_0_0_#475569] dark:hover:shadow-[0_1px_0_0_#475569] ${
                  pressedKey === 's'
                    ? 'transform translate-y-[3px] shadow-none bg-amber-100 dark:bg-slate-800'
                    : ''
                }`}
                onClick={handleDashboardSignUpClick}
                onMouseUp={() => setPressedKey(null)}
              >
                Sign Up
                <span
                  className={`ml-1 text-xs px-1 rounded ${
                    pressedKey === 's'
                      ? 'bg-amber-200 text-amber-900 dark:bg-slate-700 dark:text-amber-100'
                      : 'bg-amber-100 dark:bg-slate-800'
                  }`}
                >
                  {'S'}
                </span>
              </Button>
            )}
          </div>

          {/* Play/Cancel */}
          {!isGamePage && (
            <div className="hidden sm:block">
              <Button
                className={`h-9 text-sm text-white rounded-md transition-all hover:translate-y-[2px] 
                  bg-amber-600 hover:bg-amber-700 dark:bg-amber-500 dark:hover:bg-amber-600 
                  shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e]
                  ${
                    pressedKey === 'p'
                      ? 'transform translate-y-[3px] shadow-none bg-amber-700 dark:bg-amber-600'
                      : ''
                  }`}
                onClick={handlePlayClick}
                onMouseUp={() => setPressedKey(null)}
                disabled={playCooldownState === 'cooldown' && !isMatchmaking}
              >
                {isMatchmaking ? (
                  <>
                    Finding{loadingDots}
                    <span className="ml-1 text-xs px-1 rounded bg-amber-700 dark:bg-amber-600">
                      P
                    </span>
                  </>
                ) : playCooldownState === 'cooldown' ? (
                  <>Wait {Math.ceil(cooldownRemaining / 1000)}s</>
                ) : (
                  <>
                    Play now
                    <span className="ml-1 text-xs px-1 rounded bg-amber-700 dark:bg-amber-600">
                      P
                    </span>
                  </>
                )}
              </Button>
            </div>
          )}

          {/* Mobile Menu Toggle */}
          <button
            className="xl:hidden flex items-center justify-center h-9 w-9 border border-amber-300 bg-white dark:bg-slate-800 text-amber-800 hover:bg-amber-50 hover:text-amber-900 rounded-md transition-all shadow-[0_3px_0_0_#fcd34d] hover:shadow-[0_1px_0_0_#fcd34d] hover:translate-y-[2px] dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50 dark:shadow-[0_3px_0_0_#475569] dark:hover:shadow-[0_1px_0_0_#475569]"
            onClick={toggleMobileMenu}
            disabled={animating}
            aria-label="Menu"
          >
            {mobileMenuOpen ? (
              <XMarkIcon className="h-5 w-5" />
            ) : (
              <Bars3Icon className="h-5 w-5" />
            )}
          </button>
        </div>
      </div>

      {/* Mobile Menu */}
      <div
        className={`xl:hidden overflow-hidden transition-all duration-300 ease-in-out ${
          mobileMenuOpen ? 'max-h-[500px] opacity-100' : 'max-h-0 opacity-0'
        }`}
      >
        <div className="px-4 py-4 space-y-3 border-t border-amber-200/30 dark:border-slate-700/30 bg-amber-50/95 dark:bg-slate-900/95 backdrop-blur-sm">
          {navigationItems.map((item) => (
            <button
              key={item.name}
              onClick={() => handleNavClick(item.href)}
              className="w-full text-left py-2 px-3 text-base text-amber-800 hover:bg-amber-100/70 dark:text-amber-200 dark:hover:bg-slate-800/70 rounded-md flex justify-between"
            >
              <span>{item.name}</span>
              {item.hasChildren && (
                <svg
                  className="h-4 w-4"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M9 5l7 7-7 7"
                  />
                </svg>
              )}
            </button>
          ))}

          {/* Mobile Dashboard/Signup */}
          <div className="md:hidden">
            <Button
              variant="outline"
              className="w-full mt-2 border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900 transition-all shadow-[0_3px_0_0_#fcd34d] hover:shadow-[0_1px_0_0_#fcd34d] hover:translate-y-[2px] dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50 dark:shadow-[0_3px_0_0_#475569] dark:hover:shadow-[0_1px_0_0_#475569]"
              onClick={
                isGamePage ? handleHomeClick : handleDashboardSignUpClick
              }
            >
              {isGamePage
                ? 'Home'
                : isDashboardPage
                ? 'Home'
                : authenticated
                ? 'Dashboard'
                : 'Sign up'}
              <span className="ml-1 text-xs px-1 rounded bg-amber-100 dark:bg-slate-800">
                {isGamePage || isDashboardPage
                  ? 'H'
                  : authenticated
                  ? 'D'
                  : 'S'}
              </span>
            </Button>
          </div>

          {/* Mobile Play */}
          {!isGamePage && (
            <div className="sm:hidden">
              <Button
                className={`w-full mt-2 text-sm text-white rounded-md transition-all hover:translate-y-[2px] ${
                  isMatchmaking
                    ? 'bg-amber-600 hover:bg-amber-700 shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e]'
                    : 'bg-amber-600 hover:bg-amber-700 shadow-[0_3px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e]'
                }`}
                disabled={playCooldownState === 'cooldown' && !isMatchmaking}
                onClick={handlePlayClick}
              >
                {isMatchmaking ? (
                  <>
                    Finding{loadingDots}
                    <span className="ml-1 text-xs px-1 rounded bg-red-700 dark:bg-red-600">
                      P
                    </span>
                  </>
                ) : playCooldownState === 'cooldown' ? (
                  <>Wait {Math.ceil(cooldownRemaining / 1000)}s</>
                ) : (
                  <>
                    Play now
                    <span className="ml-1 text-xs px-1 rounded bg-amber-700 dark:bg-amber-600">
                      P
                    </span>
                  </>
                )}
              </Button>
            </div>
          )}
        </div>
      </div>
    </header>
  );
}
</file>

<file path="web/src/app/home/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import {
  LockClosedIcon,
  ChevronRightIcon,
  Cog6ToothIcon,
} from '@heroicons/react/24/outline';
import { LatestChessBoard } from '@/components/DisplayChessBoard';
import {
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselNext,
  CarouselPrevious,
} from '@/components/ui/carousel';
import { getUserInfo, handleAuthCallback } from '@/lib/auth/googleAuth';
import { useRouter } from 'next/navigation';
import LoadingScreen from '@/components/LoadingScreen';
import { toast } from 'sonner';
import { testEngine } from '@/lib/engine';
import { useMatchmaking } from '@/lib/MatchmakingContext';
import {
  createGame,
  getUserHistoryGames,
  getUserOngoingGames,
} from '../actions/gameActions';
import { gamestate } from '@prisma/client';
import { getLastTime } from '@/lib/time';

const HISTORY_LIMIT = 5;

export default function HomePage() {
  const router = useRouter();
  const [username, setUsername] = useState('Player');
  const [greeting, setGreeting] = useState('Hello');
  const [isProcessingAuth, setIsProcessingAuth] = useState(true);
  const [showEngineOptions, setShowEngineOptions] = useState(false);
  const [isEngineAvailable, setIsEngineAvailable] = useState(false);
  const [isTestingEngine, setIsTestingEngine] = useState(true);
  const {
    isMatchmaking,
    startMatchmaking,
    cancelMatchmaking,
    playCooldownState,
    cooldownRemaining,
  } = useMatchmaking();

  const [gamesInPlay, setGamesInPlay] = useState<
    Awaited<ReturnType<typeof getUserOngoingGames>>['games']
  >([]);
  const [loadingOngoingGames, setLoadingOngoingGames] = useState(true);

  useEffect(() => {
    const fetchOngoingGames = async () => {
      try {
        setLoadingOngoingGames(true);
        const { success, games = [] } = await getUserOngoingGames(username);
        if (success) {
          setGamesInPlay(games);
        } else {
          toast.error('Failed to load ongoing games');
        }
      } catch {
        toast.error('Error loading ongoing games');
      } finally {
        setLoadingOngoingGames(false);
      }
    };

    if (username) {
      fetchOngoingGames();
      const interval = setInterval(fetchOngoingGames, 60000);
      return () => clearInterval(interval);
    }
  }, [username]);

  const [gameHistory, setGameHistory] = useState<
    Awaited<ReturnType<typeof getUserHistoryGames>>['games']
  >([]);
  const [loadingGameHistory, setLoadingGameHistory] = useState(true);

  useEffect(() => {
    const fetchGameHistory = async () => {
      try {
        setLoadingGameHistory(true);
        const { success, games = [] } = await getUserHistoryGames(username);
        if (success) {
          setGameHistory(games);
        } else {
          toast.error('Failed to load game history');
        }
      } catch (err) {
        console.error(err);
        toast.error('Error loading game history');
      } finally {
        setLoadingGameHistory(false);
      }
    };

    if (username) fetchGameHistory();
  }, [username]);

  const testEngineAvailability = async () => {
    try {
      const data = await testEngine();
      setIsEngineAvailable(data.status === 'success');
    } catch (err) {
      console.error('Engine Error: ', err);
      setIsEngineAvailable(false);
    } finally {
      setIsTestingEngine(false);
    }
  };

  useEffect(() => {
    const { token, error, redirectPath } = handleAuthCallback();

    if (token) {
      if (window.location.hash) {
        window.history.replaceState(
          {},
          document.title,
          window.location.pathname
        );
      }

      if (redirectPath) {
        router.push(redirectPath);
      }
    } else if (error) {
      toast.warning('Authentication Error', {
        description: error,
      });
    }

    const getTimeBasedGreeting = () => {
      const hour = new Date().getHours();
      if (hour >= 5 && hour < 12) {
        return 'Good morning';
      } else if (hour >= 12 && hour < 18) {
        return 'Good afternoon';
      } else {
        return 'Good evening';
      }
    };

    testEngineAvailability();

    setGreeting(getTimeBasedGreeting());
    setUsername(getUserInfo()?.email?.split('@')[0] || 'Player');
    setIsProcessingAuth(false);

    const greetingInterval = setInterval(() => {
      setGreeting(getTimeBasedGreeting());
    }, 60000);

    return () => clearInterval(greetingInterval);
  }, [router]);

  const handlePlayNow = () => {
    if (playCooldownState === 'cooldown' && !isMatchmaking) {
      toast.info(
        `Please wait ${Math.ceil(
          cooldownRemaining / 1000
        )} seconds before trying again`
      );
      return;
    }

    if (isMatchmaking) {
      cancelMatchmaking();
      toast.info('Matchmaking canceled');
    } else {
      startMatchmaking(username);
      toast.success('Finding a match...', {
        description: "We'll connect you with an opponent soon",
      });
    }
  };

  const handleSettingButton = () => {
    router.push('/dashboard');
  };

  const handleViewAllHistory = () => {
    router.push('/dashboard?tab=games');
  };

  const handleComputerClick = () => {
    if (isTestingEngine || !isEngineAvailable) return;
    setShowEngineOptions(() => !showEngineOptions);
  };

  const handlePlayAsWhite = (e: React.MouseEvent) => {
    e.stopPropagation();
    createAndRedirectToGame('w');
  };

  const handlePlayAsBlack = (e: React.MouseEvent) => {
    e.stopPropagation();
    createAndRedirectToGame('b');
  };

  const createAndRedirectToGame = async (color: 'w' | 'b') => {
    try {
      const computerName = 'computer';
      const playerName = username;
      const white = color === 'w' ? playerName : computerName;
      const black = color === 'w' ? computerName : playerName;

      console.log(white, black);

      const result = await createGame(white, black);

      if (result.success && result.gameId) {
        router.push(`/computer?color=${color}&game_id=${result.gameId}`);
      } else {
        toast.error('Failed to create game', {
          description: result.error || 'Please try again later',
        });
      }
    } catch (error) {
      toast.error('Error starting game', {
        description: 'An unexpected error occurred',
      });
      console.error('Error creating game:', error);
    }
  };

  const getTurnFromPgn = (pgn: string): 'w' | 'b' => {
    const moves =
      pgn.match(
        /\b([PNBRQK]?[a-h]?[1-8]?x?[a-h][1-8](?:=[NBRQ])?|O-O(?:-O)?|[a-h][1-8])\b/g
      ) || [];
    return moves.length % 2 === 0 ? 'w' : 'b';
  };

  function handleContinueGame(game: gamestate) {
    if (!game || !game.gameid) {
      toast.error('Game information is missing');
      return;
    }

    const opponent = game.white === username ? game.black : game.white;
    const userColor = game.white === username ? 'w' : 'b';

    const isComputerGame = opponent === 'computer';

    if (isComputerGame) {
      router.push(`/computer?color=${userColor}&game_id=${game.gameid}`);
    } else {
      router.push(`/socket?game_id=${game.gameid}&playas=${userColor}`);
    }
  }

  if (isProcessingAuth || loadingGameHistory) {
    return <LoadingScreen />;
  }

  return (
    <div className="container mx-auto py-8 px-4 max-w-7xl relative">
      <div
        className="absolute inset-0"
        style={{
          backgroundImage: 'url(/noise.png)',
          backgroundRepeat: 'repeat',
          opacity: 0.025,
          pointerEvents: 'none',
        }}
      />

      <header className="flex justify-between items-center mb-8">
        <h1 className="text-4xl font-bold text-amber-900 dark:text-amber-100 font-display">
          {greeting},{' '}
          <span className="text-amber-600 dark:text-amber-400">{username}</span>
        </h1>

        <div className="flex space-x-3 items-center">
          <Button
            className="h-10 w-10 p-0 rounded-md bg-amber-600 hover:bg-amber-700 text-white transition-all 
            shadow-[0_4px_0_0_#b45309] hover:shadow-[0_2px_0_0_#92400e] hover:translate-y-[2px]
            dark:bg-amber-500 dark:hover:bg-amber-600
            dark:shadow-[0_4px_0_0_#92400e] dark:hover:shadow-[0_2px_0_0_#78350f]"
            onClick={handleSettingButton}
          >
            <Cog6ToothIcon className="h-5 w-5" />
          </Button>
        </div>
      </header>

      <div className="grid grid-cols-5 gap-6 mb-6 min-h-[467px]">
        <Card className="col-span-5 lg:col-span-2 bg-white/50 dark:bg-slate-800/50 backdrop-blur-sm border border-amber-200/50 dark:border-amber-800/30 shadow-md hover:shadow-lg transition-all">
          <CardHeader>
            <CardTitle className="text-xl text-amber-900 dark:text-amber-100">
              Play Chess
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <Button
              className={`w-full flex justify-center items-center
                        bg-amber-600 hover:bg-amber-700 text-white px-6 rounded-md
                        dark:bg-amber-500 dark:hover:bg-amber-600 
                        shadow-[0_4px_0_0_#b45309] hover:shadow-[0_2px_0_0_#92400e]
                        hover:translate-y-[2px] transition-all
                        ${
                          playCooldownState === 'cooldown' && !isMatchmaking
                            ? 'bg-amber-700 dark:bg-amber-600 cursor-not-allowed'
                            : ''
                        }`}
              onClick={handlePlayNow}
              disabled={playCooldownState === 'cooldown' && !isMatchmaking}
            >
              {isMatchmaking ? (
                <>
                  Finding
                  <span className="inline-flex ml-1">
                    <span
                      className="animate-bounce mx-0.5"
                      style={{ animationDelay: '0ms' }}
                    >
                      .
                    </span>
                    <span
                      className="animate-bounce mx-0.5"
                      style={{ animationDelay: '150ms' }}
                    >
                      .
                    </span>
                    <span
                      className="animate-bounce mx-0.5"
                      style={{ animationDelay: '300ms' }}
                    >
                      .
                    </span>
                  </span>
                </>
              ) : playCooldownState === 'cooldown' ? (
                <>Wait {Math.ceil(cooldownRemaining / 1000)}s</>
              ) : (
                <>Play Now</>
              )}
              <ChevronRightIcon className="ml-2 h-4 w-4" />
            </Button>

            {/* <Button
              className="w-full flex justify-center items-center
                        bg-amber-600 hover:bg-amber-700 text-white px-6 rounded-md
                        shadow-[0_4px_0_0_#b45309] hover:shadow-[0_2px_0_0_#92400e]
                        hover:translate-y-[2px] transition-all"
              onClick={handlePlayFriend}
            >
              Play a Friend
              <ChevronRightIcon className="ml-2 h-4 w-4" />
            </Button> */}

            <Button
              variant="outline"
              className={`w-full flex justify-center items-center
                          border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900
                          px-6 rounded-md transition-all shadow-[0_4px_0_0_#fcd34d]
                          hover:shadow-[0_2px_0_0_#fcd34d] hover:translate-y-[2px]
                          dark:bg-slate-800/70 dark:border-slate-700 dark:text-amber-200
                          dark:hover:bg-slate-800/50 dark:shadow-[0_4px_0_0_#475569]
                          dark:hover:shadow-[0_2px_0_0_#475569]
                          ${
                            !isEngineAvailable
                              ? 'opacity-50 cursor-not-allowed'
                              : ''
                          }`}
              onClick={handleComputerClick}
              disabled={!isEngineAvailable || isTestingEngine}
            >
              Play with Computer
              {!isEngineAvailable && (
                <LockClosedIcon className="ml-2 h-4 w-4" />
              )}
            </Button>
          </CardContent>

          {showEngineOptions && (
            <div className="flex justify-center md:justify-start border-t border-amber-200/30 dark:border-slate-700/30 px-6 pt-4 gap-2">
              <Button
                className="flex-1 bg-white hover:bg-gray-100 text-gray-800 border border-gray-300
                          shadow-[0_4px_0_0_#d1d5db] hover:shadow-[0_2px_0_0_#9ca3af] hover:translate-y-[2px]
                          dark:bg-gray-100 dark:hover:bg-gray-200 dark:text-gray-900
                          dark:shadow-[0_4px_0_0_#9ca3af] dark:hover:shadow-[0_2px_0_0_#6b7280]"
                onClick={handlePlayAsWhite}
              >
                Play White
              </Button>

              <Button
                className="flex-1 bg-gray-800 hover:bg-gray-900 text-white
                          shadow-[0_4px_0_0_#4b5563] hover:shadow-[0_2px_0_0_#374151] hover:translate-y-[2px]
                          dark:bg-gray-700 dark:hover:bg-gray-800
                          dark:shadow-[0_4px_0_0_#6b7280] dark:hover:shadow-[0_2px_0_0_#4b5563]"
                onClick={handlePlayAsBlack}
              >
                Play Black
              </Button>
            </div>
          )}
        </Card>

        <Card className="col-span-5 lg:col-span-3 bg-white/50 dark:bg-slate-800/50 backdrop-blur-sm border border-amber-200/50 dark:border-amber-800/30 shadow-md hover:shadow-lg transition-all">
          <CardHeader>
            <CardTitle className="text-xl text-amber-900 dark:text-amber-100">
              Games in Play
            </CardTitle>
          </CardHeader>
          <CardContent>
            {loadingOngoingGames ? (
              <div className="text-center py-8 text-amber-700 dark:text-amber-300">
                Loading your games…
              </div>
            ) : !gamesInPlay || gamesInPlay.length === 0 ? (
              <div className="text-center py-8 text-amber-700 dark:text-amber-300">
                No active games at the moment
              </div>
            ) : (
              <Carousel className="w-full">
                <CarouselContent className="-ml-2">
                  {gamesInPlay.map((game) => (
                    <CarouselItem
                      key={game.gameid}
                      className="pl-2 md:basis-1/2 lg:basis-1/3"
                    >
                      <div
                        className="bg-amber-50/80 dark:bg-slate-800/70 rounded-lg border border-amber-200/40 dark:border-amber-800/20 cursor-pointer hover:bg-amber-100/80 dark:hover:bg-slate-700/70 transition-colors h-full"
                        onClick={() => handleContinueGame(game)}
                      >
                        <div className="flex items-center justify-center pt-3 px-3">
                          <div className="w-full aspect-square bg-amber-100 dark:bg-slate-700 max-w-[180px]">
                            <LatestChessBoard
                              className="w-full h-full"
                              pgn={game.pgn}
                              color={game.white === username ? 'w' : 'b'}
                            />
                          </div>
                        </div>
                        <div className="p-3">
                          <div className="flex justify-between items-center mb-1">
                            <h3 className="font-medium text-amber-900 dark:text-amber-100">
                              vs{' '}
                              {game.white === username
                                ? game.black
                                : game.white}
                            </h3>
                            <span
                              className={`text-xs px-2 py-0.5 rounded-full ${
                                getTurnFromPgn(game.pgn) ===
                                (game.white === username ? 'w' : 'b')
                                  ? 'bg-green-100 text-green-700 dark:bg-green-900/40 dark:text-green-400'
                                  : 'bg-amber-100 text-amber-700 dark:bg-amber-900/40 dark:text-amber-400'
                              }`}
                            >
                              {getTurnFromPgn(game.pgn) ===
                              (game.white === username ? 'w' : 'b')
                                ? 'Your turn'
                                : `${
                                    game.white === username ? 'Black' : 'White'
                                  } turn`}
                            </span>
                          </div>
                          <p className="text-sm text-amber-700 dark:text-amber-300 mb-3">
                            {game.lastMove !== 'Game started'
                              ? `Last move: ${game.lastMove} ${game.lastMoveTime}`
                              : `Game started: ${game.lastMoveTime}`}
                          </p>
                          <Button
                            size="sm"
                            className="w-full bg-amber-600 hover:bg-amber-700 text-white rounded-md transition-all 
                          shadow-[0_2px_0_0_#b45309] hover:shadow-[0_1px_0_0_#92400e] hover:translate-y-[1px]
                          dark:bg-amber-500 dark:hover:bg-amber-600
                          dark:shadow-[0_2px_0_0_#92400e] dark:hover:shadow-[0_1px_0_0_#78350f]"
                          >
                            Continue
                          </Button>
                        </div>
                      </div>
                    </CarouselItem>
                  ))}
                </CarouselContent>
                <div className="flex justify-end gap-2 mt-4">
                  <CarouselPrevious
                    className="relative inset-0 translate-y-0 border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900 rounded-md
        dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50"
                  />
                  <CarouselNext
                    className="relative inset-0 translate-y-0 border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900 rounded-md
        dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50"
                  />
                </div>
              </Carousel>
            )}
          </CardContent>
        </Card>
      </div>

      <div className="grid grid-cols-5 gap-6">
        <Card className="col-span-5 lg:col-span-3 bg-white/50 dark:bg-slate-800/50 backdrop-blur-sm border border-amber-200/50 dark:border-amber-800/30 shadow-md hover:shadow-lg transition-all">
          <CardHeader className="flex flex-row items-center justify-between">
            <CardTitle className="text-xl text-amber-900 dark:text-amber-100">
              Game History
            </CardTitle>
            <Button
              variant="outline"
              size="sm"
              className="border-amber-300 text-amber-800 hover:bg-amber-50 hover:text-amber-900
              dark:border-slate-700 dark:text-amber-200 dark:hover:bg-slate-800/50"
              onClick={() => handleViewAllHistory()}
            >
              View All
            </Button>
          </CardHeader>
          <CardContent>
            <div className="overflow-x-auto">
              <table className="w-full text-sm">
                <thead className="text-amber-700 dark:text-amber-300 border-b border-amber-200/30 dark:border-amber-700/30">
                  <tr>
                    <th className="text-left py-2 pl-2">Opponent</th>
                    <th className="text-left py-2">Result</th>
                    <th className="text-center py-2">Date</th>
                    <th className="text-right py-2 pr-2">Moves</th>
                  </tr>
                </thead>
                <tbody>
                  {gameHistory !== undefined &&
                    gameHistory.slice(0, HISTORY_LIMIT).map((game) => (
                      <tr
                        key={game.gameid}
                        className="border-b border-amber-100/50 dark:border-slate-700/30 hover:bg-amber-50 hover:text-amber-900 dark:hover:bg-slate-700/30 dark:hover:text-slate-100/80 transition-colors"
                      >
                        <td className="text-left py-2 pl-2">
                          {game.black === username ? game.white : game.black}
                        </td>
                        <td
                          className={`text-left py-2 ${
                            (game.status === 'WHITE_WINS' &&
                              game.white === username) ||
                            (game.status === 'BLACK_WINS' &&
                              game.black === username)
                              ? 'text-green-600 dark:text-green-400' // Win
                              : game.status === 'DRAW'
                              ? 'text-amber-600 dark:text-amber-400' // Draw
                              : 'text-red-600 dark:text-red-400' // Loss
                          }`}
                        >
                          {game.status === 'DRAW'
                            ? 'Draw'
                            : (game.status === 'WHITE_WINS' &&
                                game.white === username) ||
                              (game.status === 'BLACK_WINS' &&
                                game.black === username)
                            ? 'Win'
                            : game.status === 'ONGOING'
                            ? 'In progress'
                            : 'Loss'}
                        </td>
                        <td className="text-center py-2">
                          {game.createdat ? getLastTime(game.createdat) : '—'}
                        </td>
                        <td
                          className={`text-right py-2 pr-2 ${
                            (game.status === 'WHITE_WINS' &&
                              game.white === username) ||
                            (game.status === 'BLACK_WINS' &&
                              game.black === username)
                              ? 'text-green-600 dark:text-green-400' // Win
                              : game.status === 'DRAW'
                              ? 'text-amber-600 dark:text-amber-400' // Draw
                              : 'text-red-600 dark:text-red-400' // Loss
                          }`}
                        >
                          {game.pgn
                            ? (
                                game.pgn.match(
                                  /\b([PNBRQK]?[a-h]?[1-8]?x?[a-h][1-8](?:=[NBRQ])?|O-O(?:-O)?|[a-h][1-8])\b/g
                                ) || []
                              ).length
                            : 0}
                        </td>
                      </tr>
                    ))}
                </tbody>
              </table>
            </div>

            {gameHistory && gameHistory.length >= 10 && (
              <div className="flex justify-end items-center mt-4 text-sm text-amber-700 dark:text-amber-300">
                Showing up to 10 most recent games
              </div>
            )}
          </CardContent>
        </Card>

        <Card className="col-span-5 lg:col-span-2 bg-white/50 dark:bg-slate-800/50 backdrop-blur-sm border border-amber-200/50 dark:border-amber-800/30 shadow-md hover:shadow-lg transition-all">
          <CardHeader>
            <CardTitle className="text-xl text-amber-900 dark:text-amber-100">
              Player Stats
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-2 gap-4">
              <div className="flex flex-col items-center bg-amber-50/80 dark:bg-slate-700/50 p-4 rounded-lg border border-amber-200/40 dark:border-amber-800/20">
                <div className="text-3xl font-bold text-amber-900 dark:text-amber-100">
                  {gameHistory === undefined
                    ? 500
                    : Math.max(
                        100,
                        500 -
                          10 *
                            gameHistory.filter(
                              (g) =>
                                (g.status === 'WHITE_WINS' &&
                                  g.black === username) ||
                                (g.status === 'BLACK_WINS' &&
                                  g.white === username)
                            ).length +
                          10 *
                            gameHistory.filter(
                              (g) =>
                                (g.status === 'WHITE_WINS' &&
                                  g.white === username) ||
                                (g.status === 'BLACK_WINS' &&
                                  g.black === username)
                            ).length
                      )}
                </div>
                <div className="text-sm text-amber-700 dark:text-amber-300">
                  Rating
                </div>
              </div>

              <div className="flex flex-col items-center bg-amber-50/80 dark:bg-slate-700/50 p-4 rounded-lg border border-amber-200/40 dark:border-amber-800/20">
                <div className="text-3xl font-bold text-amber-900 dark:text-amber-100">
                  {gameHistory?.length ?? 0}
                </div>
                <div className="text-sm text-amber-700 dark:text-amber-300">
                  Games Played
                </div>
              </div>

              <div className="flex flex-col items-center bg-amber-50/80 dark:bg-slate-700/50 p-4 rounded-lg border border-amber-200/40 dark:border-amber-800/20">
                <div className="text-3xl font-bold text-amber-900 dark:text-amber-100">
                  {gameHistory === undefined
                    ? 0
                    : gameHistory.length
                    ? Math.round(
                        (100 *
                          gameHistory.filter(
                            (g) =>
                              (g.status === 'WHITE_WINS' &&
                                g.white === username) ||
                              (g.status === 'BLACK_WINS' &&
                                g.black === username)
                          ).length) /
                          gameHistory.length
                      )
                    : 0}
                  %
                </div>
                <div className="text-sm text-amber-700 dark:text-amber-300">
                  Win Rate
                </div>
              </div>

              <div className="flex flex-col items-center bg-amber-50/80 dark:bg-slate-700/50 p-4 rounded-lg border border-amber-200/40 dark:border-amber-800/20">
                <div className="text-3xl font-bold text-amber-900 dark:text-amber-100">
                  {gameHistory === undefined
                    ? 0
                    : ((i) => (i === -1 ? gameHistory.length : i))(
                        gameHistory.findIndex(
                          (g) =>
                            !(
                              (g.status === 'WHITE_WINS' &&
                                g.white === username) ||
                              (g.status === 'BLACK_WINS' &&
                                g.black === username)
                            )
                        )
                      )}
                </div>
                <div className="text-sm text-amber-700 dark:text-amber-300">
                  Current Streak
                </div>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
</file>

</files>
