This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
bindings/
  ClientMessage.ts
  Color.ts
  Error.ts
  InitBody.ts
  Outcome.ts
  ServerMessage.ts
src/
  bin/
    client_disconnect.rs
    client.rs
    test.rs
  route/
    games.rs
    init.rs
    ws.rs
  game_state.rs
  lib.rs
  main.rs
  message.rs
  route.rs
.gitignore
Cargo.toml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="bindings/ClientMessage.ts">
// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.

export type ClientMessage = { "kind": "Auth", "value": { game_id: string, user_id: string, } } | { "kind": "Move", "value": string };
</file>

<file path="bindings/Color.ts">
// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.

export type Color = "Black" | "White";
</file>

<file path="bindings/Error.ts">
// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.

export type Error = "Deserialization" | "Unauthorized" | "InvalidTurn" | "InvalidMove";
</file>

<file path="bindings/InitBody.ts">
// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.

export type InitBody = { game_id: string, white_user_id: string, black_user_id: string, };
</file>

<file path="bindings/Outcome.ts">
// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.
import type { Color } from "./Color";

export type Outcome = { "Decisive": { winner: Color, } } | "Draw";
</file>

<file path="bindings/ServerMessage.ts">
// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.
import type { Error } from "./Error";
import type { Outcome } from "./Outcome";

export type ServerMessage = { "kind": "Move", "value": string } | { "kind": "GameEnd", "value": Outcome } | { "kind": "Error", "value": Error } | { "kind": "AuthSuccess" } | { "kind": "MoveHistory", "value": Array<string> };
</file>

<file path="src/bin/client_disconnect.rs">
use std::time::Duration;

use futures_util::{
    stream::{SplitSink, SplitStream},
    SinkExt, StreamExt,
};
use tokio::{net::TcpStream, time::sleep};
use tokio_tungstenite::{
    connect_async,
    tungstenite::{Message, Utf8Bytes},
    MaybeTlsStream, WebSocketStream,
};
use ws_server::{message::ClientMessage, route::init::InitBody, HOST};

async fn send_msg(
    writer: &mut SplitSink<WebSocketStream<MaybeTlsStream<TcpStream>>, Message>,
    msg: &ClientMessage,
) -> anyhow::Result<()> {
    let msg = serde_json::to_string(&msg)?;
    writer.send(Message::Text(Utf8Bytes::from(&msg))).await?;
    sleep(Duration::from_millis(500)).await;
    Ok(())
}

async fn handle_read(
    mut reader: SplitStream<WebSocketStream<MaybeTlsStream<TcpStream>>>,
    socket_name: &str,
) {
    while let Some(Ok(msg)) = reader.next().await {
        if let Message::Text(text) = msg {
            println!("{socket_name} received: {}", text.to_string());
        }
    }
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let url = format!("ws://{HOST}/ws",);

    const GAME_ID: &'static str = "123";
    const WHITE_ID: &'static str = "white";
    const BLACK_ID: &'static str = "black";

    // initialize new game
    let init_body = InitBody {
        game_id: GAME_ID.to_string(),
        white_user_id: WHITE_ID.to_string(),
        black_user_id: BLACK_ID.to_string(),
    };

    let client = reqwest::Client::new();
    client
        .post(format!("http://{HOST}/init"))
        .json(&init_body)
        .send()
        .await?;

    let (socket1, _) = connect_async(&url).await?;
    let (mut writer1, reader1) = socket1.split();

    let (socket2, _) = connect_async(&url).await?;
    let (mut writer2, reader2) = socket2.split();

    tokio::spawn(handle_read(reader1, "socket 1"));
    let handle2 = tokio::spawn(handle_read(reader2, "socket 2"));

    send_msg(
        &mut writer1,
        &ClientMessage::Auth {
            game_id: GAME_ID.to_string(),
            user_id: WHITE_ID.to_string(),
        },
    )
    .await?;
    send_msg(
        &mut writer2,
        &ClientMessage::Auth {
            game_id: GAME_ID.to_string(),
            user_id: BLACK_ID.to_string(),
        },
    )
    .await?;

    send_msg(&mut writer1, &ClientMessage::Move("e4".to_string())).await?;
    send_msg(&mut writer2, &ClientMessage::Move("e5".to_string())).await?;

    send_msg(&mut writer1, &ClientMessage::Move("Qh5".to_string())).await?;
    send_msg(&mut writer2, &ClientMessage::Move("Nc6".to_string())).await?;

    // disconnect socket 1
    writer1.close().await?;

    let (socket3, _) = connect_async(&url).await?;
    let (mut writer3, reader3) = socket3.split();

    let handle3 = tokio::spawn(handle_read(reader3, "socket 3"));

    send_msg(
        &mut writer3,
        &ClientMessage::Auth {
            game_id: GAME_ID.to_string(),
            user_id: WHITE_ID.to_string(),
        },
    )
    .await?;

    send_msg(&mut writer3, &ClientMessage::Move("Bc4".to_string())).await?;
    send_msg(&mut writer2, &ClientMessage::Move("Nf6".to_string())).await?;

    send_msg(&mut writer3, &ClientMessage::Move("Qxf7#".to_string())).await?;

    let _ = tokio::join!(handle2, handle3);
    Ok(())
}
</file>

<file path="src/bin/client.rs">
use std::time::Duration;

use futures_util::{stream::SplitSink, SinkExt, StreamExt};
use tokio::{net::TcpStream, time::sleep};
use tokio_tungstenite::{
    connect_async,
    tungstenite::{Message, Utf8Bytes},
    MaybeTlsStream, WebSocketStream,
};
use ws_server::{message::ClientMessage, route::init::InitBody, HOST};

async fn send_msg(
    writer: &mut SplitSink<WebSocketStream<MaybeTlsStream<TcpStream>>, Message>,
    msg: &ClientMessage,
) -> anyhow::Result<()> {
    let msg = serde_json::to_string(&msg)?;
    writer.send(Message::Text(Utf8Bytes::from(&msg))).await?;
    sleep(Duration::from_millis(500)).await;
    Ok(())
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let url = format!("ws://{HOST}/ws",);

    const GAME_ID: &'static str = "123";
    const WHITE_ID: &'static str = "white";
    const BLACK_ID: &'static str = "black";

    // initialize new game
    let init_body = InitBody {
        game_id: GAME_ID.to_string(),
        white_user_id: WHITE_ID.to_string(),
        black_user_id: BLACK_ID.to_string(),
    };

    let client = reqwest::Client::new();
    client
        .post(format!("http://{HOST}/init"))
        .json(&init_body)
        .send()
        .await?;

    let (socket1, _) = connect_async(&url).await?;
    let (mut writer1, mut reader1) = socket1.split();

    let (socket2, _) = connect_async(&url).await?;
    let (mut writer2, mut reader2) = socket2.split();

    tokio::spawn(async move {
        while let Some(Ok(msg)) = reader1.next().await {
            if let Message::Text(text) = msg {
                println!("Socket 1 received: {}", text.to_string());
            }
        }
    });

    tokio::spawn(async move {
        while let Some(Ok(msg)) = reader2.next().await {
            if let Message::Text(text) = msg {
                println!("Socket 2 received: {}", text.to_string());
            }
        }
    });

    send_msg(
        &mut writer1,
        &ClientMessage::Auth {
            game_id: GAME_ID.to_string(),
            user_id: WHITE_ID.to_string(),
        },
    )
    .await?;
    send_msg(
        &mut writer2,
        &ClientMessage::Auth {
            game_id: GAME_ID.to_string(),
            user_id: BLACK_ID.to_string(),
        },
    )
    .await?;

    send_msg(&mut writer1, &ClientMessage::Move("e4".to_string())).await?;
    send_msg(&mut writer2, &ClientMessage::Move("e5".to_string())).await?;

    send_msg(&mut writer1, &ClientMessage::Move("Qh5".to_string())).await?;
    send_msg(&mut writer2, &ClientMessage::Move("Nc6".to_string())).await?;

    send_msg(&mut writer1, &ClientMessage::Move("Bc4".to_string())).await?;
    send_msg(&mut writer2, &ClientMessage::Move("Nf6".to_string())).await?;

    send_msg(&mut writer1, &ClientMessage::Move("Qxf7#".to_string())).await?;
    Ok(())
}
</file>

<file path="src/bin/test.rs">
use std::time::Duration;

use axum::body::Bytes;
use futures_util::{
    stream::{SplitSink, SplitStream},
    SinkExt, StreamExt,
};
use tokio::{net::TcpStream, time::sleep};
use tokio_tungstenite::{
    connect_async,
    tungstenite::{Message, Utf8Bytes},
    MaybeTlsStream, WebSocketStream,
};
use ws_server::{message::ClientMessage, route::init::InitBody, HOST};

const GAME_ID: &'static str = "game";
const WHITE_ID: &'static str = "white";
const BLACK_ID: &'static str = "black";

async fn send_msg(
    writer: &mut SplitSink<WebSocketStream<MaybeTlsStream<TcpStream>>, Message>,
    msg: ClientMessage,
) -> anyhow::Result<()> {
    let msg = serde_json::to_string(&msg)?;
    writer.send(Message::Text(Utf8Bytes::from(&msg))).await?;
    sleep(Duration::from_millis(500)).await;
    Ok(())
}

fn spawn_reader(mut reader: SplitStream<WebSocketStream<MaybeTlsStream<TcpStream>>>) {
    tokio::spawn(async move {
        while let Some(Ok(Message::Text(text))) = reader.next().await {
            println!("Received: {}", text.to_string());
        }
    });
}

async fn connect_socket(
    url: &str,
) -> anyhow::Result<SplitSink<WebSocketStream<MaybeTlsStream<TcpStream>>, Message>> {
    let (socket, _) = connect_async(url).await?;
    let (writer, reader) = socket.split();

    spawn_reader(reader);

    Ok(writer)
}

async fn test_auth(url: &str) -> anyhow::Result<()> {
    {
        println!("should fail: not Message::Text");
        let mut writer = connect_socket(url).await?;

        writer
            .send(Message::Ping(Bytes::from_static(b"abc")))
            .await?;

        writer.close().await?;
    }
    {
        println!("should fail: deserialization");
        let mut writer = connect_socket(url).await?;

        writer
            .send(Message::Text(Utf8Bytes::from_static("abc")))
            .await?;

        writer.close().await?;
    }
    {
        println!("should fail: not-existent game");
        let mut writer = connect_socket(url).await?;

        send_msg(
            &mut writer,
            ClientMessage::Auth {
                game_id: "abc".to_string(),
                user_id: WHITE_ID.to_string(),
            },
        )
        .await?;

        writer.close().await?;
    }
    {
        println!("should fail: user not black or white");
        let mut writer = connect_socket(url).await?;

        send_msg(
            &mut writer,
            ClientMessage::Auth {
                game_id: GAME_ID.to_string(),
                user_id: "brown".to_string(),
            },
        )
        .await?;

        writer.close().await?;
    }
    {
        println!("should succeed: move, auth white");
        let mut writer = connect_socket(url).await?;

        send_msg(&mut writer, ClientMessage::Move("e4".to_string())).await?;
        send_msg(
            &mut writer,
            ClientMessage::Auth {
                game_id: GAME_ID.to_string(),
                user_id: WHITE_ID.to_string(),
            },
        )
        .await?;

        writer.close().await?;
    }
    {
        println!("should succeed: auth black");
        let mut writer = connect_socket(url).await?;

        send_msg(
            &mut writer,
            ClientMessage::Auth {
                game_id: GAME_ID.to_string(),
                user_id: BLACK_ID.to_string(),
            },
        )
        .await?;

        writer.close().await?;
    }
    {
        println!("should fail: white already connected");
        let mut writer1 = connect_socket(url).await?;
        let mut writer2 = connect_socket(url).await?;

        send_msg(
            &mut writer1,
            ClientMessage::Auth {
                game_id: GAME_ID.to_string(),
                user_id: WHITE_ID.to_string(),
            },
        )
        .await?;
        send_msg(
            &mut writer2,
            ClientMessage::Auth {
                game_id: GAME_ID.to_string(),
                user_id: WHITE_ID.to_string(),
            },
        )
        .await?;

        writer1.close().await?;
        writer2.close().await?;
    }
    {
        println!("should fail: black already connected");
        let mut writer1 = connect_socket(url).await?;
        let mut writer2 = connect_socket(url).await?;

        send_msg(
            &mut writer1,
            ClientMessage::Auth {
                game_id: GAME_ID.to_string(),
                user_id: BLACK_ID.to_string(),
            },
        )
        .await?;
        send_msg(
            &mut writer2,
            ClientMessage::Auth {
                game_id: GAME_ID.to_string(),
                user_id: BLACK_ID.to_string(),
            },
        )
        .await?;

        writer1.close().await?;
        writer2.close().await?;
    }
    Ok(())
}

async fn test_moves(url: &str) -> anyhow::Result<()> {
    {
        let mut writer_black = connect_socket(url).await?;
        let mut writer_white = connect_socket(url).await?;

        send_msg(
            &mut writer_white,
            ClientMessage::Auth {
                game_id: GAME_ID.to_string(),
                user_id: WHITE_ID.to_string(),
            },
        )
        .await?;
        send_msg(
            &mut writer_black,
            ClientMessage::Auth {
                game_id: GAME_ID.to_string(),
                user_id: BLACK_ID.to_string(),
            },
        )
        .await?;

        println!("should fail: deserialization");
        writer_black
            .send(Message::Text(Utf8Bytes::from_static("abc")))
            .await?;
        println!("should fail: invalid turn");
        send_msg(&mut writer_black, ClientMessage::Move("e5".to_string())).await?;
        println!("should fail: invalid move");
        send_msg(&mut writer_white, ClientMessage::Move("abc".to_string())).await?;
        println!("should fail: invalid move");
        send_msg(&mut writer_white, ClientMessage::Move("e5".to_string())).await?;
        println!("should succeed");
        send_msg(&mut writer_white, ClientMessage::Move("d4".to_string())).await?;
        println!("should fail: invalid turn");
        send_msg(&mut writer_white, ClientMessage::Move("e4".to_string())).await?;

        writer_white.close().await?;
        writer_black.close().await?;
    }

    Ok(())
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let url = format!("ws://{HOST}/ws",);

    // initialize new game
    let init_body = InitBody {
        game_id: GAME_ID.to_string(),
        white_user_id: WHITE_ID.to_string(),
        black_user_id: BLACK_ID.to_string(),
    };

    let client = reqwest::Client::new();
    client
        .post(format!("http://{HOST}/init"))
        .json(&init_body)
        .send()
        .await?;

    test_auth(&url).await?;

    test_moves(&url).await?;

    Ok(())
}
</file>

<file path="src/route/games.rs">
use axum::extract::State;

use crate::game_state::GameStateMap;

// for debugging, might remove this later
pub async fn get_games(State(state): State<GameStateMap>) -> String {
    tracing::info!("/GET games");
    let mut s = String::new();
    state.scan(|k, v| {
        s = format!(
            "{s}\n{{Game: {k}, Black: {}, White: {}}}",
            v.black_user_id, v.white_user_id
        );
    });
    s
}
</file>

<file path="src/route/init.rs">
use axum::{extract::State, http::StatusCode, Json};
use serde::{Deserialize, Serialize};
use ts_rs::TS;

use crate::game_state::{GameState, GameStateMap};

#[derive(Deserialize, Serialize, Debug, TS)]
#[ts(export)]
pub struct InitBody {
    pub game_id: String,
    pub white_user_id: String,
    pub black_user_id: String,
}

pub async fn post_init(
    State(state): State<GameStateMap>,
    Json(body): Json<InitBody>,
) -> (StatusCode, &'static str) {
    tracing::info!("/POST init");
    if state
        .insert(
            body.game_id,
            GameState::new(body.white_user_id, body.black_user_id),
        )
        .is_err()
    {
        tracing::error!("Game already exists");
        return (StatusCode::INTERNAL_SERVER_ERROR, "Game already exists");
    }
    (StatusCode::OK, "OK")
}
</file>

<file path="src/route/ws.rs">
use std::sync::Arc;

use axum::{
    extract::{
        ws::{Message, Utf8Bytes, WebSocket},
        State, WebSocketUpgrade,
    },
    response::Response,
};
use shakmaty::{san::San, Color, Position};
use tokio::sync::{
    broadcast,
    mpsc::{self, Receiver, Sender},
};

use crate::{
    game_state::GameStateMap,
    message::{ClientMessage, Error, ServerMessage},
    MAX_CHANNEL_CAPACITY,
};
use futures_util::{
    sink::SinkExt,
    stream::{SplitSink, SplitStream, StreamExt},
};

type Result<T> = std::result::Result<T, Error>;

struct Connection {
    pub game_id: String,
    pub color: Color,
    pub tx_broadcast: broadcast::Sender<ServerMessage>,
}

pub async fn ws_handler(ws: WebSocketUpgrade, State(state): State<GameStateMap>) -> Response {
    ws.on_upgrade(|socket| handle_socket(socket, state))
}

async fn send_msg(
    writer: &mut SplitSink<WebSocket, Message>,
    msg: &ServerMessage,
) -> std::result::Result<(), axum::Error> {
    writer
        .send(Message::Text(Utf8Bytes::from(
            serde_json::to_string(&msg).unwrap(),
        )))
        .await
}

async fn handle_socket(socket: WebSocket, state: GameStateMap) {
    tracing::info!("socket connected");

    let (mut writer, mut reader) = socket.split();
    let (tx_local, rx_local) = mpsc::channel(MAX_CHANNEL_CAPACITY);

    let connection = match auth_socket(&mut reader, &state).await {
        Ok(info) => {
            let msg = ServerMessage::AuthSuccess;
            let _ = send_msg(&mut writer, &msg).await;
            tracing::info!("auth success: {} {}", info.game_id, info.color);
            Arc::new(info)
        }
        Err(err) => {
            let msg = ServerMessage::Error(err);
            let _ = send_msg(&mut writer, &msg).await;
            tracing::error!("auth failed");
            return;
        }
    };

    state
        .get(&connection.game_id)
        .expect("game should exist")
        .connect(connection.color);

    let move_history = state
        .read(&connection.game_id, |_, v| v.moves.clone())
        .expect("game should exist");
    if send_msg(&mut writer, &ServerMessage::MoveHistory(move_history))
        .await
        .is_err()
    {
        return;
    }

    let rx_broadcast = connection.tx_broadcast.subscribe();

    let mut read_task = tokio::spawn(handle_socket_read(
        reader,
        state.clone(),
        connection.clone(),
        tx_local,
    ));
    let mut write_task = tokio::spawn(handle_socket_write(writer, rx_broadcast, rx_local));

    // let _ = write_task.await;
    // read_task.abort();
    tokio::select! {
        _ = &mut read_task => write_task.abort(),
        _ = &mut write_task => read_task.abort()
    }

    tracing::info!("socket closing {} {}", connection.game_id, connection.color);

    state
        .get(&connection.game_id)
        .expect("game should exist")
        .disconnect(connection.color);
    // TODO: clean up things
}

async fn auth_socket(
    socket: &mut SplitStream<WebSocket>,
    state: &GameStateMap,
) -> Result<Connection> {
    while let Some(Ok(Message::Text(text))) = socket.next().await {
        let client_msg: ClientMessage = match serde_json::from_str(text.as_str()) {
            Ok(msg) => msg,
            Err(_) => return Err(Error::Deserialization),
        };

        if let ClientMessage::Auth { game_id, user_id } = client_msg {
            return state
                .read(&game_id, |_, v| {
                    if v.black_user_id == user_id && !v.black_connected {
                        return Ok(Connection {
                            game_id: game_id.clone(),
                            color: Color::Black,
                            tx_broadcast: v.tx_broadcast.clone(),
                        });
                    } else if v.white_user_id == user_id && !v.white_connected {
                        return Ok(Connection {
                            game_id: game_id.clone(),
                            color: Color::White,
                            tx_broadcast: v.tx_broadcast.clone(),
                        });
                    }
                    Err(Error::Unauthorized)
                })
                .unwrap_or(Err(Error::Unauthorized));
        }
    }

    Err(Error::Unauthorized)
}

async fn handle_socket_read(
    mut reader: SplitStream<WebSocket>,
    state: GameStateMap,
    connection: Arc<Connection>,
    #[allow(unused_variables)] tx_local: Sender<ServerMessage>,
) {
    while let Some(Ok(Message::Text(text))) = reader.next().await {
        let client_msg: ClientMessage = match serde_json::from_str(&text.to_string()) {
            Ok(msg) => msg,
            Err(_) => {
                let _ = tx_local
                    .send(ServerMessage::Error(Error::Deserialization))
                    .await;
                tracing::error!("deserialization failed");
                continue;
            }
        };

        if let ClientMessage::Move(san_str) = client_msg {
            // check if is current player turn
            if !state
                .read(&connection.game_id, |_, v| {
                    connection.color == v.board.turn()
                })
                .expect("game should exist")
            // game existence is validated from auth step
            {
                let _ = tx_local
                    .send(ServerMessage::Error(Error::InvalidTurn))
                    .await;
                tracing::error!("invalid turn");
                continue;
            }

            let san: San = match san_str.parse() {
                Ok(san) => san,
                Err(_) => {
                    let _ = tx_local
                        .send(ServerMessage::Error(Error::InvalidMove))
                        .await;
                    tracing::error!("invalid move");
                    continue;
                }
            };

            let m = match state
                .read(&connection.game_id, |_, v| san.to_move(&v.board))
                .expect("game should exist")
            {
                Ok(m) => m,
                Err(_) => {
                    let _ = tx_local
                        .send(ServerMessage::Error(Error::InvalidMove))
                        .await;
                    tracing::error!("invalid move");
                    continue;
                }
            };

            state
                .get(&connection.game_id)
                .expect("game should exist")
                .board
                .play_unchecked(&m); // move is already validated when calling `san.to_move`

            tracing::info!("broadcasting move {san_str}");
            connection
                .tx_broadcast
                .send(ServerMessage::Move(san_str.clone()))
                .unwrap();

            state
                .get(&connection.game_id)
                .expect("game should exist")
                .moves
                .push(san_str.clone());

            let outcome = state
                .read(&connection.game_id, |_, v| v.board.outcome())
                .expect("game should exist");

            if let Some(outcome) = outcome {
                connection
                    .tx_broadcast
                    .send(ServerMessage::GameEnd(outcome))
                    .unwrap();
                tracing::info!("game ended {} {}", connection.game_id, outcome);
            }
        }
    }
}

async fn handle_socket_write(
    mut writer: SplitSink<WebSocket, Message>,
    mut rx_broadcast: broadcast::Receiver<ServerMessage>,
    mut rx_local: Receiver<ServerMessage>,
) {
    loop {
        tokio::select! {
            Ok(msg) = rx_broadcast.recv() => {
                if send_msg(&mut writer, &msg).await
                    .is_err()
                {
                    tracing::error!("socket send failed");
                    break;
                }
                if msg.is_game_end() {
                    break;
                }
            }
            Some(msg) = rx_local.recv() => {
                if send_msg(&mut writer, &msg).await
                    .is_err()
                {
                    tracing::error!("socket send failed");
                    break;
                }
            }
        }
    }
}
</file>

<file path="src/game_state.rs">
use std::sync::Arc;

use scc::HashMap;
use shakmaty::{Chess, Color};
use tokio::sync::broadcast;

use crate::{message::ServerMessage, MAX_CHANNEL_CAPACITY};

pub struct GameState {
    pub white_user_id: String,
    pub black_user_id: String,
    pub white_connected: bool,
    pub black_connected: bool,
    pub board: Chess,
    pub tx_broadcast: broadcast::Sender<ServerMessage>,
    pub moves: Vec<String>,
}

impl GameState {
    pub fn new(white_user_id: String, black_user_id: String) -> Self {
        let (tx, _) = broadcast::channel(MAX_CHANNEL_CAPACITY);
        GameState {
            white_user_id,
            black_user_id,
            white_connected: false,
            black_connected: false,
            board: Chess::default(),
            tx_broadcast: tx,
            moves: Vec::new(),
        }
    }

    pub fn connect(&mut self, color: Color) {
        match color {
            Color::Black => {
                assert!(!self.black_connected);
                self.black_connected = true;
            }
            Color::White => {
                assert!(!self.white_connected);
                self.white_connected = true;
            }
        }
    }

    pub fn disconnect(&mut self, color: Color) {
        match color {
            Color::Black => {
                assert!(self.black_connected);
                self.black_connected = false;
            }
            Color::White => {
                assert!(self.white_connected);
                self.white_connected = false;
            }
        }
    }
}

pub type GameStateMap = Arc<HashMap<String, GameState>>;
</file>

<file path="src/lib.rs">
pub mod game_state;
pub mod message;
pub mod route;

pub const MAX_CHANNEL_CAPACITY: usize = 64;
pub const HOST: &'static str = "0.0.0.0:3000";
</file>

<file path="src/main.rs">
use std::sync::Arc;

use axum::{
    routing::{any, get, post},
    Router,
};
use scc::HashMap;
use ws_server::{
    game_state::GameStateMap,
    route::{games::get_games, init::post_init, ws::ws_handler},
    HOST,
};

#[tokio::main]
async fn main() {
    tracing_subscriber::fmt::init();
    let state: GameStateMap = Arc::new(HashMap::new());

    let app = Router::new()
        .route("/ws", any(ws_handler))
        .route("/init", post(post_init))
        .route("/games", get(get_games))
        .with_state(state);

    let listener = tokio::net::TcpListener::bind(HOST).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}
</file>

<file path="src/message.rs">
use serde::{Deserialize, Serialize};
use ts_rs::TS;

#[derive(Serialize, Deserialize, Debug, Clone, TS)]
#[ts(export)]
pub enum Error {
    Deserialization,
    Unauthorized,
    InvalidTurn,
    InvalidMove,
}

#[derive(Serialize, Deserialize, Debug, TS)]
#[serde(tag = "kind", content = "value")]
#[ts(export)]
pub enum ClientMessage {
    Auth { game_id: String, user_id: String },
    Move(String),
}

#[derive(Serialize, Deserialize, TS)]
#[serde(remote = "shakmaty::Color")]
#[ts(export)]
enum Color {
    Black = 0,
    White = 1,
}

// why shakmaty does not derive this???
#[derive(Serialize, Deserialize, TS)]
#[serde(remote = "shakmaty::Outcome")]
#[ts(export)]
enum Outcome {
    Decisive {
        #[serde(with = "Color")]
        #[ts(as = "Color")]
        winner: shakmaty::Color,
    },
    Draw,
}

#[derive(Serialize, Debug, Clone, TS)]
#[serde(tag = "kind", content = "value")]
#[ts(export)]
pub enum ServerMessage {
    Move(String),
    GameEnd(
        #[serde(with = "Outcome")]
        #[ts(as = "Outcome")]
        shakmaty::Outcome,
    ),
    Error(Error),
    AuthSuccess,
    MoveHistory(Vec<String>),
}

impl ServerMessage {
    pub fn is_game_end(&self) -> bool {
        match self {
            Self::GameEnd(_) => true,
            _ => false,
        }
    }
}
</file>

<file path="src/route.rs">
pub mod games;
pub mod init;
pub mod ws;
</file>

<file path=".gitignore">
# Generated by Cargo
# will have compiled files and executables
debug/
target/

# These are backup files generated by rustfmt
**/*.rs.bk

# MSVC Windows builds of rustc generate these, which store debugging information
*.pdb

# RustRover
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/
</file>

<file path="Cargo.toml">
[package]
name = "ws_server"
version = "0.1.0"
edition = "2021"
default-run = "ws_server"

[dependencies]
anyhow = "1.0.97"
axum = { version = "0.8.3", features = ["ws"] }
axum-macros = "0.5.0"
futures-util = "0.3.31"
reqwest = { version = "0.12.15", features = ["json"] }
scc = "2.3.3"
serde = { version = "1.0.219", features = ["derive"] }
serde_json = "1.0.140"
shakmaty = { version = "0.27.3", features = ["serde"] }
tokio = { version = "1.44.1", features = ["full"] }
tokio-tungstenite = "0.26.2"
tracing = "0.1.41"
tracing-subscriber = "0.3.19"
ts-rs = "10.1.0"
</file>

</files>
