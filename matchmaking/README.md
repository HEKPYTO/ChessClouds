# ChessClouds Matchmaking Service

The Matchmaking Service is responsible for pairing players for chess games on the ChessClouds platform.

## Architecture

The Matchmaking Service is built in Rust using:

- Axum web framework
- Tokio asynchronous runtime
- SQLx

## API Endpoints

### POST `/match`

**Request format:**

```json
{
  "user_id": ""
}
```

**Successful response**

```json
{
  "result": "Ok",
  "value": {
    "game_id": "",
    "color": "White"
  }
}
```

**Error response**

```json
{
  "result": "Err",
  "value": "Player already in queue"
}
```

## Implementation Details

The service has the following components:

1. **Queue** - A thread-safe queue holding players requesting a match
2. **Matcher** - An async task responsible for popping the queue and pair players. The task gets notified by request handler on a new match request using an async channel to avoid polling.

## Flow

1. Player makes a request to `/match` with their user ID
2. Player is added to the matching queue, the matcher task is notified
3. Matcher task finds another player in the queue
4. New game is created in the database with both players
5. Each player receives their game assignment and color
6. Players connect to the WebSocket server to begin the game

If at any point the request is aborted, the match request will be automatically cleaned up from the queue.

## Setup and Development

### Prerequisites

- Rust
- PostgreSQL database

### Local Development

1. Create an `.env` file with a variable `DATABASE_URL`.
2. Run the service

```bash
cargo run
```

### Docker Deployment

```bash
docker build -t chessclouds-matchmaking .
docker run -p 8001:8001 -e DATABASE_URL=postgres://user:password@host/db chessclouds-matchmaking
```

## TypeScript Bindings

TypeScript type definitions can be generated by running `cargo test`.

